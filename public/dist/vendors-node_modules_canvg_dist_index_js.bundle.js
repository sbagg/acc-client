(self["webpackChunkac_client2"] = self["webpackChunkac_client2"] || []).push([["vendors-node_modules_canvg_dist_index_js"],{

/***/ "./node_modules/performance-now/lib/performance-now.js":
/*!*************************************************************!*\
  !*** ./node_modules/performance-now/lib/performance-now.js ***!
  \*************************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

//# sourceMappingURL=performance-now.js.map


/***/ }),

/***/ "./node_modules/raf/index.js":
/*!***********************************!*\
  !*** ./node_modules/raf/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var now = __webpack_require__(/*! performance-now */ "./node_modules/performance-now/lib/performance-now.js")
  , root = typeof window === 'undefined' ? __webpack_require__.g : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}


/***/ }),

/***/ "./node_modules/rgbcolor/index.js":
/*!****************************************!*\
  !*** ./node_modules/rgbcolor/index.js ***!
  \****************************************/
/***/ ((module) => {

/*
	Based on rgbcolor.js by Stoyan Stefanov <sstoo@gmail.com>
	http://www.phpied.com/rgb-color-parser-in-javascript/
*/

module.exports = function(color_string) {
    this.ok = false;
    this.alpha = 1.0;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        rebeccapurple: '663399',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    color_string = simple_colors[color_string] || color_string;
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
            example: ['rgba(123, 234, 45, 0.8)', 'rgba(255,234,245,1.0)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3]),
                    parseFloat(bits[4])
                ];
            }
        },
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            var channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            if (channels.length > 3) {
                this.alpha = channels[3];
            }
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);
    this.alpha = (this.alpha < 0) ? 0 : ((this.alpha > 1.0 || isNaN(this.alpha)) ? 1.0 : this.alpha);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toRGBA = function () {
        return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.alpha + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}


/***/ }),

/***/ "./node_modules/stackblur-canvas/dist/stackblur-es.js":
/*!************************************************************!*\
  !*** ./node_modules/stackblur-canvas/dist/stackblur-es.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlurStack": () => (/* binding */ BlurStack),
/* harmony export */   "canvasRGB": () => (/* binding */ processCanvasRGB),
/* harmony export */   "canvasRGBA": () => (/* binding */ processCanvasRGBA),
/* harmony export */   "image": () => (/* binding */ processImage),
/* harmony export */   "imageDataRGB": () => (/* binding */ processImageDataRGB),
/* harmony export */   "imageDataRGBA": () => (/* binding */ processImageDataRGBA)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/* eslint-disable no-bitwise -- used for calculations */

/* eslint-disable unicorn/prefer-query-selector -- aiming at
  backward-compatibility */

/**
* StackBlur - a fast almost Gaussian Blur For Canvas
*
* In case you find this class useful - especially in commercial projects -
* I am not totally unhappy for a small donation to my PayPal account
* mario@quasimondo.de
*
* Or support me on flattr:
* {@link https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript}.
*
* @module StackBlur
* @author Mario Klingemann
* Contact: mario@quasimondo.com
* Website: {@link http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html}
* Twitter: @quasimondo
*
* @copyright (c) 2010 Mario Klingemann
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/
var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
var shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
/**
 * @param {string|HTMLImageElement} img
 * @param {string|HTMLCanvasElement} canvas
 * @param {Float} radius
 * @param {boolean} blurAlphaChannel
 * @param {boolean} useOffset
 * @param {boolean} skipStyles
 * @returns {undefined}
 */

function processImage(img, canvas, radius, blurAlphaChannel, useOffset, skipStyles) {
  if (typeof img === 'string') {
    img = document.getElementById(img);
  }

  if (!img || !('naturalWidth' in img)) {
    return;
  }

  var dimensionType = useOffset ? 'offset' : 'natural';
  var w = img[dimensionType + 'Width'];
  var h = img[dimensionType + 'Height'];

  if (typeof canvas === 'string') {
    canvas = document.getElementById(canvas);
  }

  if (!canvas || !('getContext' in canvas)) {
    return;
  }

  if (!skipStyles) {
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }

  canvas.width = w;
  canvas.height = h;
  var context = canvas.getContext('2d');
  context.clearRect(0, 0, w, h);
  context.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, 0, 0, w, h);

  if (isNaN(radius) || radius < 1) {
    return;
  }

  if (blurAlphaChannel) {
    processCanvasRGBA(canvas, 0, 0, w, h, radius);
  } else {
    processCanvasRGB(canvas, 0, 0, w, h, radius);
  }
}
/**
 * @param {string|HTMLCanvasElement} canvas
 * @param {Integer} topX
 * @param {Integer} topY
 * @param {Integer} width
 * @param {Integer} height
 * @throws {Error|TypeError}
 * @returns {ImageData} See {@link https://html.spec.whatwg.org/multipage/canvas.html#imagedata}
 */


function getImageDataFromCanvas(canvas, topX, topY, width, height) {
  if (typeof canvas === 'string') {
    canvas = document.getElementById(canvas);
  }

  if (!canvas || _typeof(canvas) !== 'object' || !('getContext' in canvas)) {
    throw new TypeError('Expecting canvas with `getContext` method ' + 'in processCanvasRGB(A) calls!');
  }

  var context = canvas.getContext('2d');

  try {
    return context.getImageData(topX, topY, width, height);
  } catch (e) {
    throw new Error('unable to access image data: ' + e);
  }
}
/**
 * @param {HTMLCanvasElement} canvas
 * @param {Integer} topX
 * @param {Integer} topY
 * @param {Integer} width
 * @param {Integer} height
 * @param {Float} radius
 * @returns {undefined}
 */


function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }

  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
  canvas.getContext('2d').putImageData(imageData, topX, topY);
}
/**
 * @param {ImageData} imageData
 * @param {Integer} topX
 * @param {Integer} topY
 * @param {Integer} width
 * @param {Integer} height
 * @param {Float} radius
 * @returns {ImageData}
 */


function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1; // const w4 = width << 2;

  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;

  for (var i = 1; i < div; i++) {
    stack = stack.next = new BlurStack();

    if (i === radiusPlus1) {
      stackEnd = stack;
    }
  }

  stack.next = stackStart;
  var stackIn = null,
      stackOut = null,
      yw = 0,
      yi = 0;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];

  for (var y = 0; y < height; y++) {
    stack = stackStart;
    var pr = pixels[yi],
        pg = pixels[yi + 1],
        pb = pixels[yi + 2],
        pa = pixels[yi + 3];

    for (var _i = 0; _i < radiusPlus1; _i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }

    var rInSum = 0,
        gInSum = 0,
        bInSum = 0,
        aInSum = 0,
        rOutSum = radiusPlus1 * pr,
        gOutSum = radiusPlus1 * pg,
        bOutSum = radiusPlus1 * pb,
        aOutSum = radiusPlus1 * pa,
        rSum = sumFactor * pr,
        gSum = sumFactor * pg,
        bSum = sumFactor * pb,
        aSum = sumFactor * pa;

    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
      var p = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
      var r = pixels[p],
          g = pixels[p + 1],
          b = pixels[p + 2],
          a = pixels[p + 3];
      var rbs = radiusPlus1 - _i2;
      rSum += (stack.r = r) * rbs;
      gSum += (stack.g = g) * rbs;
      bSum += (stack.b = b) * rbs;
      aSum += (stack.a = a) * rbs;
      rInSum += r;
      gInSum += g;
      bInSum += b;
      aInSum += a;
      stack = stack.next;
    }

    stackIn = stackStart;
    stackOut = stackEnd;

    for (var x = 0; x < width; x++) {
      var paInitial = aSum * mulSum >> shgSum;
      pixels[yi + 3] = paInitial;

      if (paInitial !== 0) {
        var _a2 = 255 / paInitial;

        pixels[yi] = (rSum * mulSum >> shgSum) * _a2;
        pixels[yi + 1] = (gSum * mulSum >> shgSum) * _a2;
        pixels[yi + 2] = (bSum * mulSum >> shgSum) * _a2;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }

      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      aOutSum -= stackIn.a;

      var _p = x + radius + 1;

      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[_p];
      gInSum += stackIn.g = pixels[_p + 1];
      bInSum += stackIn.b = pixels[_p + 2];
      aInSum += stackIn.a = pixels[_p + 3];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackIn = stackIn.next;
      var _stackOut = stackOut,
          _r = _stackOut.r,
          _g = _stackOut.g,
          _b = _stackOut.b,
          _a = _stackOut.a;
      rOutSum += _r;
      gOutSum += _g;
      bOutSum += _b;
      aOutSum += _a;
      rInSum -= _r;
      gInSum -= _g;
      bInSum -= _b;
      aInSum -= _a;
      stackOut = stackOut.next;
      yi += 4;
    }

    yw += width;
  }

  for (var _x = 0; _x < width; _x++) {
    yi = _x << 2;

    var _pr = pixels[yi],
        _pg = pixels[yi + 1],
        _pb = pixels[yi + 2],
        _pa = pixels[yi + 3],
        _rOutSum = radiusPlus1 * _pr,
        _gOutSum = radiusPlus1 * _pg,
        _bOutSum = radiusPlus1 * _pb,
        _aOutSum = radiusPlus1 * _pa,
        _rSum = sumFactor * _pr,
        _gSum = sumFactor * _pg,
        _bSum = sumFactor * _pb,
        _aSum = sumFactor * _pa;

    stack = stackStart;

    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
      stack.r = _pr;
      stack.g = _pg;
      stack.b = _pb;
      stack.a = _pa;
      stack = stack.next;
    }

    var yp = width;
    var _gInSum = 0,
        _bInSum = 0,
        _aInSum = 0,
        _rInSum = 0;

    for (var _i4 = 1; _i4 <= radius; _i4++) {
      yi = yp + _x << 2;

      var _rbs = radiusPlus1 - _i4;

      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
      _rInSum += _pr;
      _gInSum += _pg;
      _bInSum += _pb;
      _aInSum += _pa;
      stack = stack.next;

      if (_i4 < heightMinus1) {
        yp += width;
      }
    }

    yi = _x;
    stackIn = stackStart;
    stackOut = stackEnd;

    for (var _y = 0; _y < height; _y++) {
      var _p2 = yi << 2;

      pixels[_p2 + 3] = _pa = _aSum * mulSum >> shgSum;

      if (_pa > 0) {
        _pa = 255 / _pa;
        pixels[_p2] = (_rSum * mulSum >> shgSum) * _pa;
        pixels[_p2 + 1] = (_gSum * mulSum >> shgSum) * _pa;
        pixels[_p2 + 2] = (_bSum * mulSum >> shgSum) * _pa;
      } else {
        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
      }

      _rSum -= _rOutSum;
      _gSum -= _gOutSum;
      _bSum -= _bOutSum;
      _aSum -= _aOutSum;
      _rOutSum -= stackIn.r;
      _gOutSum -= stackIn.g;
      _bOutSum -= stackIn.b;
      _aOutSum -= stackIn.a;
      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
      _rSum += _rInSum += stackIn.r = pixels[_p2];
      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
      stackIn = stackIn.next;
      _rOutSum += _pr = stackOut.r;
      _gOutSum += _pg = stackOut.g;
      _bOutSum += _pb = stackOut.b;
      _aOutSum += _pa = stackOut.a;
      _rInSum -= _pr;
      _gInSum -= _pg;
      _bInSum -= _pb;
      _aInSum -= _pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }

  return imageData;
}
/**
 * @param {HTMLCanvasElement} canvas
 * @param {Integer} topX
 * @param {Integer} topY
 * @param {Integer} width
 * @param {Integer} height
 * @param {Float} radius
 * @returns {undefined}
 */


function processCanvasRGB(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }

  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGB(imageData, topX, topY, width, height, radius);
  canvas.getContext('2d').putImageData(imageData, topX, topY);
}
/**
 * @param {ImageData} imageData
 * @param {Integer} topX
 * @param {Integer} topY
 * @param {Integer} width
 * @param {Integer} height
 * @param {Float} radius
 * @returns {ImageData}
 */


function processImageDataRGB(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1; // const w4 = width << 2;

  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;

  for (var i = 1; i < div; i++) {
    stack = stack.next = new BlurStack();

    if (i === radiusPlus1) {
      stackEnd = stack;
    }
  }

  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];
  var p, rbs;
  var yw = 0,
      yi = 0;

  for (var y = 0; y < height; y++) {
    var pr = pixels[yi],
        pg = pixels[yi + 1],
        pb = pixels[yi + 2],
        rOutSum = radiusPlus1 * pr,
        gOutSum = radiusPlus1 * pg,
        bOutSum = radiusPlus1 * pb,
        rSum = sumFactor * pr,
        gSum = sumFactor * pg,
        bSum = sumFactor * pb;
    stack = stackStart;

    for (var _i5 = 0; _i5 < radiusPlus1; _i5++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack = stack.next;
    }

    var rInSum = 0,
        gInSum = 0,
        bInSum = 0;

    for (var _i6 = 1; _i6 < radiusPlus1; _i6++) {
      p = yi + ((widthMinus1 < _i6 ? widthMinus1 : _i6) << 2);
      rSum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - _i6);
      gSum += (stack.g = pg = pixels[p + 1]) * rbs;
      bSum += (stack.b = pb = pixels[p + 2]) * rbs;
      rInSum += pr;
      gInSum += pg;
      bInSum += pb;
      stack = stack.next;
    }

    stackIn = stackStart;
    stackOut = stackEnd;

    for (var x = 0; x < width; x++) {
      pixels[yi] = rSum * mulSum >> shgSum;
      pixels[yi + 1] = gSum * mulSum >> shgSum;
      pixels[yi + 2] = bSum * mulSum >> shgSum;
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[p];
      gInSum += stackIn.g = pixels[p + 1];
      bInSum += stackIn.b = pixels[p + 2];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      stackIn = stackIn.next;
      rOutSum += pr = stackOut.r;
      gOutSum += pg = stackOut.g;
      bOutSum += pb = stackOut.b;
      rInSum -= pr;
      gInSum -= pg;
      bInSum -= pb;
      stackOut = stackOut.next;
      yi += 4;
    }

    yw += width;
  }

  for (var _x2 = 0; _x2 < width; _x2++) {
    yi = _x2 << 2;

    var _pr2 = pixels[yi],
        _pg2 = pixels[yi + 1],
        _pb2 = pixels[yi + 2],
        _rOutSum2 = radiusPlus1 * _pr2,
        _gOutSum2 = radiusPlus1 * _pg2,
        _bOutSum2 = radiusPlus1 * _pb2,
        _rSum2 = sumFactor * _pr2,
        _gSum2 = sumFactor * _pg2,
        _bSum2 = sumFactor * _pb2;

    stack = stackStart;

    for (var _i7 = 0; _i7 < radiusPlus1; _i7++) {
      stack.r = _pr2;
      stack.g = _pg2;
      stack.b = _pb2;
      stack = stack.next;
    }

    var _rInSum2 = 0,
        _gInSum2 = 0,
        _bInSum2 = 0;

    for (var _i8 = 1, yp = width; _i8 <= radius; _i8++) {
      yi = yp + _x2 << 2;
      _rSum2 += (stack.r = _pr2 = pixels[yi]) * (rbs = radiusPlus1 - _i8);
      _gSum2 += (stack.g = _pg2 = pixels[yi + 1]) * rbs;
      _bSum2 += (stack.b = _pb2 = pixels[yi + 2]) * rbs;
      _rInSum2 += _pr2;
      _gInSum2 += _pg2;
      _bInSum2 += _pb2;
      stack = stack.next;

      if (_i8 < heightMinus1) {
        yp += width;
      }
    }

    yi = _x2;
    stackIn = stackStart;
    stackOut = stackEnd;

    for (var _y2 = 0; _y2 < height; _y2++) {
      p = yi << 2;
      pixels[p] = _rSum2 * mulSum >> shgSum;
      pixels[p + 1] = _gSum2 * mulSum >> shgSum;
      pixels[p + 2] = _bSum2 * mulSum >> shgSum;
      _rSum2 -= _rOutSum2;
      _gSum2 -= _gOutSum2;
      _bSum2 -= _bOutSum2;
      _rOutSum2 -= stackIn.r;
      _gOutSum2 -= stackIn.g;
      _bOutSum2 -= stackIn.b;
      p = _x2 + ((p = _y2 + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
      _rSum2 += _rInSum2 += stackIn.r = pixels[p];
      _gSum2 += _gInSum2 += stackIn.g = pixels[p + 1];
      _bSum2 += _bInSum2 += stackIn.b = pixels[p + 2];
      stackIn = stackIn.next;
      _rOutSum2 += _pr2 = stackOut.r;
      _gOutSum2 += _pg2 = stackOut.g;
      _bOutSum2 += _pb2 = stackOut.b;
      _rInSum2 -= _pr2;
      _gInSum2 -= _pg2;
      _bInSum2 -= _pb2;
      stackOut = stackOut.next;
      yi += width;
    }
  }

  return imageData;
}
/**
 *
 */


var BlurStack =
/**
 * Set properties.
 */
function BlurStack() {
  _classCallCheck(this, BlurStack);

  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
};




/***/ }),

/***/ "./node_modules/canvg/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/canvg/dist/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AElement": () => (/* binding */ AElement),
/* harmony export */   "AnimateColorElement": () => (/* binding */ AnimateColorElement),
/* harmony export */   "AnimateElement": () => (/* binding */ AnimateElement),
/* harmony export */   "AnimateTransformElement": () => (/* binding */ AnimateTransformElement),
/* harmony export */   "BoundingBox": () => (/* binding */ BoundingBox),
/* harmony export */   "CB1": () => (/* binding */ CB1),
/* harmony export */   "CB2": () => (/* binding */ CB2),
/* harmony export */   "CB3": () => (/* binding */ CB3),
/* harmony export */   "CB4": () => (/* binding */ CB4),
/* harmony export */   "Canvg": () => (/* binding */ Canvg),
/* harmony export */   "CircleElement": () => (/* binding */ CircleElement),
/* harmony export */   "ClipPathElement": () => (/* binding */ ClipPathElement),
/* harmony export */   "DefsElement": () => (/* binding */ DefsElement),
/* harmony export */   "DescElement": () => (/* binding */ DescElement),
/* harmony export */   "Document": () => (/* binding */ Document),
/* harmony export */   "Element": () => (/* binding */ Element),
/* harmony export */   "EllipseElement": () => (/* binding */ EllipseElement),
/* harmony export */   "FeColorMatrixElement": () => (/* binding */ FeColorMatrixElement),
/* harmony export */   "FeCompositeElement": () => (/* binding */ FeCompositeElement),
/* harmony export */   "FeDropShadowElement": () => (/* binding */ FeDropShadowElement),
/* harmony export */   "FeGaussianBlurElement": () => (/* binding */ FeGaussianBlurElement),
/* harmony export */   "FeMorphologyElement": () => (/* binding */ FeMorphologyElement),
/* harmony export */   "FilterElement": () => (/* binding */ FilterElement),
/* harmony export */   "Font": () => (/* binding */ Font),
/* harmony export */   "FontElement": () => (/* binding */ FontElement),
/* harmony export */   "FontFaceElement": () => (/* binding */ FontFaceElement),
/* harmony export */   "GElement": () => (/* binding */ GElement),
/* harmony export */   "GlyphElement": () => (/* binding */ GlyphElement),
/* harmony export */   "GradientElement": () => (/* binding */ GradientElement),
/* harmony export */   "ImageElement": () => (/* binding */ ImageElement),
/* harmony export */   "LineElement": () => (/* binding */ LineElement),
/* harmony export */   "LinearGradientElement": () => (/* binding */ LinearGradientElement),
/* harmony export */   "MarkerElement": () => (/* binding */ MarkerElement),
/* harmony export */   "MaskElement": () => (/* binding */ MaskElement),
/* harmony export */   "Matrix": () => (/* binding */ Matrix),
/* harmony export */   "MissingGlyphElement": () => (/* binding */ MissingGlyphElement),
/* harmony export */   "Mouse": () => (/* binding */ Mouse),
/* harmony export */   "PSEUDO_ZERO": () => (/* binding */ PSEUDO_ZERO),
/* harmony export */   "Parser": () => (/* binding */ Parser),
/* harmony export */   "PathElement": () => (/* binding */ PathElement),
/* harmony export */   "PathParser": () => (/* binding */ PathParser),
/* harmony export */   "PatternElement": () => (/* binding */ PatternElement),
/* harmony export */   "Point": () => (/* binding */ Point),
/* harmony export */   "PolygonElement": () => (/* binding */ PolygonElement),
/* harmony export */   "PolylineElement": () => (/* binding */ PolylineElement),
/* harmony export */   "Property": () => (/* binding */ Property),
/* harmony export */   "QB1": () => (/* binding */ QB1),
/* harmony export */   "QB2": () => (/* binding */ QB2),
/* harmony export */   "QB3": () => (/* binding */ QB3),
/* harmony export */   "RadialGradientElement": () => (/* binding */ RadialGradientElement),
/* harmony export */   "RectElement": () => (/* binding */ RectElement),
/* harmony export */   "RenderedElement": () => (/* binding */ RenderedElement),
/* harmony export */   "Rotate": () => (/* binding */ Rotate),
/* harmony export */   "SVGElement": () => (/* binding */ SVGElement),
/* harmony export */   "SVGFontLoader": () => (/* binding */ SVGFontLoader),
/* harmony export */   "Scale": () => (/* binding */ Scale),
/* harmony export */   "Screen": () => (/* binding */ Screen),
/* harmony export */   "Skew": () => (/* binding */ Skew),
/* harmony export */   "SkewX": () => (/* binding */ SkewX),
/* harmony export */   "SkewY": () => (/* binding */ SkewY),
/* harmony export */   "StopElement": () => (/* binding */ StopElement),
/* harmony export */   "StyleElement": () => (/* binding */ StyleElement),
/* harmony export */   "SymbolElement": () => (/* binding */ SymbolElement),
/* harmony export */   "TRefElement": () => (/* binding */ TRefElement),
/* harmony export */   "TSpanElement": () => (/* binding */ TSpanElement),
/* harmony export */   "TextElement": () => (/* binding */ TextElement),
/* harmony export */   "TextPathElement": () => (/* binding */ TextPathElement),
/* harmony export */   "TitleElement": () => (/* binding */ TitleElement),
/* harmony export */   "Transform": () => (/* binding */ Transform),
/* harmony export */   "Translate": () => (/* binding */ Translate),
/* harmony export */   "UnknownElement": () => (/* binding */ UnknownElement),
/* harmony export */   "UseElement": () => (/* binding */ UseElement),
/* harmony export */   "ViewPort": () => (/* binding */ ViewPort),
/* harmony export */   "compressSpaces": () => (/* binding */ compressSpaces),
/* harmony export */   "elements": () => (/* binding */ elements),
/* harmony export */   "getSelectorSpecificity": () => (/* binding */ getSelectorSpecificity),
/* harmony export */   "normalizeAttributeName": () => (/* binding */ normalizeAttributeName),
/* harmony export */   "normalizeColor": () => (/* binding */ normalizeColor),
/* harmony export */   "parseExternalUrl": () => (/* binding */ parseExternalUrl),
/* harmony export */   "presets": () => (/* binding */ index),
/* harmony export */   "toMatrixValue": () => (/* binding */ toMatrixValue),
/* harmony export */   "toNumbers": () => (/* binding */ toNumbers),
/* harmony export */   "trimLeft": () => (/* binding */ trimLeft),
/* harmony export */   "trimRight": () => (/* binding */ trimRight),
/* harmony export */   "vectorMagnitude": () => (/* binding */ vectorMagnitude),
/* harmony export */   "vectorsAngle": () => (/* binding */ vectorsAngle),
/* harmony export */   "vectorsRatio": () => (/* binding */ vectorsRatio)
/* harmony export */ });
/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! raf */ "./node_modules/raf/index.js");
/* harmony import */ var rgbcolor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rgbcolor */ "./node_modules/rgbcolor/index.js");
/* harmony import */ var svg_pathdata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svg-pathdata */ "./node_modules/svg-pathdata/lib/SVGPathData.module.js");
/* harmony import */ var stackblur_canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stackblur-canvas */ "./node_modules/stackblur-canvas/dist/stackblur-es.js");





/**
 * Options preset for `OffscreenCanvas`.
 * @param config - Preset requirements.
 * @param config.DOMParser - XML/HTML parser from string into DOM Document.
 * @returns Preset object.
 */ function offscreen() {
    let { DOMParser: DOMParserFallback  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const preset = {
        window: null,
        ignoreAnimation: true,
        ignoreMouse: true,
        DOMParser: DOMParserFallback,
        createCanvas (width, height) {
            return new OffscreenCanvas(width, height);
        },
        async createImage (url) {
            const response = await fetch(url);
            const blob = await response.blob();
            const img = await createImageBitmap(blob);
            return img;
        }
    };
    if (typeof globalThis.DOMParser !== 'undefined' || typeof DOMParserFallback === 'undefined') {
        Reflect.deleteProperty(preset, 'DOMParser');
    }
    return preset;
}

/**
 * Options preset for `node-canvas`.
 * @param config - Preset requirements.
 * @param config.DOMParser - XML/HTML parser from string into DOM Document.
 * @param config.canvas - `node-canvas` exports.
 * @param config.fetch - WHATWG-compatible `fetch` function.
 * @returns Preset object.
 */ function node(param) {
    let { DOMParser , canvas , fetch  } = param;
    return {
        window: null,
        ignoreAnimation: true,
        ignoreMouse: true,
        DOMParser,
        fetch,
        createCanvas: canvas.createCanvas,
        createImage: canvas.loadImage
    };
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  offscreen: offscreen,
  node: node
});

/**
 * HTML-safe compress white-spaces.
 * @param str - String to compress.
 * @returns String.
 */ function compressSpaces(str) {
    return str.replace(/(?!\u3000)\s+/gm, ' ');
}
/**
 * HTML-safe left trim.
 * @param str - String to trim.
 * @returns String.
 */ function trimLeft(str) {
    return str.replace(/^[\n \t]+/, '');
}
/**
 * HTML-safe right trim.
 * @param str - String to trim.
 * @returns String.
 */ function trimRight(str) {
    return str.replace(/[\n \t]+$/, '');
}
/**
 * String to numbers array.
 * @param str - Numbers string.
 * @returns Numbers array.
 */ function toNumbers(str) {
    const matches = str.match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm);
    return matches ? matches.map(parseFloat) : [];
}
/**
 * String to matrix value.
 * @param str - Numbers string.
 * @returns Matrix value.
 */ function toMatrixValue(str) {
    const numbers = toNumbers(str);
    const matrix = [
        numbers[0] || 0,
        numbers[1] || 0,
        numbers[2] || 0,
        numbers[3] || 0,
        numbers[4] || 0,
        numbers[5] || 0
    ];
    return matrix;
}
// Microsoft Edge fix
const allUppercase = /^[A-Z-]+$/;
/**
 * Normalize attribute name.
 * @param name - Attribute name.
 * @returns Normalized attribute name.
 */ function normalizeAttributeName(name) {
    if (allUppercase.test(name)) {
        return name.toLowerCase();
    }
    return name;
}
/**
 * Parse external URL.
 * @param url - CSS url string.
 * @returns Parsed URL.
 */ function parseExternalUrl(url) {
    //                      single quotes [2]
    //                      v         double quotes [3]
    //                      v         v         no quotes [4]
    //                      v         v         v
    const urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url);
    if (!urlMatch) {
        return '';
    }
    return urlMatch[2] || urlMatch[3] || urlMatch[4] || '';
}
/**
 * Transform floats to integers in rgb colors.
 * @param color - Color to normalize.
 * @returns Normalized color.
 */ function normalizeColor(color) {
    if (!color.startsWith('rgb')) {
        return color;
    }
    let rgbParts = 3;
    const normalizedColor = color.replace(/\d+(\.\d+)?/g, (num, isFloat)=>(rgbParts--) && isFloat ? String(Math.round(parseFloat(num))) : num
    );
    return normalizedColor;
}

// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
const attributeRegex = /(\[[^\]]+\])/g;
const idRegex = /(#[^\s+>~.[:]+)/g;
const classRegex = /(\.[^\s+>~.[:]+)/g;
const pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
const pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
const pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
const elementRegex = /([^\s+>~.[:]+)/g;
function findSelectorMatch(selector, regex) {
    const matches = regex.exec(selector);
    if (!matches) {
        return [
            selector,
            0
        ];
    }
    return [
        selector.replace(regex, ' '),
        matches.length
    ];
}
/**
 * Measure selector specificity.
 * @param selector - Selector to measure.
 * @returns Specificity.
 */ function getSelectorSpecificity(selector) {
    const specificity = [
        0,
        0,
        0
    ];
    let currentSelector = selector.replace(/:not\(([^)]*)\)/g, '     $1 ').replace(/{[\s\S]*/gm, ' ');
    let delta = 0;
    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
    specificity[0] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
    specificity[2] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
    specificity[1] += delta;
    currentSelector = currentSelector.replace(/[*\s+>~]/g, ' ').replace(/[#.]/g, ' ');
    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex) // lgtm [js/useless-assignment-to-local]
    ;
    specificity[2] += delta;
    return specificity.join('');
}

const PSEUDO_ZERO = 0.00000001;
/**
 * Vector magnitude.
 * @param v
 * @returns Number result.
 */ function vectorMagnitude(v) {
    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
}
/**
 * Ratio between two vectors.
 * @param u
 * @param v
 * @returns Number result.
 */ function vectorsRatio(u, v) {
    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));
}
/**
 * Angle between two vectors.
 * @param u
 * @param v
 * @returns Number result.
 */ function vectorsAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));
}
function CB1(t) {
    return t * t * t;
}
function CB2(t) {
    return 3 * t * t * (1 - t);
}
function CB3(t) {
    return 3 * t * (1 - t) * (1 - t);
}
function CB4(t) {
    return (1 - t) * (1 - t) * (1 - t);
}
function QB1(t) {
    return t * t;
}
function QB2(t) {
    return 2 * t * (1 - t);
}
function QB3(t) {
    return (1 - t) * (1 - t);
}

class Property {
    static empty(document) {
        return new Property(document, 'EMPTY', '');
    }
    split() {
        let separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ' ';
        const { document , name  } = this;
        return compressSpaces(this.getString()).trim().split(separator).map((value)=>new Property(document, name, value)
        );
    }
    hasValue(zeroIsValue) {
        const value = this.value;
        return value !== null && value !== '' && (zeroIsValue || value !== 0) && typeof value !== 'undefined';
    }
    isString(regexp) {
        const { value  } = this;
        const result = typeof value === 'string';
        if (!result || !regexp) {
            return result;
        }
        return regexp.test(value);
    }
    isUrlDefinition() {
        return this.isString(/^url\(/);
    }
    isPixels() {
        if (!this.hasValue()) {
            return false;
        }
        const asString = this.getString();
        switch(true){
            case asString.endsWith('px'):
            case /^[0-9]+$/.test(asString):
                return true;
            default:
                return false;
        }
    }
    setValue(value) {
        this.value = value;
        return this;
    }
    getValue(def) {
        if (typeof def === 'undefined' || this.hasValue()) {
            return this.value;
        }
        return def;
    }
    getNumber(def) {
        if (!this.hasValue()) {
            if (typeof def === 'undefined') {
                return 0;
            }
            // @ts-expect-error Parse unknown value.
            return parseFloat(def);
        }
        const { value  } = this;
        // @ts-expect-error Parse unknown value.
        let n = parseFloat(value);
        if (this.isString(/%$/)) {
            n /= 100;
        }
        return n;
    }
    getString(def) {
        if (typeof def === 'undefined' || this.hasValue()) {
            return typeof this.value === 'undefined' ? '' : String(this.value);
        }
        return String(def);
    }
    getColor(def) {
        let color = this.getString(def);
        if (this.isNormalizedColor) {
            return color;
        }
        this.isNormalizedColor = true;
        color = normalizeColor(color);
        this.value = color;
        return color;
    }
    getDpi() {
        return 96 // TODO: compute?
        ;
    }
    getRem() {
        return this.document.rootEmSize;
    }
    getEm() {
        return this.document.emSize;
    }
    getUnits() {
        return this.getString().replace(/[0-9.-]/g, '');
    }
    getPixels(axisOrIsFontSize) {
        let processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!this.hasValue()) {
            return 0;
        }
        const [axis, isFontSize] = typeof axisOrIsFontSize === 'boolean' ? [
            undefined,
            axisOrIsFontSize
        ] : [
            axisOrIsFontSize
        ];
        const { viewPort  } = this.document.screen;
        switch(true){
            case this.isString(/vmin$/):
                return this.getNumber() / 100 * Math.min(viewPort.computeSize('x'), viewPort.computeSize('y'));
            case this.isString(/vmax$/):
                return this.getNumber() / 100 * Math.max(viewPort.computeSize('x'), viewPort.computeSize('y'));
            case this.isString(/vw$/):
                return this.getNumber() / 100 * viewPort.computeSize('x');
            case this.isString(/vh$/):
                return this.getNumber() / 100 * viewPort.computeSize('y');
            case this.isString(/rem$/):
                return this.getNumber() * this.getRem();
            case this.isString(/em$/):
                return this.getNumber() * this.getEm();
            case this.isString(/ex$/):
                return this.getNumber() * this.getEm() / 2;
            case this.isString(/px$/):
                return this.getNumber();
            case this.isString(/pt$/):
                return this.getNumber() * this.getDpi() * (1 / 72);
            case this.isString(/pc$/):
                return this.getNumber() * 15;
            case this.isString(/cm$/):
                return this.getNumber() * this.getDpi() / 2.54;
            case this.isString(/mm$/):
                return this.getNumber() * this.getDpi() / 25.4;
            case this.isString(/in$/):
                return this.getNumber() * this.getDpi();
            case this.isString(/%$/) && isFontSize:
                return this.getNumber() * this.getEm();
            case this.isString(/%$/):
                return this.getNumber() * viewPort.computeSize(axis);
            default:
                {
                    const n = this.getNumber();
                    if (processPercent && n < 1) {
                        return n * viewPort.computeSize(axis);
                    }
                    return n;
                }
        }
    }
    getMilliseconds() {
        if (!this.hasValue()) {
            return 0;
        }
        if (this.isString(/ms$/)) {
            return this.getNumber();
        }
        return this.getNumber() * 1000;
    }
    getRadians() {
        if (!this.hasValue()) {
            return 0;
        }
        switch(true){
            case this.isString(/deg$/):
                return this.getNumber() * (Math.PI / 180);
            case this.isString(/grad$/):
                return this.getNumber() * (Math.PI / 200);
            case this.isString(/rad$/):
                return this.getNumber();
            default:
                return this.getNumber() * (Math.PI / 180);
        }
    }
    getDefinition() {
        const asString = this.getString();
        const match = /#([^)'"]+)/.exec(asString);
        const name = (match === null || match === void 0 ? void 0 : match[1]) || asString;
        return this.document.definitions[name];
    }
    getFillStyleDefinition(element, opacity) {
        let def = this.getDefinition();
        if (!def) {
            return null;
        }
        // gradient
        if (typeof def.createGradient === 'function' && 'getBoundingBox' in element) {
            return def.createGradient(this.document.ctx, element, opacity);
        }
        // pattern
        if (typeof def.createPattern === 'function') {
            if (def.getHrefAttribute().hasValue()) {
                const patternTransform = def.getAttribute('patternTransform');
                def = def.getHrefAttribute().getDefinition();
                if (def && patternTransform.hasValue()) {
                    def.getAttribute('patternTransform', true).setValue(patternTransform.value);
                }
            }
            if (def) {
                return def.createPattern(this.document.ctx, element, opacity);
            }
        }
        return null;
    }
    getTextBaseline() {
        if (!this.hasValue()) {
            return null;
        }
        const key = this.getString();
        return Property.textBaselineMapping[key] || null;
    }
    addOpacity(opacity) {
        let value = this.getColor();
        const len = value.length;
        let commas = 0;
        // Simulate old RGBColor version, which can't parse rgba.
        for(let i = 0; i < len; i++){
            if (value[i] === ',') {
                commas++;
            }
            if (commas === 3) {
                break;
            }
        }
        if (opacity.hasValue() && this.isString() && commas !== 3) {
            const color = new rgbcolor__WEBPACK_IMPORTED_MODULE_1__(value);
            if (color.ok) {
                color.alpha = opacity.getNumber();
                value = color.toRGBA();
            }
        }
        return new Property(this.document, this.name, value);
    }
    constructor(document, name, value){
        this.document = document;
        this.name = name;
        this.value = value;
        this.isNormalizedColor = false;
    }
}
Property.textBaselineMapping = {
    'baseline': 'alphabetic',
    'before-edge': 'top',
    'text-before-edge': 'top',
    'middle': 'middle',
    'central': 'middle',
    'after-edge': 'bottom',
    'text-after-edge': 'bottom',
    'ideographic': 'ideographic',
    'alphabetic': 'alphabetic',
    'hanging': 'hanging',
    'mathematical': 'alphabetic'
};

class ViewPort {
    clear() {
        this.viewPorts = [];
    }
    setCurrent(width, height) {
        this.viewPorts.push({
            width,
            height
        });
    }
    removeCurrent() {
        this.viewPorts.pop();
    }
    getRoot() {
        const [root] = this.viewPorts;
        if (!root) {
            return getDefault();
        }
        return root;
    }
    getCurrent() {
        const { viewPorts  } = this;
        const current = viewPorts[viewPorts.length - 1];
        if (!current) {
            return getDefault();
        }
        return current;
    }
    get width() {
        return this.getCurrent().width;
    }
    get height() {
        return this.getCurrent().height;
    }
    computeSize(d) {
        if (typeof d === 'number') {
            return d;
        }
        if (d === 'x') {
            return this.width;
        }
        if (d === 'y') {
            return this.height;
        }
        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
    }
    constructor(){
        this.viewPorts = [];
    }
}
ViewPort.DEFAULT_VIEWPORT_WIDTH = 800;
ViewPort.DEFAULT_VIEWPORT_HEIGHT = 600;
function getDefault() {
    return {
        width: ViewPort.DEFAULT_VIEWPORT_WIDTH,
        height: ViewPort.DEFAULT_VIEWPORT_HEIGHT
    };
}

class Point {
    static parse(point) {
        let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        const [x = defaultValue, y = defaultValue] = toNumbers(point);
        return new Point(x, y);
    }
    static parseScale(scale) {
        let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        const [x = defaultValue, y = x] = toNumbers(scale);
        return new Point(x, y);
    }
    static parsePath(path) {
        const points = toNumbers(path);
        const len = points.length;
        const pathPoints = [];
        for(let i = 0; i < len; i += 2){
            pathPoints.push(new Point(points[i], points[i + 1]));
        }
        return pathPoints;
    }
    angleTo(point) {
        return Math.atan2(point.y - this.y, point.x - this.x);
    }
    applyTransform(transform) {
        const { x , y  } = this;
        const xp = x * transform[0] + y * transform[2] + transform[4];
        const yp = x * transform[1] + y * transform[3] + transform[5];
        this.x = xp;
        this.y = yp;
    }
    constructor(x, y){
        this.x = x;
        this.y = y;
    }
}

class Mouse {
    isWorking() {
        return this.working;
    }
    start() {
        if (this.working) {
            return;
        }
        const { screen , onClick , onMouseMove  } = this;
        const canvas = screen.ctx.canvas;
        canvas.onclick = onClick;
        canvas.onmousemove = onMouseMove;
        this.working = true;
    }
    stop() {
        if (!this.working) {
            return;
        }
        const canvas = this.screen.ctx.canvas;
        this.working = false;
        canvas.onclick = null;
        canvas.onmousemove = null;
    }
    hasEvents() {
        return this.working && this.events.length > 0;
    }
    runEvents() {
        if (!this.working) {
            return;
        }
        const { screen: document , events , eventElements  } = this;
        const { style  } = document.ctx.canvas;
        let element;
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (style) {
            style.cursor = '';
        }
        events.forEach((param, i)=>{
            let { run  } = param;
            element = eventElements[i];
            while(element){
                run(element);
                element = element.parent;
            }
        });
        // done running, clear
        this.events = [];
        this.eventElements = [];
    }
    checkPath(element, ctx) {
        if (!this.working || !ctx) {
            return;
        }
        const { events , eventElements  } = this;
        events.forEach((param, i)=>{
            let { x , y  } = param;
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {
                eventElements[i] = element;
            }
        });
    }
    checkBoundingBox(element, boundingBox) {
        if (!this.working || !boundingBox) {
            return;
        }
        const { events , eventElements  } = this;
        events.forEach((param, i)=>{
            let { x , y  } = param;
            if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {
                eventElements[i] = element;
            }
        });
    }
    mapXY(x, y) {
        const { window , ctx  } = this.screen;
        const point = new Point(x, y);
        let element = ctx.canvas;
        while(element){
            point.x -= element.offsetLeft;
            point.y -= element.offsetTop;
            element = element.offsetParent;
        }
        if (window === null || window === void 0 ? void 0 : window.scrollX) {
            point.x += window.scrollX;
        }
        if (window === null || window === void 0 ? void 0 : window.scrollY) {
            point.y += window.scrollY;
        }
        return point;
    }
    onClick(event) {
        const { x , y  } = this.mapXY(event.clientX, event.clientY);
        this.events.push({
            type: 'onclick',
            x,
            y,
            run (eventTarget) {
                if (eventTarget.onClick) {
                    eventTarget.onClick();
                }
            }
        });
    }
    onMouseMove(event) {
        const { x , y  } = this.mapXY(event.clientX, event.clientY);
        this.events.push({
            type: 'onmousemove',
            x,
            y,
            run (eventTarget) {
                if (eventTarget.onMouseMove) {
                    eventTarget.onMouseMove();
                }
            }
        });
    }
    constructor(screen){
        this.screen = screen;
        this.working = false;
        this.events = [];
        this.eventElements = [];
        this.onClick = this.onClick.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
    }
}

const defaultWindow = typeof window !== 'undefined' ? window : null;
const defaultFetch$1 = typeof fetch !== 'undefined' ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.
 : undefined;
class Screen {
    wait(checker) {
        this.waits.push(checker);
    }
    ready() {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        if (!this.readyPromise) {
            return Promise.resolve();
        }
        return this.readyPromise;
    }
    isReady() {
        if (this.isReadyLock) {
            return true;
        }
        const isReadyLock = this.waits.every((_)=>_()
        );
        if (isReadyLock) {
            this.waits = [];
            if (this.resolveReady) {
                this.resolveReady();
            }
        }
        this.isReadyLock = isReadyLock;
        return isReadyLock;
    }
    setDefaults(ctx) {
        // initial values and defaults
        ctx.strokeStyle = 'rgba(0,0,0,0)';
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
        ctx.miterLimit = 4;
    }
    setViewBox(param) {
        let { document , ctx , aspectRatio , width , desiredWidth , height , desiredHeight , minX =0 , minY =0 , refX , refY , clip =false , clipX =0 , clipY =0  } = param;
        // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
        const cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, '') // ignore defer
        ;
        const [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(' ');
        const align = aspectRatioAlign || 'xMidYMid';
        const meetOrSlice = aspectRatioMeetOrSlice || 'meet';
        // calculate scale
        const scaleX = width / desiredWidth;
        const scaleY = height / desiredHeight;
        const scaleMin = Math.min(scaleX, scaleY);
        const scaleMax = Math.max(scaleX, scaleY);
        let finalDesiredWidth = desiredWidth;
        let finalDesiredHeight = desiredHeight;
        if (meetOrSlice === 'meet') {
            finalDesiredWidth *= scaleMin;
            finalDesiredHeight *= scaleMin;
        }
        if (meetOrSlice === 'slice') {
            finalDesiredWidth *= scaleMax;
            finalDesiredHeight *= scaleMax;
        }
        const refXProp = new Property(document, 'refX', refX);
        const refYProp = new Property(document, 'refY', refY);
        const hasRefs = refXProp.hasValue() && refYProp.hasValue();
        if (hasRefs) {
            ctx.translate(-scaleMin * refXProp.getPixels('x'), -scaleMin * refYProp.getPixels('y'));
        }
        if (clip) {
            const scaledClipX = scaleMin * clipX;
            const scaledClipY = scaleMin * clipY;
            ctx.beginPath();
            ctx.moveTo(scaledClipX, scaledClipY);
            ctx.lineTo(width, scaledClipY);
            ctx.lineTo(width, height);
            ctx.lineTo(scaledClipX, height);
            ctx.closePath();
            ctx.clip();
        }
        if (!hasRefs) {
            const isMeetMinY = meetOrSlice === 'meet' && scaleMin === scaleY;
            const isSliceMaxY = meetOrSlice === 'slice' && scaleMax === scaleY;
            const isMeetMinX = meetOrSlice === 'meet' && scaleMin === scaleX;
            const isSliceMaxX = meetOrSlice === 'slice' && scaleMax === scaleX;
            if (align.startsWith('xMid') && (isMeetMinY || isSliceMaxY)) {
                ctx.translate(width / 2 - finalDesiredWidth / 2, 0);
            }
            if (align.endsWith('YMid') && (isMeetMinX || isSliceMaxX)) {
                ctx.translate(0, height / 2 - finalDesiredHeight / 2);
            }
            if (align.startsWith('xMax') && (isMeetMinY || isSliceMaxY)) {
                ctx.translate(width - finalDesiredWidth, 0);
            }
            if (align.endsWith('YMax') && (isMeetMinX || isSliceMaxX)) {
                ctx.translate(0, height - finalDesiredHeight);
            }
        }
        // scale
        switch(true){
            case align === 'none':
                ctx.scale(scaleX, scaleY);
                break;
            case meetOrSlice === 'meet':
                ctx.scale(scaleMin, scaleMin);
                break;
            case meetOrSlice === 'slice':
                ctx.scale(scaleMax, scaleMax);
                break;
        }
        // translate
        ctx.translate(-minX, -minY);
    }
    start(element) {
        let { enableRedraw =false , ignoreMouse =false , ignoreAnimation =false , ignoreDimensions =false , ignoreClear =false , forceRedraw , scaleWidth , scaleHeight , offsetX , offsetY  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const { mouse  } = this;
        const frameDuration = 1000 / Screen.FRAMERATE;
        this.frameDuration = frameDuration;
        this.readyPromise = new Promise((resolve)=>{
            this.resolveReady = resolve;
        });
        if (this.isReady()) {
            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
        }
        if (!enableRedraw) {
            return;
        }
        let now = Date.now();
        let then = now;
        let delta = 0;
        const tick = ()=>{
            now = Date.now();
            delta = now - then;
            if (delta >= frameDuration) {
                then = now - delta % frameDuration;
                if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
                    this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
                    mouse.runEvents();
                }
            }
            this.intervalId = raf__WEBPACK_IMPORTED_MODULE_0__(tick);
        };
        if (!ignoreMouse) {
            mouse.start();
        }
        this.intervalId = raf__WEBPACK_IMPORTED_MODULE_0__(tick);
    }
    stop() {
        if (this.intervalId) {
            raf__WEBPACK_IMPORTED_MODULE_0__.cancel(this.intervalId);
            this.intervalId = null;
        }
        this.mouse.stop();
    }
    shouldUpdate(ignoreAnimation, forceRedraw) {
        // need update from animations?
        if (!ignoreAnimation) {
            const { frameDuration  } = this;
            const shouldUpdate1 = this.animations.reduce((shouldUpdate, animation)=>animation.update(frameDuration) || shouldUpdate
            , false);
            if (shouldUpdate1) {
                return true;
            }
        }
        // need update from redraw?
        if (typeof forceRedraw === 'function' && forceRedraw()) {
            return true;
        }
        if (!this.isReadyLock && this.isReady()) {
            return true;
        }
        // need update from mouse events?
        if (this.mouse.hasEvents()) {
            return true;
        }
        return false;
    }
    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
        const { viewPort , ctx , isFirstRender  } = this;
        const canvas = ctx.canvas;
        viewPort.clear();
        if (canvas.width && canvas.height) {
            viewPort.setCurrent(canvas.width, canvas.height);
        }
        const widthStyle = element.getStyle('width');
        const heightStyle = element.getStyle('height');
        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== 'number' && typeof scaleHeight !== 'number')) {
            // set canvas size
            if (widthStyle.hasValue()) {
                canvas.width = widthStyle.getPixels('x');
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (canvas.style) {
                    canvas.style.width = "".concat(canvas.width, "px");
                }
            }
            if (heightStyle.hasValue()) {
                canvas.height = heightStyle.getPixels('y');
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (canvas.style) {
                    canvas.style.height = "".concat(canvas.height, "px");
                }
            }
        }
        let cWidth = canvas.clientWidth || canvas.width;
        let cHeight = canvas.clientHeight || canvas.height;
        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
            cWidth = widthStyle.getPixels('x');
            cHeight = heightStyle.getPixels('y');
        }
        viewPort.setCurrent(cWidth, cHeight);
        if (typeof offsetX === 'number') {
            element.getAttribute('x', true).setValue(offsetX);
        }
        if (typeof offsetY === 'number') {
            element.getAttribute('y', true).setValue(offsetY);
        }
        if (typeof scaleWidth === 'number' || typeof scaleHeight === 'number') {
            const viewBox = toNumbers(element.getAttribute('viewBox').getString());
            let xRatio = 0;
            let yRatio = 0;
            if (typeof scaleWidth === 'number') {
                const widthStyle = element.getStyle('width');
                if (widthStyle.hasValue()) {
                    xRatio = widthStyle.getPixels('x') / scaleWidth;
                } else if (viewBox[2] && !isNaN(viewBox[2])) {
                    xRatio = viewBox[2] / scaleWidth;
                }
            }
            if (typeof scaleHeight === 'number') {
                const heightStyle = element.getStyle('height');
                if (heightStyle.hasValue()) {
                    yRatio = heightStyle.getPixels('y') / scaleHeight;
                } else if (viewBox[3] && !isNaN(viewBox[3])) {
                    yRatio = viewBox[3] / scaleHeight;
                }
            }
            if (!xRatio) {
                xRatio = yRatio;
            }
            if (!yRatio) {
                yRatio = xRatio;
            }
            element.getAttribute('width', true).setValue(scaleWidth);
            element.getAttribute('height', true).setValue(scaleHeight);
            const transformStyle = element.getStyle('transform', true, true);
            transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
        }
        // clear and render
        if (!ignoreClear) {
            ctx.clearRect(0, 0, cWidth, cHeight);
        }
        element.render(ctx);
        if (isFirstRender) {
            this.isFirstRender = false;
        }
    }
    constructor(ctx, { fetch =defaultFetch$1 , window =defaultWindow  } = {}){
        this.ctx = ctx;
        this.viewPort = new ViewPort();
        this.mouse = new Mouse(this);
        this.animations = [];
        this.waits = [];
        this.frameDuration = 0;
        this.isReadyLock = false;
        this.isFirstRender = true;
        this.intervalId = null;
        this.window = window;
        if (!fetch) {
            throw new Error("Can't find 'fetch' in 'globalThis', please provide it via options");
        }
        this.fetch = fetch;
    }
}
Screen.defaultWindow = defaultWindow;
Screen.defaultFetch = defaultFetch$1;
Screen.FRAMERATE = 30;
Screen.MAX_VIRTUAL_PIXELS = 30000;

const { defaultFetch  } = Screen;
const DefaultDOMParser = typeof DOMParser !== 'undefined' ? DOMParser : undefined;
class Parser {
    async parse(resource) {
        if (resource.startsWith('<')) {
            return this.parseFromString(resource);
        }
        return this.load(resource);
    }
    parseFromString(xml) {
        const parser = new this.DOMParser();
        try {
            return this.checkDocument(parser.parseFromString(xml, 'image/svg+xml'));
        } catch (err) {
            return this.checkDocument(parser.parseFromString(xml, 'text/xml'));
        }
    }
    checkDocument(document) {
        const parserError = document.getElementsByTagName('parsererror')[0];
        if (parserError) {
            throw new Error(parserError.textContent || 'Unknown parse error');
        }
        return document;
    }
    async load(url) {
        const response = await this.fetch(url);
        const xml = await response.text();
        return this.parseFromString(xml);
    }
    constructor({ fetch =defaultFetch , DOMParser =DefaultDOMParser  } = {}){
        if (!fetch) {
            throw new Error("Can't find 'fetch' in 'globalThis', please provide it via options");
        }
        if (!DOMParser) {
            throw new Error("Can't find 'DOMParser' in 'globalThis', please provide it via options");
        }
        this.fetch = fetch;
        this.DOMParser = DOMParser;
    }
}

class Translate {
    apply(ctx) {
        const { x , y  } = this.point;
        ctx.translate(x || 0, y || 0);
    }
    unapply(ctx) {
        const { x , y  } = this.point;
        ctx.translate(-1 * x || 0, -1 * y || 0);
    }
    applyToPoint(point) {
        const { x , y  } = this.point;
        point.applyTransform([
            1,
            0,
            0,
            1,
            x || 0,
            y || 0
        ]);
    }
    constructor(_, point){
        this.type = 'translate';
        this.point = Point.parse(point);
    }
}

class Rotate {
    apply(ctx) {
        const { cx , cy , originX , originY , angle  } = this;
        const tx = cx + originX.getPixels('x');
        const ty = cy + originY.getPixels('y');
        ctx.translate(tx, ty);
        ctx.rotate(angle.getRadians());
        ctx.translate(-tx, -ty);
    }
    unapply(ctx) {
        const { cx , cy , originX , originY , angle  } = this;
        const tx = cx + originX.getPixels('x');
        const ty = cy + originY.getPixels('y');
        ctx.translate(tx, ty);
        ctx.rotate(-1 * angle.getRadians());
        ctx.translate(-tx, -ty);
    }
    applyToPoint(point) {
        const { cx , cy , angle  } = this;
        const rad = angle.getRadians();
        point.applyTransform([
            1,
            0,
            0,
            1,
            cx || 0,
            cy || 0 // this.p.y
        ]);
        point.applyTransform([
            Math.cos(rad),
            Math.sin(rad),
            -Math.sin(rad),
            Math.cos(rad),
            0,
            0
        ]);
        point.applyTransform([
            1,
            0,
            0,
            1,
            -cx || 0,
            -cy || 0 // -this.p.y
        ]);
    }
    constructor(document, rotate, transformOrigin){
        this.type = 'rotate';
        const numbers = toNumbers(rotate);
        this.angle = new Property(document, 'angle', numbers[0]);
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
        this.cx = numbers[1] || 0;
        this.cy = numbers[2] || 0;
    }
}

class Scale {
    apply(ctx) {
        const { scale: { x , y  } , originX , originY  } = this;
        const tx = originX.getPixels('x');
        const ty = originY.getPixels('y');
        ctx.translate(tx, ty);
        ctx.scale(x, y || x);
        ctx.translate(-tx, -ty);
    }
    unapply(ctx) {
        const { scale: { x , y  } , originX , originY  } = this;
        const tx = originX.getPixels('x');
        const ty = originY.getPixels('y');
        ctx.translate(tx, ty);
        ctx.scale(1 / x, 1 / y || x);
        ctx.translate(-tx, -ty);
    }
    applyToPoint(point) {
        const { x , y  } = this.scale;
        point.applyTransform([
            x || 0,
            0,
            0,
            y || 0,
            0,
            0
        ]);
    }
    constructor(_, scale, transformOrigin){
        this.type = 'scale';
        const scaleSize = Point.parseScale(scale);
        // Workaround for node-canvas
        if (scaleSize.x === 0 || scaleSize.y === 0) {
            scaleSize.x = PSEUDO_ZERO;
            scaleSize.y = PSEUDO_ZERO;
        }
        this.scale = scaleSize;
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
    }
}

class Matrix {
    apply(ctx) {
        const { originX , originY , matrix  } = this;
        const tx = originX.getPixels('x');
        const ty = originY.getPixels('y');
        ctx.translate(tx, ty);
        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
        ctx.translate(-tx, -ty);
    }
    unapply(ctx) {
        const { originX , originY , matrix  } = this;
        const a = matrix[0];
        const b = matrix[2];
        const c = matrix[4];
        const d = matrix[1];
        const e = matrix[3];
        const f = matrix[5];
        const g = 0;
        const h = 0;
        const i = 1;
        const det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));
        const tx = originX.getPixels('x');
        const ty = originY.getPixels('y');
        ctx.translate(tx, ty);
        ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));
        ctx.translate(-tx, -ty);
    }
    applyToPoint(point) {
        point.applyTransform(this.matrix);
    }
    constructor(_, matrix, transformOrigin){
        this.type = 'matrix';
        this.matrix = toMatrixValue(matrix);
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
    }
}

class Skew extends Matrix {
    constructor(document, skew, transformOrigin){
        super(document, skew, transformOrigin);
        this.type = 'skew';
        this.angle = new Property(document, 'angle', skew);
    }
}

class SkewX extends Skew {
    constructor(document, skew, transformOrigin){
        super(document, skew, transformOrigin);
        this.type = 'skewX';
        this.matrix = [
            1,
            0,
            Math.tan(this.angle.getRadians()),
            1,
            0,
            0
        ];
    }
}

class SkewY extends Skew {
    constructor(document, skew, transformOrigin){
        super(document, skew, transformOrigin);
        this.type = 'skewY';
        this.matrix = [
            1,
            Math.tan(this.angle.getRadians()),
            0,
            1,
            0,
            0
        ];
    }
}

function parseTransforms(transform) {
    return compressSpaces(transform).trim().replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g, ') ').split(/\s(?=[a-z])/);
}
function parseTransform(transform) {
    const [type = '', value = ''] = transform.split('(');
    return [
        type.trim(),
        value.trim().replace(')', '')
    ];
}
class Transform {
    static fromElement(document, element) {
        const transformStyle = element.getStyle('transform', false, true);
        if (transformStyle.hasValue()) {
            const [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle('transform-origin', false, true).split();
            if (transformOriginXProperty && transformOriginYProperty) {
                const transformOrigin = [
                    transformOriginXProperty,
                    transformOriginYProperty
                ];
                return new Transform(document, transformStyle.getString(), transformOrigin);
            }
        }
        return null;
    }
    apply(ctx) {
        this.transforms.forEach((transform)=>transform.apply(ctx)
        );
    }
    unapply(ctx) {
        this.transforms.forEach((transform)=>transform.unapply(ctx)
        );
    }
    // TODO: applyToPoint unused ... remove?
    applyToPoint(point) {
        this.transforms.forEach((transform)=>transform.applyToPoint(point)
        );
    }
    constructor(document, transform1, transformOrigin){
        this.document = document;
        this.transforms = [];
        const data = parseTransforms(transform1);
        data.forEach((transform)=>{
            if (transform === 'none') {
                return;
            }
            const [type, value] = parseTransform(transform);
            const TransformType = Transform.transformTypes[type];
            if (TransformType) {
                this.transforms.push(new TransformType(this.document, value, transformOrigin));
            }
        });
    }
}
Transform.transformTypes = {
    translate: Translate,
    rotate: Rotate,
    scale: Scale,
    matrix: Matrix,
    skewX: SkewX,
    skewY: SkewY
};

class Element {
    getAttribute(name) {
        let createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const attr = this.attributes[name];
        if (!attr && createIfNotExists) {
            const attr = new Property(this.document, name, '');
            this.attributes[name] = attr;
            return attr;
        }
        return attr || Property.empty(this.document);
    }
    getHrefAttribute() {
        let href;
        for(const key in this.attributes){
            if (key === 'href' || key.endsWith(':href')) {
                href = this.attributes[key];
                break;
            }
        }
        return href || Property.empty(this.document);
    }
    getStyle(name) {
        let createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        const style = this.styles[name];
        if (style) {
            return style;
        }
        const attr = this.getAttribute(name);
        if (attr.hasValue()) {
            this.styles[name] = attr // move up to me to cache
            ;
            return attr;
        }
        if (!skipAncestors) {
            const { parent  } = this;
            if (parent) {
                const parentStyle = parent.getStyle(name);
                if (parentStyle.hasValue()) {
                    return parentStyle;
                }
            }
        }
        if (createIfNotExists) {
            const style = new Property(this.document, name, '');
            this.styles[name] = style;
            return style;
        }
        return Property.empty(this.document);
    }
    render(ctx) {
        // don't render display=none
        // don't render visibility=hidden
        if (this.getStyle('display').getString() === 'none' || this.getStyle('visibility').getString() === 'hidden') {
            return;
        }
        ctx.save();
        if (this.getStyle('mask').hasValue()) {
            const mask = this.getStyle('mask').getDefinition();
            if (mask) {
                this.applyEffects(ctx);
                mask.apply(ctx, this);
            }
        } else if (this.getStyle('filter').getValue('none') !== 'none') {
            const filter = this.getStyle('filter').getDefinition();
            if (filter) {
                this.applyEffects(ctx);
                filter.apply(ctx, this);
            }
        } else {
            this.setContext(ctx);
            this.renderChildren(ctx);
            this.clearContext(ctx);
        }
        ctx.restore();
    }
    setContext(_) {
    // NO RENDER
    }
    applyEffects(ctx) {
        // transform
        const transform = Transform.fromElement(this.document, this);
        if (transform) {
            transform.apply(ctx);
        }
        // clip
        const clipPathStyleProp = this.getStyle('clip-path', false, true);
        if (clipPathStyleProp.hasValue()) {
            const clip = clipPathStyleProp.getDefinition();
            if (clip) {
                clip.apply(ctx);
            }
        }
    }
    clearContext(_) {
    // NO RENDER
    }
    renderChildren(ctx) {
        this.children.forEach((child)=>{
            child.render(ctx);
        });
    }
    addChild(childNode) {
        const child = childNode instanceof Element ? childNode : this.document.createElement(childNode);
        child.parent = this;
        if (!Element.ignoreChildTypes.includes(child.type)) {
            this.children.push(child);
        }
    }
    matchesSelector(selector) {
        var ref;
        const { node  } = this;
        if (typeof node.matches === 'function') {
            return node.matches(selector);
        }
        const styleClasses = (ref = node.getAttribute) === null || ref === void 0 ? void 0 : ref.call(node, 'class');
        if (!styleClasses || styleClasses === '') {
            return false;
        }
        return styleClasses.split(' ').some((styleClass)=>".".concat(styleClass) === selector
        );
    }
    addStylesFromStyleDefinition() {
        const { styles , stylesSpecificity  } = this.document;
        let styleProp;
        for(const selector in styles){
            if (!selector.startsWith('@') && this.matchesSelector(selector)) {
                const style = styles[selector];
                const specificity = stylesSpecificity[selector];
                if (style) {
                    for(const name in style){
                        let existingSpecificity = this.stylesSpecificity[name];
                        if (typeof existingSpecificity === 'undefined') {
                            existingSpecificity = '000';
                        }
                        if (specificity && specificity >= existingSpecificity) {
                            styleProp = style[name];
                            if (styleProp) {
                                this.styles[name] = styleProp;
                            }
                            this.stylesSpecificity[name] = specificity;
                        }
                    }
                }
            }
        }
    }
    removeStyles(element, ignoreStyles) {
        const toRestore1 = ignoreStyles.reduce((toRestore, name)=>{
            const styleProp = element.getStyle(name);
            if (!styleProp.hasValue()) {
                return toRestore;
            }
            const value = styleProp.getString();
            styleProp.setValue('');
            return [
                ...toRestore,
                [
                    name,
                    value
                ]
            ];
        }, []);
        return toRestore1;
    }
    restoreStyles(element, styles) {
        styles.forEach((param)=>{
            let [name, value] = param;
            element.getStyle(name, true).setValue(value);
        });
    }
    isFirstChild() {
        var ref;
        return ((ref = this.parent) === null || ref === void 0 ? void 0 : ref.children.indexOf(this)) === 0;
    }
    constructor(document, node, captureTextNodes = false){
        this.document = document;
        this.node = node;
        this.captureTextNodes = captureTextNodes;
        this.type = '';
        this.attributes = {};
        this.styles = {};
        this.stylesSpecificity = {};
        this.animationFrozen = false;
        this.animationFrozenValue = '';
        this.parent = null;
        this.children = [];
        if (!node || node.nodeType !== 1) {
            return;
        }
        // add attributes
        Array.from(node.attributes).forEach((attribute)=>{
            const nodeName = normalizeAttributeName(attribute.nodeName);
            this.attributes[nodeName] = new Property(document, nodeName, attribute.value);
        });
        this.addStylesFromStyleDefinition();
        // add inline styles
        if (this.getAttribute('style').hasValue()) {
            const styles = this.getAttribute('style').getString().split(';').map((_)=>_.trim()
            );
            styles.forEach((style)=>{
                if (!style) {
                    return;
                }
                const [name, value] = style.split(':').map((_)=>_.trim()
                );
                if (name) {
                    this.styles[name] = new Property(document, name, value);
                }
            });
        }
        const { definitions  } = document;
        const id = this.getAttribute('id');
        // add id
        if (id.hasValue()) {
            if (!definitions[id.getString()]) {
                definitions[id.getString()] = this;
            }
        }
        Array.from(node.childNodes).forEach((childNode)=>{
            if (childNode.nodeType === 1) {
                this.addChild(childNode) // ELEMENT_NODE
                ;
            } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
                const textNode = document.createTextNode(childNode);
                if (textNode.getText().length > 0) {
                    this.addChild(textNode) // TEXT_NODE
                    ;
                }
            }
        });
    }
}
Element.ignoreChildTypes = [
    'title'
];

class UnknownElement extends Element {
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
    }
}

function wrapFontFamily(fontFamily) {
    const trimmed = fontFamily.trim();
    return /^('|")/.test(trimmed) ? trimmed : "\"".concat(trimmed, "\"");
}
function prepareFontFamily(fontFamily) {
    return typeof process === 'undefined' ? fontFamily : fontFamily.trim().split(',').map(wrapFontFamily).join(',');
}
/**
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
 * @param fontStyle
 * @returns CSS font style.
 */ function prepareFontStyle(fontStyle) {
    if (!fontStyle) {
        return '';
    }
    const targetFontStyle = fontStyle.trim().toLowerCase();
    switch(targetFontStyle){
        case 'normal':
        case 'italic':
        case 'oblique':
        case 'inherit':
        case 'initial':
        case 'unset':
            return targetFontStyle;
        default:
            if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
                return targetFontStyle;
            }
            return '';
    }
}
/**
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight
 * @param fontWeight
 * @returns CSS font weight.
 */ function prepareFontWeight(fontWeight) {
    if (!fontWeight) {
        return '';
    }
    const targetFontWeight = fontWeight.trim().toLowerCase();
    switch(targetFontWeight){
        case 'normal':
        case 'bold':
        case 'lighter':
        case 'bolder':
        case 'inherit':
        case 'initial':
        case 'unset':
            return targetFontWeight;
        default:
            if (/^[\d.]+$/.test(targetFontWeight)) {
                return targetFontWeight;
            }
            return '';
    }
}
class Font {
    static parse() {
        let font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '', inherit = arguments.length > 1 ? arguments[1] : void 0;
        let fontStyle = '';
        let fontVariant = '';
        let fontWeight = '';
        let fontSize = '';
        let fontFamily = '';
        const parts = compressSpaces(font).trim().split(' ');
        const set = {
            fontSize: false,
            fontStyle: false,
            fontWeight: false,
            fontVariant: false
        };
        parts.forEach((part)=>{
            switch(true){
                case !set.fontStyle && Font.styles.includes(part):
                    if (part !== 'inherit') {
                        fontStyle = part;
                    }
                    set.fontStyle = true;
                    break;
                case !set.fontVariant && Font.variants.includes(part):
                    if (part !== 'inherit') {
                        fontVariant = part;
                    }
                    set.fontStyle = true;
                    set.fontVariant = true;
                    break;
                case !set.fontWeight && Font.weights.includes(part):
                    if (part !== 'inherit') {
                        fontWeight = part;
                    }
                    set.fontStyle = true;
                    set.fontVariant = true;
                    set.fontWeight = true;
                    break;
                case !set.fontSize:
                    if (part !== 'inherit') {
                        fontSize = part.split('/')[0] || '';
                    }
                    set.fontStyle = true;
                    set.fontVariant = true;
                    set.fontWeight = true;
                    set.fontSize = true;
                    break;
                default:
                    if (part !== 'inherit') {
                        fontFamily += part;
                    }
            }
        });
        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);
    }
    toString() {
        return [
            prepareFontStyle(this.fontStyle),
            this.fontVariant,
            prepareFontWeight(this.fontWeight),
            this.fontSize,
            // Wrap fontFamily only on nodejs and only for canvas.ctx
            prepareFontFamily(this.fontFamily)
        ].join(' ').trim();
    }
    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit){
        const inheritFont = inherit ? typeof inherit === 'string' ? Font.parse(inherit) : inherit : {};
        this.fontFamily = fontFamily || inheritFont.fontFamily;
        this.fontSize = fontSize || inheritFont.fontSize;
        this.fontStyle = fontStyle || inheritFont.fontStyle;
        this.fontWeight = fontWeight || inheritFont.fontWeight;
        this.fontVariant = fontVariant || inheritFont.fontVariant;
    }
}
Font.styles = 'normal|italic|oblique|inherit';
Font.variants = 'normal|small-caps|inherit';
Font.weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

class BoundingBox {
    get x() {
        return this.x1;
    }
    get y() {
        return this.y1;
    }
    get width() {
        return this.x2 - this.x1;
    }
    get height() {
        return this.y2 - this.y1;
    }
    addPoint(x, y) {
        if (typeof x !== 'undefined') {
            if (isNaN(this.x1) || isNaN(this.x2)) {
                this.x1 = x;
                this.x2 = x;
            }
            if (x < this.x1) {
                this.x1 = x;
            }
            if (x > this.x2) {
                this.x2 = x;
            }
        }
        if (typeof y !== 'undefined') {
            if (isNaN(this.y1) || isNaN(this.y2)) {
                this.y1 = y;
                this.y2 = y;
            }
            if (y < this.y1) {
                this.y1 = y;
            }
            if (y > this.y2) {
                this.y2 = y;
            }
        }
    }
    addX(x) {
        this.addPoint(x, 0);
    }
    addY(y) {
        this.addPoint(0, y);
    }
    addBoundingBox(boundingBox) {
        if (!boundingBox) {
            return;
        }
        const { x1 , y1 , x2 , y2  } = boundingBox;
        this.addPoint(x1, y1);
        this.addPoint(x2, y2);
    }
    sumCubic(t, p0, p1, p2, p3) {
        return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;
    }
    bezierCurveAdd(forX, p0, p1, p2, p3) {
        const b = 6 * p0 - 12 * p1 + 6 * p2;
        const a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
        const c = 3 * p1 - 3 * p0;
        if (a === 0) {
            if (b === 0) {
                return;
            }
            const t = -c / b;
            if (0 < t && t < 1) {
                if (forX) {
                    this.addX(this.sumCubic(t, p0, p1, p2, p3));
                } else {
                    this.addY(this.sumCubic(t, p0, p1, p2, p3));
                }
            }
            return;
        }
        const b2ac = Math.pow(b, 2) - 4 * c * a;
        if (b2ac < 0) {
            return;
        }
        const t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
        if (0 < t1 && t1 < 1) {
            if (forX) {
                this.addX(this.sumCubic(t1, p0, p1, p2, p3));
            } else {
                this.addY(this.sumCubic(t1, p0, p1, p2, p3));
            }
        }
        const t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
        if (0 < t2 && t2 < 1) {
            if (forX) {
                this.addX(this.sumCubic(t2, p0, p1, p2, p3));
            } else {
                this.addY(this.sumCubic(t2, p0, p1, p2, p3));
            }
        }
    }
    // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
        this.addPoint(p0x, p0y);
        this.addPoint(p3x, p3y);
        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
    }
    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
        const cp1x = p0x + 2 / 3 * (p1x - p0x) // CP1 = QP0 + 2/3 *(QP1-QP0)
        ;
        const cp1y = p0y + 2 / 3 * (p1y - p0y) // CP1 = QP0 + 2/3 *(QP1-QP0)
        ;
        const cp2x = cp1x + 1 / 3 * (p2x - p0x) // CP2 = CP1 + 1/3 *(QP2-QP0)
        ;
        const cp2y = cp1y + 1 / 3 * (p2y - p0y) // CP2 = CP1 + 1/3 *(QP2-QP0)
        ;
        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
    }
    isPointInBox(x, y) {
        const { x1 , y1 , x2 , y2  } = this;
        return x1 <= x && x <= x2 && y1 <= y && y <= y2;
    }
    constructor(x1 = Number.NaN, y1 = Number.NaN, x2 = Number.NaN, y2 = Number.NaN){
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.addPoint(x1, y1);
        this.addPoint(x2, y2);
    }
}

class RenderedElement extends Element {
    calculateOpacity() {
        let opacity = 1;
        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this
        let element = this;
        while(element){
            const opacityStyle = element.getStyle('opacity', false, true) // no ancestors on style call
            ;
            if (opacityStyle.hasValue(true)) {
                opacity *= opacityStyle.getNumber();
            }
            element = element.parent;
        }
        return opacity;
    }
    setContext(ctx) {
        let fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!fromMeasure) {
            // fill
            const fillStyleProp = this.getStyle('fill');
            const fillOpacityStyleProp = this.getStyle('fill-opacity');
            const strokeStyleProp = this.getStyle('stroke');
            const strokeOpacityProp = this.getStyle('stroke-opacity');
            if (fillStyleProp.isUrlDefinition()) {
                const fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
                if (fillStyle) {
                    ctx.fillStyle = fillStyle;
                }
            } else if (fillStyleProp.hasValue()) {
                if (fillStyleProp.getString() === 'currentColor') {
                    fillStyleProp.setValue(this.getStyle('color').getColor());
                }
                const fillStyle = fillStyleProp.getColor();
                if (fillStyle !== 'inherit') {
                    ctx.fillStyle = fillStyle === 'none' ? 'rgba(0,0,0,0)' : fillStyle;
                }
            }
            if (fillOpacityStyleProp.hasValue()) {
                const fillStyle = new Property(this.document, 'fill', ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
                ctx.fillStyle = fillStyle;
            }
            // stroke
            if (strokeStyleProp.isUrlDefinition()) {
                const strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
                if (strokeStyle) {
                    ctx.strokeStyle = strokeStyle;
                }
            } else if (strokeStyleProp.hasValue()) {
                if (strokeStyleProp.getString() === 'currentColor') {
                    strokeStyleProp.setValue(this.getStyle('color').getColor());
                }
                const strokeStyle = strokeStyleProp.getString();
                if (strokeStyle !== 'inherit') {
                    ctx.strokeStyle = strokeStyle === 'none' ? 'rgba(0,0,0,0)' : strokeStyle;
                }
            }
            if (strokeOpacityProp.hasValue()) {
                const strokeStyle = new Property(this.document, 'stroke', ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
                ctx.strokeStyle = strokeStyle;
            }
            const strokeWidthStyleProp = this.getStyle('stroke-width');
            if (strokeWidthStyleProp.hasValue()) {
                const newLineWidth = strokeWidthStyleProp.getPixels();
                ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)
                 : newLineWidth;
            }
            const strokeLinecapStyleProp = this.getStyle('stroke-linecap');
            const strokeLinejoinStyleProp = this.getStyle('stroke-linejoin');
            const strokeMiterlimitProp = this.getStyle('stroke-miterlimit');
            // NEED TEST
            // const pointOrderStyleProp = this.getStyle('paint-order');
            const strokeDasharrayStyleProp = this.getStyle('stroke-dasharray');
            const strokeDashoffsetProp = this.getStyle('stroke-dashoffset');
            if (strokeLinecapStyleProp.hasValue()) {
                ctx.lineCap = strokeLinecapStyleProp.getString();
            }
            if (strokeLinejoinStyleProp.hasValue()) {
                ctx.lineJoin = strokeLinejoinStyleProp.getString();
            }
            if (strokeMiterlimitProp.hasValue()) {
                ctx.miterLimit = strokeMiterlimitProp.getNumber();
            }
            // NEED TEST
            // if (pointOrderStyleProp.hasValue()) {
            //   // ?
            //   ctx.paintOrder = pointOrderStyleProp.getValue();
            // }
            if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== 'none') {
                const gaps = toNumbers(strokeDasharrayStyleProp.getString());
                if (typeof ctx.setLineDash !== 'undefined') {
                    ctx.setLineDash(gaps);
                } else // @ts-expect-error Handle browser prefix.
                if (typeof ctx.webkitLineDash !== 'undefined') {
                    // @ts-expect-error Handle browser prefix.
                    ctx.webkitLineDash = gaps;
                } else // @ts-expect-error Handle browser prefix.
                if (typeof ctx.mozDash !== 'undefined' && !(gaps.length === 1 && gaps[0] === 0)) {
                    // @ts-expect-error Handle browser prefix.
                    ctx.mozDash = gaps;
                }
                const offset = strokeDashoffsetProp.getPixels();
                if (typeof ctx.lineDashOffset !== 'undefined') {
                    ctx.lineDashOffset = offset;
                } else // @ts-expect-error Handle browser prefix.
                if (typeof ctx.webkitLineDashOffset !== 'undefined') {
                    // @ts-expect-error Handle browser prefix.
                    ctx.webkitLineDashOffset = offset;
                } else // @ts-expect-error Handle browser prefix.
                if (typeof ctx.mozDashOffset !== 'undefined') {
                    // @ts-expect-error Handle browser prefix.
                    ctx.mozDashOffset = offset;
                }
            }
        }
        // font
        this.modifiedEmSizeStack = false;
        if (typeof ctx.font !== 'undefined') {
            const fontStyleProp = this.getStyle('font');
            const fontStyleStyleProp = this.getStyle('font-style');
            const fontVariantStyleProp = this.getStyle('font-variant');
            const fontWeightStyleProp = this.getStyle('font-weight');
            const fontSizeStyleProp = this.getStyle('font-size');
            const fontFamilyStyleProp = this.getStyle('font-family');
            const font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : '', fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
            fontStyleStyleProp.setValue(font.fontStyle);
            fontVariantStyleProp.setValue(font.fontVariant);
            fontWeightStyleProp.setValue(font.fontWeight);
            fontSizeStyleProp.setValue(font.fontSize);
            fontFamilyStyleProp.setValue(font.fontFamily);
            ctx.font = font.toString();
            if (fontSizeStyleProp.isPixels()) {
                this.document.emSize = fontSizeStyleProp.getPixels();
                this.modifiedEmSizeStack = true;
            }
        }
        if (!fromMeasure) {
            // effects
            this.applyEffects(ctx);
            // opacity
            ctx.globalAlpha = this.calculateOpacity();
        }
    }
    clearContext(ctx) {
        super.clearContext(ctx);
        if (this.modifiedEmSizeStack) {
            this.document.popEmSize();
        }
    }
    constructor(...args){
        super(...args);
        this.modifiedEmSizeStack = false;
    }
}

class TextElement extends RenderedElement {
    setContext(ctx) {
        let fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        super.setContext(ctx, fromMeasure);
        const textBaseline = this.getStyle('dominant-baseline').getTextBaseline() || this.getStyle('alignment-baseline').getTextBaseline();
        if (textBaseline) {
            ctx.textBaseline = textBaseline;
        }
    }
    initializeCoordinates() {
        this.x = 0;
        this.y = 0;
        this.leafTexts = [];
        this.textChunkStart = 0;
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
    }
    getBoundingBox(ctx) {
        if (this.type !== 'text') {
            return this.getTElementBoundingBox(ctx);
        }
        // first, calculate child positions
        this.initializeCoordinates();
        this.adjustChildCoordinatesRecursive(ctx);
        let boundingBox = null;
        // then calculate bounding box
        this.children.forEach((_, i)=>{
            const childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);
            if (!boundingBox) {
                boundingBox = childBoundingBox;
            } else {
                boundingBox.addBoundingBox(childBoundingBox);
            }
        });
        return boundingBox;
    }
    getFontSize() {
        const { document , parent  } = this;
        const inheritFontSize = Font.parse(document.ctx.font).fontSize;
        const fontSize = parent.getStyle('font-size').getNumber(inheritFontSize);
        return fontSize;
    }
    getTElementBoundingBox(ctx) {
        const fontSize = this.getFontSize();
        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);
    }
    getGlyph(font, text, i) {
        const char = text[i];
        let glyph;
        if (font.isArabic) {
            var ref;
            const len = text.length;
            const prevChar = text[i - 1];
            const nextChar = text[i + 1];
            let arabicForm = 'isolated';
            if ((i === 0 || prevChar === ' ') && i < len - 1 && nextChar !== ' ') {
                arabicForm = 'terminal';
            }
            if (i > 0 && prevChar !== ' ' && i < len - 1 && nextChar !== ' ') {
                arabicForm = 'medial';
            }
            if (i > 0 && prevChar !== ' ' && (i === len - 1 || nextChar === ' ')) {
                arabicForm = 'initial';
            }
            glyph = ((ref = font.arabicGlyphs[char]) === null || ref === void 0 ? void 0 : ref[arabicForm]) || font.glyphs[char];
        } else {
            glyph = font.glyphs[char];
        }
        if (!glyph) {
            glyph = font.missingGlyph;
        }
        return glyph;
    }
    getText() {
        return '';
    }
    getTextFromNode(node) {
        const textNode = node || this.node;
        const childNodes = Array.from(textNode.parentNode.childNodes);
        const index = childNodes.indexOf(textNode);
        const lastIndex = childNodes.length - 1;
        let text = compressSpaces(// textNode.value
        // || textNode.text
        textNode.textContent || '');
        if (index === 0) {
            text = trimLeft(text);
        }
        if (index === lastIndex) {
            text = trimRight(text);
        }
        return text;
    }
    renderChildren(ctx) {
        if (this.type !== 'text') {
            this.renderTElementChildren(ctx);
            return;
        }
        // first, calculate child positions
        this.initializeCoordinates();
        this.adjustChildCoordinatesRecursive(ctx);
        // then render
        this.children.forEach((_, i)=>{
            this.renderChild(ctx, this, this, i);
        });
        const { mouse  } = this.document.screen;
        // Do not calc bounding box if mouse is not working.
        if (mouse.isWorking()) {
            mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
        }
    }
    renderTElementChildren(ctx) {
        const { document , parent  } = this;
        const renderText = this.getText();
        const customFont = parent.getStyle('font-family').getDefinition();
        if (customFont) {
            const { unitsPerEm  } = customFont.fontFace;
            const ctxFont = Font.parse(document.ctx.font);
            const fontSize = parent.getStyle('font-size').getNumber(ctxFont.fontSize);
            const fontStyle = parent.getStyle('font-style').getString(ctxFont.fontStyle);
            const scale = fontSize / unitsPerEm;
            const text = customFont.isRTL ? renderText.split('').reverse().join('') : renderText;
            const dx = toNumbers(parent.getAttribute('dx').getString());
            const len = text.length;
            for(let i = 0; i < len; i++){
                const glyph = this.getGlyph(customFont, text, i);
                ctx.translate(this.x, this.y);
                ctx.scale(scale, -scale);
                const lw = ctx.lineWidth;
                ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;
                if (fontStyle === 'italic') {
                    ctx.transform(1, 0, 0.4, 1, 0, 0);
                }
                glyph.render(ctx);
                if (fontStyle === 'italic') {
                    ctx.transform(1, 0, -0.4, 1, 0, 0);
                }
                ctx.lineWidth = lw;
                ctx.scale(1 / scale, -1 / scale);
                ctx.translate(-this.x, -this.y);
                this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
                if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {
                    this.x += dx[i];
                }
            }
            return;
        }
        const { x , y  } = this;
        // NEED TEST
        // if (ctx.paintOrder === 'stroke') {
        //   if (ctx.strokeStyle) {
        //     ctx.strokeText(renderText, x, y);
        //   }
        //   if (ctx.fillStyle) {
        //     ctx.fillText(renderText, x, y);
        //   }
        // } else {
        if (ctx.fillStyle) {
            ctx.fillText(renderText, x, y);
        }
        if (ctx.strokeStyle) {
            ctx.strokeText(renderText, x, y);
        }
    // }
    }
    applyAnchoring() {
        if (this.textChunkStart >= this.leafTexts.length) {
            return;
        }
        // This is basically the "Apply anchoring" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.
        // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.
        // Vertical text is not supported.
        const firstElement = this.leafTexts[this.textChunkStart];
        const textAnchor = firstElement.getStyle('text-anchor').getString('start');
        const isRTL = false // we treat RTL like LTR
        ;
        let shift = 0;
        if (textAnchor === 'start' && !isRTL || textAnchor === 'end' && isRTL) {
            shift = firstElement.x - this.minX;
        } else if (textAnchor === 'end' && !isRTL || textAnchor === 'start' && isRTL) {
            shift = firstElement.x - this.maxX;
        } else {
            shift = firstElement.x - (this.minX + this.maxX) / 2;
        }
        for(let i = this.textChunkStart; i < this.leafTexts.length; i++){
            this.leafTexts[i].x += shift;
        }
        // start new chunk
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.textChunkStart = this.leafTexts.length;
    }
    adjustChildCoordinatesRecursive(ctx) {
        this.children.forEach((_, i)=>{
            this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);
        });
        this.applyAnchoring();
    }
    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i1) {
        const child = parent.children[i1];
        if (child.children.length > 0) {
            child.children.forEach((_, i)=>{
                textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);
            });
        } else {
            // only leafs are relevant
            this.adjustChildCoordinates(ctx, textParent, parent, i1);
        }
    }
    adjustChildCoordinates(ctx, textParent, parent, i) {
        const child = parent.children[i];
        if (typeof child.measureText !== 'function') {
            return child;
        }
        ctx.save();
        child.setContext(ctx, true);
        const xAttr = child.getAttribute('x');
        const yAttr = child.getAttribute('y');
        const dxAttr = child.getAttribute('dx');
        const dyAttr = child.getAttribute('dy');
        const customFont = child.getStyle('font-family').getDefinition();
        const isRTL = Boolean(customFont === null || customFont === void 0 ? void 0 : customFont.isRTL);
        if (i === 0) {
            // First children inherit attributes from parent(s). Positional attributes
            // are only inherited from a parent to it's first child.
            if (!xAttr.hasValue()) {
                xAttr.setValue(child.getInheritedAttribute('x'));
            }
            if (!yAttr.hasValue()) {
                yAttr.setValue(child.getInheritedAttribute('y'));
            }
            if (!dxAttr.hasValue()) {
                dxAttr.setValue(child.getInheritedAttribute('dx'));
            }
            if (!dyAttr.hasValue()) {
                dyAttr.setValue(child.getInheritedAttribute('dy'));
            }
        }
        const width = child.measureText(ctx);
        if (isRTL) {
            textParent.x -= width;
        }
        if (xAttr.hasValue()) {
            // an "x" attribute marks the start of a new chunk
            textParent.applyAnchoring();
            child.x = xAttr.getPixels('x');
            if (dxAttr.hasValue()) {
                child.x += dxAttr.getPixels('x');
            }
        } else {
            if (dxAttr.hasValue()) {
                textParent.x += dxAttr.getPixels('x');
            }
            child.x = textParent.x;
        }
        textParent.x = child.x;
        if (!isRTL) {
            textParent.x += width;
        }
        if (yAttr.hasValue()) {
            child.y = yAttr.getPixels('y');
            if (dyAttr.hasValue()) {
                child.y += dyAttr.getPixels('y');
            }
        } else {
            if (dyAttr.hasValue()) {
                textParent.y += dyAttr.getPixels('y');
            }
            child.y = textParent.y;
        }
        textParent.y = child.y;
        // update the current chunk and it's bounds
        textParent.leafTexts.push(child);
        textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
        child.clearContext(ctx);
        ctx.restore();
        return child;
    }
    getChildBoundingBox(ctx, textParent, parent, i2) {
        const child = parent.children[i2];
        // not a text node?
        if (typeof child.getBoundingBox !== 'function') {
            return null;
        }
        const boundingBox = child.getBoundingBox(ctx);
        if (boundingBox) {
            child.children.forEach((_, i)=>{
                const childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);
                boundingBox.addBoundingBox(childBoundingBox);
            });
        }
        return boundingBox;
    }
    renderChild(ctx, textParent, parent, i3) {
        const child = parent.children[i3];
        child.render(ctx);
        child.children.forEach((_, i)=>{
            textParent.renderChild(ctx, textParent, child, i);
        });
    }
    measureText(ctx) {
        const { measureCache  } = this;
        if (~measureCache) {
            return measureCache;
        }
        const renderText = this.getText();
        const measure = this.measureTargetText(ctx, renderText);
        this.measureCache = measure;
        return measure;
    }
    measureTargetText(ctx, targetText) {
        if (!targetText.length) {
            return 0;
        }
        const { parent  } = this;
        const customFont = parent.getStyle('font-family').getDefinition();
        if (customFont) {
            const fontSize = this.getFontSize();
            const text = customFont.isRTL ? targetText.split('').reverse().join('') : targetText;
            const dx = toNumbers(parent.getAttribute('dx').getString());
            const len = text.length;
            let measure = 0;
            for(let i = 0; i < len; i++){
                const glyph = this.getGlyph(customFont, text, i);
                measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {
                    measure += dx[i];
                }
            }
            return measure;
        }
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!ctx.measureText) {
            return targetText.length * 10;
        }
        ctx.save();
        this.setContext(ctx, true);
        const { width: measure  } = ctx.measureText(targetText);
        this.clearContext(ctx);
        ctx.restore();
        return measure;
    }
    /**
   * Inherits positional attributes from {@link TextElement} parent(s). Attributes
   * are only inherited from a parent to its first child.
   * @param name - The attribute name.
   * @returns The attribute value or null.
   */ getInheritedAttribute(name) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this
        let current = this;
        while(current instanceof TextElement && current.isFirstChild() && current.parent){
            const parentAttr = current.parent.getAttribute(name);
            if (parentAttr.hasValue(true)) {
                return parentAttr.getString('0');
            }
            current = current.parent;
        }
        return null;
    }
    constructor(document, node, captureTextNodes){
        super(document, node, new.target === TextElement ? true : captureTextNodes);
        this.type = 'text';
        this.x = 0;
        this.y = 0;
        this.leafTexts = [];
        this.textChunkStart = 0;
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.measureCache = -1;
    }
}

class TSpanElement extends TextElement {
    getText() {
        return this.text;
    }
    constructor(document, node, captureTextNodes){
        super(document, node, new.target === TSpanElement ? true : captureTextNodes);
        this.type = 'tspan';
        // if this node has children, then they own the text
        this.text = this.children.length > 0 ? '' : this.getTextFromNode();
    }
}

class TextNode extends TSpanElement {
    constructor(...args){
        super(...args);
        this.type = 'textNode';
    }
}

class PathParser extends svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData {
    reset() {
        this.i = -1;
        this.command = null;
        this.previousCommand = null;
        this.start = new Point(0, 0);
        this.control = new Point(0, 0);
        this.current = new Point(0, 0);
        this.points = [];
        this.angles = [];
    }
    isEnd() {
        const { i , commands  } = this;
        return i >= commands.length - 1;
    }
    next() {
        const command = this.commands[++this.i];
        this.previousCommand = this.command;
        this.command = command;
        return command;
    }
    getPoint() {
        let xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'x', yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'y';
        const point = new Point(this.command[xProp], this.command[yProp]);
        return this.makeAbsolute(point);
    }
    getAsControlPoint(xProp, yProp) {
        const point = this.getPoint(xProp, yProp);
        this.control = point;
        return point;
    }
    getAsCurrentPoint(xProp, yProp) {
        const point = this.getPoint(xProp, yProp);
        this.current = point;
        return point;
    }
    getReflectedControlPoint() {
        const previousCommand = this.previousCommand.type;
        if (previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.QUAD_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.SMOOTH_QUAD_TO) {
            return this.current;
        }
        // reflect point
        const { current: { x: cx , y: cy  } , control: { x: ox , y: oy  }  } = this;
        const point = new Point(2 * cx - ox, 2 * cy - oy);
        return point;
    }
    makeAbsolute(point) {
        if (this.command.relative) {
            const { x , y  } = this.current;
            point.x += x;
            point.y += y;
        }
        return point;
    }
    addMarker(point, from, priorTo) {
        const { points , angles  } = this;
        // if the last angle isn't filled in because we didn't have this point yet ...
        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
            angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
        }
        this.addMarkerAngle(point, from ? from.angleTo(point) : null);
    }
    addMarkerAngle(point, angle) {
        this.points.push(point);
        this.angles.push(angle);
    }
    getMarkerPoints() {
        return this.points;
    }
    getMarkerAngles() {
        const { angles  } = this;
        const len = angles.length;
        for(let i = 0; i < len; i++){
            if (!angles[i]) {
                for(let j = i + 1; j < len; j++){
                    if (angles[j]) {
                        angles[i] = angles[j];
                        break;
                    }
                }
            }
        }
        return angles;
    }
    constructor(path){
        super(path// Fix spaces after signs.
        .replace(/([+\-.])\s+/gm, '$1')// Remove invalid part.
        .replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ''));
        this.control = new Point(0, 0);
        this.start = new Point(0, 0);
        this.current = new Point(0, 0);
        this.command = null;
        this.commands = this.commands;
        this.i = -1;
        this.previousCommand = null;
        this.points = [];
        this.angles = [];
    }
}

class PathElement extends RenderedElement {
    path(ctx) {
        const { pathParser  } = this;
        const boundingBox = new BoundingBox();
        pathParser.reset();
        if (ctx) {
            ctx.beginPath();
        }
        while(!pathParser.isEnd()){
            switch(pathParser.next().type){
                case PathParser.MOVE_TO:
                    this.pathM(ctx, boundingBox);
                    break;
                case PathParser.LINE_TO:
                    this.pathL(ctx, boundingBox);
                    break;
                case PathParser.HORIZ_LINE_TO:
                    this.pathH(ctx, boundingBox);
                    break;
                case PathParser.VERT_LINE_TO:
                    this.pathV(ctx, boundingBox);
                    break;
                case PathParser.CURVE_TO:
                    this.pathC(ctx, boundingBox);
                    break;
                case PathParser.SMOOTH_CURVE_TO:
                    this.pathS(ctx, boundingBox);
                    break;
                case PathParser.QUAD_TO:
                    this.pathQ(ctx, boundingBox);
                    break;
                case PathParser.SMOOTH_QUAD_TO:
                    this.pathT(ctx, boundingBox);
                    break;
                case PathParser.ARC:
                    this.pathA(ctx, boundingBox);
                    break;
                case PathParser.CLOSE_PATH:
                    this.pathZ(ctx, boundingBox);
                    break;
            }
        }
        return boundingBox;
    }
    getBoundingBox(_ctx) {
        return this.path();
    }
    getMarkers() {
        const { pathParser  } = this;
        const points = pathParser.getMarkerPoints();
        const angles = pathParser.getMarkerAngles();
        const markers = points.map((point, i)=>[
                point,
                angles[i]
            ]
        );
        return markers;
    }
    renderChildren(ctx) {
        this.path(ctx);
        this.document.screen.mouse.checkPath(this, ctx);
        const fillRuleStyleProp = this.getStyle('fill-rule');
        if (ctx.fillStyle !== '') {
            if (fillRuleStyleProp.getString('inherit') !== 'inherit') {
                ctx.fill(fillRuleStyleProp.getString());
            } else {
                ctx.fill();
            }
        }
        if (ctx.strokeStyle !== '') {
            if (this.getAttribute('vector-effect').getString() === 'non-scaling-stroke') {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.stroke();
                ctx.restore();
            } else {
                ctx.stroke();
            }
        }
        const markers = this.getMarkers();
        if (markers) {
            const markersLastIndex = markers.length - 1;
            const markerStartStyleProp = this.getStyle('marker-start');
            const markerMidStyleProp = this.getStyle('marker-mid');
            const markerEndStyleProp = this.getStyle('marker-end');
            if (markerStartStyleProp.isUrlDefinition()) {
                const marker = markerStartStyleProp.getDefinition();
                const [point, angle] = markers[0];
                marker.render(ctx, point, angle);
            }
            if (markerMidStyleProp.isUrlDefinition()) {
                const marker = markerMidStyleProp.getDefinition();
                for(let i = 1; i < markersLastIndex; i++){
                    const [point, angle] = markers[i];
                    marker.render(ctx, point, angle);
                }
            }
            if (markerEndStyleProp.isUrlDefinition()) {
                const marker = markerEndStyleProp.getDefinition();
                const [point, angle] = markers[markersLastIndex];
                marker.render(ctx, point, angle);
            }
        }
    }
    static pathM(pathParser) {
        const point = pathParser.getAsCurrentPoint();
        pathParser.start = pathParser.current;
        return {
            point
        };
    }
    pathM(ctx, boundingBox) {
        const { pathParser  } = this;
        const { point  } = PathElement.pathM(pathParser);
        const { x , y  } = point;
        pathParser.addMarker(point);
        boundingBox.addPoint(x, y);
        if (ctx) {
            ctx.moveTo(x, y);
        }
    }
    static pathL(pathParser) {
        const { current  } = pathParser;
        const point = pathParser.getAsCurrentPoint();
        return {
            current,
            point
        };
    }
    pathL(ctx, boundingBox) {
        const { pathParser  } = this;
        const { current , point  } = PathElement.pathL(pathParser);
        const { x , y  } = point;
        pathParser.addMarker(point, current);
        boundingBox.addPoint(x, y);
        if (ctx) {
            ctx.lineTo(x, y);
        }
    }
    static pathH(pathParser) {
        const { current , command  } = pathParser;
        const point = new Point((command.relative ? current.x : 0) + command.x, current.y);
        pathParser.current = point;
        return {
            current,
            point
        };
    }
    pathH(ctx, boundingBox) {
        const { pathParser  } = this;
        const { current , point  } = PathElement.pathH(pathParser);
        const { x , y  } = point;
        pathParser.addMarker(point, current);
        boundingBox.addPoint(x, y);
        if (ctx) {
            ctx.lineTo(x, y);
        }
    }
    static pathV(pathParser) {
        const { current , command  } = pathParser;
        const point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
        pathParser.current = point;
        return {
            current,
            point
        };
    }
    pathV(ctx, boundingBox) {
        const { pathParser  } = this;
        const { current , point  } = PathElement.pathV(pathParser);
        const { x , y  } = point;
        pathParser.addMarker(point, current);
        boundingBox.addPoint(x, y);
        if (ctx) {
            ctx.lineTo(x, y);
        }
    }
    static pathC(pathParser) {
        const { current  } = pathParser;
        const point = pathParser.getPoint('x1', 'y1');
        const controlPoint = pathParser.getAsControlPoint('x2', 'y2');
        const currentPoint = pathParser.getAsCurrentPoint();
        return {
            current,
            point,
            controlPoint,
            currentPoint
        };
    }
    pathC(ctx, boundingBox) {
        const { pathParser  } = this;
        const { current , point , controlPoint , currentPoint  } = PathElement.pathC(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, point);
        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
    }
    static pathS(pathParser) {
        const { current  } = pathParser;
        const point = pathParser.getReflectedControlPoint();
        const controlPoint = pathParser.getAsControlPoint('x2', 'y2');
        const currentPoint = pathParser.getAsCurrentPoint();
        return {
            current,
            point,
            controlPoint,
            currentPoint
        };
    }
    pathS(ctx, boundingBox) {
        const { pathParser  } = this;
        const { current , point , controlPoint , currentPoint  } = PathElement.pathS(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, point);
        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
    }
    static pathQ(pathParser) {
        const { current  } = pathParser;
        const controlPoint = pathParser.getAsControlPoint('x1', 'y1');
        const currentPoint = pathParser.getAsCurrentPoint();
        return {
            current,
            controlPoint,
            currentPoint
        };
    }
    pathQ(ctx, boundingBox) {
        const { pathParser  } = this;
        const { current , controlPoint , currentPoint  } = PathElement.pathQ(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, controlPoint);
        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
    }
    static pathT(pathParser) {
        const { current  } = pathParser;
        const controlPoint = pathParser.getReflectedControlPoint();
        pathParser.control = controlPoint;
        const currentPoint = pathParser.getAsCurrentPoint();
        return {
            current,
            controlPoint,
            currentPoint
        };
    }
    pathT(ctx, boundingBox) {
        const { pathParser  } = this;
        const { current , controlPoint , currentPoint  } = PathElement.pathT(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, controlPoint);
        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
    }
    static pathA(pathParser) {
        const { current , command  } = pathParser;
        let { rX , rY , xRot , lArcFlag , sweepFlag  } = command;
        const xAxisRotation = xRot * (Math.PI / 180);
        const currentPoint = pathParser.getAsCurrentPoint();
        // Conversion from endpoint to center parameterization
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        // x1', y1'
        const currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
        // adjust radii
        const l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
        if (l > 1) {
            rX *= Math.sqrt(l);
            rY *= Math.sqrt(l);
        }
        // cx', cy'
        let s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
        if (isNaN(s)) {
            s = 0;
        }
        const cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX);
        // cx, cy
        const centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
        // initial angle
        const a1 = vectorsAngle([
            1,
            0
        ], [
            (currp.x - cpp.x) / rX,
            (currp.y - cpp.y) / rY
        ]) // 1
        ;
        // angle delta
        const u = [
            (currp.x - cpp.x) / rX,
            (currp.y - cpp.y) / rY
        ];
        const v = [
            (-currp.x - cpp.x) / rX,
            (-currp.y - cpp.y) / rY
        ];
        let ad = vectorsAngle(u, v) // 
        ;
        if (vectorsRatio(u, v) <= -1) {
            ad = Math.PI;
        }
        if (vectorsRatio(u, v) >= 1) {
            ad = 0;
        }
        return {
            currentPoint,
            rX,
            rY,
            sweepFlag,
            xAxisRotation,
            centp,
            a1,
            ad
        };
    }
    pathA(ctx, boundingBox) {
        const { pathParser  } = this;
        const { currentPoint , rX , rY , sweepFlag , xAxisRotation , centp , a1 , ad  } = PathElement.pathA(pathParser);
        // for markers
        const dir = 1 - sweepFlag ? 1 : -1;
        const ah = a1 + dir * (ad / 2);
        const halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
        pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
        pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
        boundingBox.addPoint(currentPoint.x, currentPoint.y) // TODO: this is too naive, make it better
        ;
        if (ctx && !isNaN(a1) && !isNaN(ad)) {
            const r = rX > rY ? rX : rY;
            const sx = rX > rY ? 1 : rX / rY;
            const sy = rX > rY ? rY / rX : 1;
            ctx.translate(centp.x, centp.y);
            ctx.rotate(xAxisRotation);
            ctx.scale(sx, sy);
            ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));
            ctx.scale(1 / sx, 1 / sy);
            ctx.rotate(-xAxisRotation);
            ctx.translate(-centp.x, -centp.y);
        }
    }
    static pathZ(pathParser) {
        pathParser.current = pathParser.start;
    }
    pathZ(ctx, boundingBox) {
        PathElement.pathZ(this.pathParser);
        if (ctx) {
            // only close path if it is not a straight line
            if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
                ctx.closePath();
            }
        }
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'path';
        this.pathParser = new PathParser(this.getAttribute('d').getString());
    }
}

class SVGElement extends RenderedElement {
    setContext(ctx) {
        var ref;
        const { document  } = this;
        const { screen , window  } = document;
        const canvas = ctx.canvas;
        screen.setDefaults(ctx);
        if ('style' in canvas && typeof ctx.font !== 'undefined' && window && typeof window.getComputedStyle !== 'undefined') {
            ctx.font = window.getComputedStyle(canvas).getPropertyValue('font');
            const fontSizeProp = new Property(document, 'fontSize', Font.parse(ctx.font).fontSize);
            if (fontSizeProp.hasValue()) {
                document.rootEmSize = fontSizeProp.getPixels('y');
                document.emSize = document.rootEmSize;
            }
        }
        // create new view port
        if (!this.getAttribute('x').hasValue()) {
            this.getAttribute('x', true).setValue(0);
        }
        if (!this.getAttribute('y').hasValue()) {
            this.getAttribute('y', true).setValue(0);
        }
        let { width , height  } = screen.viewPort;
        if (!this.getStyle('width').hasValue()) {
            this.getStyle('width', true).setValue('100%');
        }
        if (!this.getStyle('height').hasValue()) {
            this.getStyle('height', true).setValue('100%');
        }
        if (!this.getStyle('color').hasValue()) {
            this.getStyle('color', true).setValue('black');
        }
        const refXAttr = this.getAttribute('refX');
        const refYAttr = this.getAttribute('refY');
        const viewBoxAttr = this.getAttribute('viewBox');
        const viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
        const clip = !this.root && this.getStyle('overflow').getValue('hidden') !== 'visible';
        let minX = 0;
        let minY = 0;
        let clipX = 0;
        let clipY = 0;
        if (viewBox) {
            minX = viewBox[0];
            minY = viewBox[1];
        }
        if (!this.root) {
            width = this.getStyle('width').getPixels('x');
            height = this.getStyle('height').getPixels('y');
            if (this.type === 'marker') {
                clipX = minX;
                clipY = minY;
                minX = 0;
                minY = 0;
            }
        }
        screen.viewPort.setCurrent(width, height);
        // Default value of transform-origin is center only for root SVG elements
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin
        if (this.node // is not temporary SVGElement
         && (!this.parent || ((ref = this.node.parentNode) === null || ref === void 0 ? void 0 : ref.nodeName) === 'foreignObject') && this.getStyle('transform', false, true).hasValue() && !this.getStyle('transform-origin', false, true).hasValue()) {
            this.getStyle('transform-origin', true, true).setValue('50% 50%');
        }
        super.setContext(ctx);
        ctx.translate(this.getAttribute('x').getPixels('x'), this.getAttribute('y').getPixels('y'));
        if (viewBox) {
            width = viewBox[2];
            height = viewBox[3];
        }
        document.setViewBox({
            ctx,
            aspectRatio: this.getAttribute('preserveAspectRatio').getString(),
            width: screen.viewPort.width,
            desiredWidth: width,
            height: screen.viewPort.height,
            desiredHeight: height,
            minX,
            minY,
            refX: refXAttr.getValue(),
            refY: refYAttr.getValue(),
            clip,
            clipX,
            clipY
        });
        if (viewBox) {
            screen.viewPort.removeCurrent();
            screen.viewPort.setCurrent(width, height);
        }
    }
    clearContext(ctx) {
        super.clearContext(ctx);
        this.document.screen.viewPort.removeCurrent();
    }
    /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */ resize(width) {
        let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width, preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        const widthAttr = this.getAttribute('width', true);
        const heightAttr = this.getAttribute('height', true);
        const viewBoxAttr = this.getAttribute('viewBox');
        const styleAttr = this.getAttribute('style');
        const originWidth = widthAttr.getNumber(0);
        const originHeight = heightAttr.getNumber(0);
        if (preserveAspectRatio) {
            if (typeof preserveAspectRatio === 'string') {
                this.getAttribute('preserveAspectRatio', true).setValue(preserveAspectRatio);
            } else {
                const preserveAspectRatioAttr = this.getAttribute('preserveAspectRatio');
                if (preserveAspectRatioAttr.hasValue()) {
                    preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, '$1'));
                }
            }
        }
        widthAttr.setValue(width);
        heightAttr.setValue(height);
        if (!viewBoxAttr.hasValue()) {
            viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
        }
        if (styleAttr.hasValue()) {
            const widthStyle = this.getStyle('width');
            const heightStyle = this.getStyle('height');
            if (widthStyle.hasValue()) {
                widthStyle.setValue("".concat(width, "px"));
            }
            if (heightStyle.hasValue()) {
                heightStyle.setValue("".concat(height, "px"));
            }
        }
    }
    constructor(...args){
        super(...args);
        this.type = 'svg';
        this.root = false;
    }
}

class RectElement extends PathElement {
    path(ctx) {
        const x = this.getAttribute('x').getPixels('x');
        const y = this.getAttribute('y').getPixels('y');
        const width = this.getStyle('width', false, true).getPixels('x');
        const height = this.getStyle('height', false, true).getPixels('y');
        const rxAttr = this.getAttribute('rx');
        const ryAttr = this.getAttribute('ry');
        let rx = rxAttr.getPixels('x');
        let ry = ryAttr.getPixels('y');
        if (rxAttr.hasValue() && !ryAttr.hasValue()) {
            ry = rx;
        }
        if (ryAttr.hasValue() && !rxAttr.hasValue()) {
            rx = ry;
        }
        rx = Math.min(rx, width / 2);
        ry = Math.min(ry, height / 2);
        if (ctx) {
            const KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
            ctx.beginPath() // always start the path so we don't fill prior paths
            ;
            if (height > 0 && width > 0) {
                ctx.moveTo(x + rx, y);
                ctx.lineTo(x + width - rx, y);
                ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);
                ctx.lineTo(x + width, y + height - ry);
                ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);
                ctx.lineTo(x + rx, y + height);
                ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);
                ctx.lineTo(x, y + ry);
                ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);
                ctx.closePath();
            }
        }
        return new BoundingBox(x, y, x + width, y + height);
    }
    getMarkers() {
        return null;
    }
    constructor(...args){
        super(...args);
        this.type = 'rect';
    }
}

class CircleElement extends PathElement {
    path(ctx) {
        const cx = this.getAttribute('cx').getPixels('x');
        const cy = this.getAttribute('cy').getPixels('y');
        const r = this.getAttribute('r').getPixels();
        if (ctx && r > 0) {
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2, false);
            ctx.closePath();
        }
        return new BoundingBox(cx - r, cy - r, cx + r, cy + r);
    }
    getMarkers() {
        return null;
    }
    constructor(...args){
        super(...args);
        this.type = 'circle';
    }
}

class EllipseElement extends PathElement {
    path(ctx) {
        const KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
        const rx = this.getAttribute('rx').getPixels('x');
        const ry = this.getAttribute('ry').getPixels('y');
        const cx = this.getAttribute('cx').getPixels('x');
        const cy = this.getAttribute('cy').getPixels('y');
        if (ctx && rx > 0 && ry > 0) {
            ctx.beginPath();
            ctx.moveTo(cx + rx, cy);
            ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
            ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
            ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
            ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
            ctx.closePath();
        }
        return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
    }
    getMarkers() {
        return null;
    }
    constructor(...args){
        super(...args);
        this.type = 'ellipse';
    }
}

class LineElement extends PathElement {
    getPoints() {
        return [
            new Point(this.getAttribute('x1').getPixels('x'), this.getAttribute('y1').getPixels('y')),
            new Point(this.getAttribute('x2').getPixels('x'), this.getAttribute('y2').getPixels('y'))
        ];
    }
    path(ctx) {
        const [{ x: x0 , y: y0  }, { x: x1 , y: y1  }] = this.getPoints();
        if (ctx) {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
        }
        return new BoundingBox(x0, y0, x1, y1);
    }
    getMarkers() {
        const [p0, p1] = this.getPoints();
        const a = p0.angleTo(p1);
        return [
            [
                p0,
                a
            ],
            [
                p1,
                a
            ]
        ];
    }
    constructor(...args){
        super(...args);
        this.type = 'line';
    }
}

class PolylineElement extends PathElement {
    path(ctx) {
        const { points  } = this;
        const [{ x: x0 , y: y0  }] = points;
        const boundingBox = new BoundingBox(x0, y0);
        if (ctx) {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
        }
        points.forEach((param)=>{
            let { x , y  } = param;
            boundingBox.addPoint(x, y);
            if (ctx) {
                ctx.lineTo(x, y);
            }
        });
        return boundingBox;
    }
    getMarkers() {
        const { points  } = this;
        const lastIndex = points.length - 1;
        const markers = [];
        points.forEach((point, i)=>{
            if (i === lastIndex) {
                return;
            }
            markers.push([
                point,
                point.angleTo(points[i + 1])
            ]);
        });
        if (markers.length > 0) {
            markers.push([
                points[points.length - 1],
                markers[markers.length - 1][1]
            ]);
        }
        return markers;
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'polyline';
        this.points = [];
        this.points = Point.parsePath(this.getAttribute('points').getString());
    }
}

class PolygonElement extends PolylineElement {
    path(ctx) {
        const boundingBox = super.path(ctx);
        const [{ x , y  }] = this.points;
        if (ctx) {
            ctx.lineTo(x, y);
            ctx.closePath();
        }
        return boundingBox;
    }
    constructor(...args){
        super(...args);
        this.type = 'polygon';
    }
}

class PatternElement extends Element {
    createPattern(ctx, _, parentOpacityProp) {
        const width = this.getStyle('width').getPixels('x', true);
        const height = this.getStyle('height').getPixels('y', true);
        // render me using a temporary svg element
        const patternSvg = new SVGElement(this.document, null);
        patternSvg.attributes.viewBox = new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue());
        patternSvg.attributes.width = new Property(this.document, 'width', "".concat(width, "px"));
        patternSvg.attributes.height = new Property(this.document, 'height', "".concat(height, "px"));
        patternSvg.attributes.transform = new Property(this.document, 'transform', this.getAttribute('patternTransform').getValue());
        patternSvg.children = this.children;
        const patternCanvas = this.document.createCanvas(width, height);
        const patternCtx = patternCanvas.getContext('2d');
        const xAttr = this.getAttribute('x');
        const yAttr = this.getAttribute('y');
        if (xAttr.hasValue() && yAttr.hasValue()) {
            patternCtx.translate(xAttr.getPixels('x', true), yAttr.getPixels('y', true));
        }
        if (parentOpacityProp.hasValue()) {
            this.styles['fill-opacity'] = parentOpacityProp;
        } else {
            Reflect.deleteProperty(this.styles, 'fill-opacity');
        }
        // render 3x3 grid so when we transform there's no white space on edges
        for(let x = -1; x <= 1; x++){
            for(let y = -1; y <= 1; y++){
                patternCtx.save();
                patternSvg.attributes.x = new Property(this.document, 'x', x * patternCanvas.width);
                patternSvg.attributes.y = new Property(this.document, 'y', y * patternCanvas.height);
                patternSvg.render(patternCtx);
                patternCtx.restore();
            }
        }
        const pattern = ctx.createPattern(patternCanvas, 'repeat');
        return pattern;
    }
    constructor(...args){
        super(...args);
        this.type = 'pattern';
    }
}

class MarkerElement extends Element {
    render(ctx, point, angle) {
        if (!point) {
            return;
        }
        const { x , y  } = point;
        const orient = this.getAttribute('orient').getString('auto');
        const markerUnits = this.getAttribute('markerUnits').getString('strokeWidth');
        ctx.translate(x, y);
        if (orient === 'auto') {
            ctx.rotate(angle);
        }
        if (markerUnits === 'strokeWidth') {
            ctx.scale(ctx.lineWidth, ctx.lineWidth);
        }
        ctx.save();
        // render me using a temporary svg element
        const markerSvg = new SVGElement(this.document);
        markerSvg.type = this.type;
        markerSvg.attributes.viewBox = new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue());
        markerSvg.attributes.refX = new Property(this.document, 'refX', this.getAttribute('refX').getValue());
        markerSvg.attributes.refY = new Property(this.document, 'refY', this.getAttribute('refY').getValue());
        markerSvg.attributes.width = new Property(this.document, 'width', this.getAttribute('markerWidth').getValue());
        markerSvg.attributes.height = new Property(this.document, 'height', this.getAttribute('markerHeight').getValue());
        markerSvg.attributes.overflow = new Property(this.document, 'overflow', this.getAttribute('overflow').getValue());
        markerSvg.attributes.fill = new Property(this.document, 'fill', this.getAttribute('fill').getColor('black'));
        markerSvg.attributes.stroke = new Property(this.document, 'stroke', this.getAttribute('stroke').getValue('none'));
        markerSvg.children = this.children;
        markerSvg.render(ctx);
        ctx.restore();
        if (markerUnits === 'strokeWidth') {
            ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
        }
        if (orient === 'auto') {
            ctx.rotate(-angle);
        }
        ctx.translate(-x, -y);
    }
    constructor(...args){
        super(...args);
        this.type = 'marker';
    }
}

class DefsElement extends Element {
    render() {
    // NOOP
    }
    constructor(...args){
        super(...args);
        this.type = 'defs';
    }
}

class GElement extends RenderedElement {
    getBoundingBox(ctx) {
        const boundingBox = new BoundingBox();
        this.children.forEach((child)=>{
            boundingBox.addBoundingBox(child.getBoundingBox(ctx));
        });
        return boundingBox;
    }
    constructor(...args){
        super(...args);
        this.type = 'g';
    }
}

class GradientElement extends Element {
    getGradientUnits() {
        return this.getAttribute('gradientUnits').getString('objectBoundingBox');
    }
    createGradient(ctx, element, parentOpacityProp) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this
        let stopsContainer = this;
        if (this.getHrefAttribute().hasValue()) {
            stopsContainer = this.getHrefAttribute().getDefinition();
            this.inheritStopContainer(stopsContainer);
        }
        const { stops  } = stopsContainer;
        const gradient = this.getGradient(ctx, element);
        if (!gradient) {
            return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
        }
        stops.forEach((stop)=>{
            gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
        });
        if (this.getAttribute('gradientTransform').hasValue()) {
            // render as transformed pattern on temporary canvas
            const { document  } = this;
            const { MAX_VIRTUAL_PIXELS  } = Screen;
            const { viewPort  } = document.screen;
            const rootView = viewPort.getRoot();
            const rect = new RectElement(document);
            rect.attributes.x = new Property(document, 'x', -MAX_VIRTUAL_PIXELS / 3);
            rect.attributes.y = new Property(document, 'y', -MAX_VIRTUAL_PIXELS / 3);
            rect.attributes.width = new Property(document, 'width', MAX_VIRTUAL_PIXELS);
            rect.attributes.height = new Property(document, 'height', MAX_VIRTUAL_PIXELS);
            const group = new GElement(document);
            group.attributes.transform = new Property(document, 'transform', this.getAttribute('gradientTransform').getValue());
            group.children = [
                rect
            ];
            const patternSvg = new SVGElement(document);
            patternSvg.attributes.x = new Property(document, 'x', 0);
            patternSvg.attributes.y = new Property(document, 'y', 0);
            patternSvg.attributes.width = new Property(document, 'width', rootView.width);
            patternSvg.attributes.height = new Property(document, 'height', rootView.height);
            patternSvg.children = [
                group
            ];
            const patternCanvas = document.createCanvas(rootView.width, rootView.height);
            const patternCtx = patternCanvas.getContext('2d');
            patternCtx.fillStyle = gradient;
            patternSvg.render(patternCtx);
            return patternCtx.createPattern(patternCanvas, 'no-repeat');
        }
        return gradient;
    }
    inheritStopContainer(stopsContainer) {
        this.attributesToInherit.forEach((attributeToInherit)=>{
            if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
                this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
            }
        });
    }
    addParentOpacity(parentOpacityProp, color) {
        if (parentOpacityProp.hasValue()) {
            const colorProp = new Property(this.document, 'color', color);
            return colorProp.addOpacity(parentOpacityProp).getColor();
        }
        return color;
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.attributesToInherit = [
            'gradientUnits'
        ];
        this.stops = [];
        const { stops , children  } = this;
        children.forEach((child)=>{
            if (child.type === 'stop') {
                stops.push(child);
            }
        });
    }
}

class LinearGradientElement extends GradientElement {
    getGradient(ctx, element) {
        const isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';
        const boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;
        if (isBoundingBoxUnits && !boundingBox) {
            return null;
        }
        if (!this.getAttribute('x1').hasValue() && !this.getAttribute('y1').hasValue() && !this.getAttribute('x2').hasValue() && !this.getAttribute('y2').hasValue()) {
            this.getAttribute('x1', true).setValue(0);
            this.getAttribute('y1', true).setValue(0);
            this.getAttribute('x2', true).setValue(1);
            this.getAttribute('y2', true).setValue(0);
        }
        const x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x1').getNumber() : this.getAttribute('x1').getPixels('x');
        const y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y1').getNumber() : this.getAttribute('y1').getPixels('y');
        const x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x2').getNumber() : this.getAttribute('x2').getPixels('x');
        const y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y2').getNumber() : this.getAttribute('y2').getPixels('y');
        if (x1 === x2 && y1 === y2) {
            return null;
        }
        return ctx.createLinearGradient(x1, y1, x2, y2);
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'linearGradient';
        this.attributesToInherit.push('x1', 'y1', 'x2', 'y2');
    }
}

class RadialGradientElement extends GradientElement {
    getGradient(ctx, element) {
        const isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';
        const boundingBox = element.getBoundingBox(ctx);
        if (isBoundingBoxUnits && !boundingBox) {
            return null;
        }
        if (!this.getAttribute('cx').hasValue()) {
            this.getAttribute('cx', true).setValue('50%');
        }
        if (!this.getAttribute('cy').hasValue()) {
            this.getAttribute('cy', true).setValue('50%');
        }
        if (!this.getAttribute('r').hasValue()) {
            this.getAttribute('r', true).setValue('50%');
        }
        const cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('cx').getNumber() : this.getAttribute('cx').getPixels('x');
        const cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('cy').getNumber() : this.getAttribute('cy').getPixels('y');
        let fx = cx;
        let fy = cy;
        if (this.getAttribute('fx').hasValue()) {
            fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('fx').getNumber() : this.getAttribute('fx').getPixels('x');
        }
        if (this.getAttribute('fy').hasValue()) {
            fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('fy').getNumber() : this.getAttribute('fy').getPixels('y');
        }
        const r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute('r').getNumber() : this.getAttribute('r').getPixels();
        const fr = this.getAttribute('fr').getPixels();
        return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'radialGradient';
        this.attributesToInherit.push('cx', 'cy', 'r', 'fx', 'fy', 'fr');
    }
}

class StopElement extends Element {
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'stop';
        const offset = Math.max(0, Math.min(1, this.getAttribute('offset').getNumber()));
        const stopOpacity = this.getStyle('stop-opacity');
        let stopColor = this.getStyle('stop-color', true);
        if (stopColor.getString() === '') {
            stopColor.setValue('#000');
        }
        if (stopOpacity.hasValue()) {
            stopColor = stopColor.addOpacity(stopOpacity);
        }
        this.offset = offset;
        this.color = stopColor.getColor();
    }
}

class AnimateElement extends Element {
    getProperty() {
        const attributeType = this.getAttribute('attributeType').getString();
        const attributeName = this.getAttribute('attributeName').getString();
        if (attributeType === 'CSS') {
            return this.parent.getStyle(attributeName, true);
        }
        return this.parent.getAttribute(attributeName, true);
    }
    calcValue() {
        const { initialUnits  } = this;
        const { progress , from , to  } = this.getProgress();
        // tween value linearly
        let newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;
        if (initialUnits === '%') {
            newValue *= 100 // numValue() returns 0-1 whereas properties are 0-100
            ;
        }
        return "".concat(newValue).concat(initialUnits);
    }
    update(delta) {
        const { parent  } = this;
        const prop = this.getProperty();
        // set initial value
        if (!this.initialValue) {
            this.initialValue = prop.getString();
            this.initialUnits = prop.getUnits();
        }
        // if we're past the end time
        if (this.duration > this.maxDuration) {
            const fill = this.getAttribute('fill').getString('remove');
            // loop for indefinitely repeating animations
            if (this.getAttribute('repeatCount').getString() === 'indefinite' || this.getAttribute('repeatDur').getString() === 'indefinite') {
                this.duration = 0;
            } else if (fill === 'freeze' && !this.frozen) {
                this.frozen = true;
                if (parent && prop) {
                    parent.animationFrozen = true;
                    parent.animationFrozenValue = prop.getString();
                }
            } else if (fill === 'remove' && !this.removed) {
                this.removed = true;
                if (parent && prop) {
                    prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
                }
                return true;
            }
            return false;
        }
        this.duration += delta;
        // if we're past the begin time
        let updated = false;
        if (this.begin < this.duration) {
            let newValue = this.calcValue() // tween
            ;
            const typeAttr = this.getAttribute('type');
            if (typeAttr.hasValue()) {
                // for transform, etc.
                const type = typeAttr.getString();
                newValue = "".concat(type, "(").concat(newValue, ")");
            }
            prop.setValue(newValue);
            updated = true;
        }
        return updated;
    }
    getProgress() {
        const { document , values  } = this;
        let progress = (this.duration - this.begin) / (this.maxDuration - this.begin);
        let from;
        let to;
        if (values.hasValue()) {
            const p = progress * (values.getValue().length - 1);
            const lb = Math.floor(p);
            const ub = Math.ceil(p);
            let value;
            value = values.getValue()[lb];
            from = new Property(document, 'from', value ? parseFloat(value) : 0);
            value = values.getValue()[ub];
            to = new Property(document, 'to', value ? parseFloat(value) : 0);
            progress = (p - lb) / (ub - lb);
        } else {
            from = this.from;
            to = this.to;
        }
        return {
            progress,
            from,
            to
        };
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'animate';
        this.duration = 0;
        this.initialUnits = '';
        this.removed = false;
        this.frozen = false;
        document.screen.animations.push(this);
        this.begin = this.getAttribute('begin').getMilliseconds();
        this.maxDuration = this.begin + this.getAttribute('dur').getMilliseconds();
        this.from = this.getAttribute('from');
        this.to = this.getAttribute('to');
        this.values = new Property(document, 'values', null);
        const valuesAttr = this.getAttribute('values');
        if (valuesAttr.hasValue()) {
            this.values.setValue(valuesAttr.getString().split(';'));
        }
    }
}

class AnimateColorElement extends AnimateElement {
    calcValue() {
        const { progress , from , to  } = this.getProgress();
        const colorFrom = new rgbcolor__WEBPACK_IMPORTED_MODULE_1__(from.getColor());
        const colorTo = new rgbcolor__WEBPACK_IMPORTED_MODULE_1__(to.getColor());
        if (colorFrom.ok && colorTo.ok) {
            // tween color linearly
            const r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
            const g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
            const b = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
            // ? alpha
            return "rgb(".concat(Math.floor(r), ", ").concat(Math.floor(g), ", ").concat(Math.floor(b), ")");
        }
        return this.getAttribute('from').getColor();
    }
    constructor(...args){
        super(...args);
        this.type = 'animateColor';
    }
}

class AnimateTransformElement extends AnimateElement {
    calcValue() {
        const { progress , from: from1 , to: to1  } = this.getProgress();
        // tween value linearly
        const transformFrom = toNumbers(from1.getString());
        const transformTo = toNumbers(to1.getString());
        const newValue = transformFrom.map((from, i)=>{
            const to = transformTo[i];
            return from + (to - from) * progress;
        }).join(' ');
        return newValue;
    }
    constructor(...args){
        super(...args);
        this.type = 'animateTransform';
    }
}

class FontFaceElement extends Element {
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'font-face';
        this.ascent = this.getAttribute('ascent').getNumber();
        this.descent = this.getAttribute('descent').getNumber();
        this.unitsPerEm = this.getAttribute('units-per-em').getNumber();
    }
}

class GlyphElement extends PathElement {
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'glyph';
        this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();
        this.unicode = this.getAttribute('unicode').getString();
        this.arabicForm = this.getAttribute('arabic-form').getString();
    }
}

class MissingGlyphElement extends GlyphElement {
    constructor(...args){
        super(...args);
        this.type = 'missing-glyph';
        this.horizAdvX = 0;
    }
}

class FontElement extends Element {
    render() {
    // NO RENDER
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'font';
        this.isArabic = false;
        this.glyphs = {};
        this.arabicGlyphs = {};
        this.isRTL = false;
        this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();
        const { definitions  } = document;
        const { children  } = this;
        for (const child of children){
            if (child instanceof FontFaceElement) {
                this.fontFace = child;
                const fontFamilyStyle = child.getStyle('font-family');
                if (fontFamilyStyle.hasValue()) {
                    definitions[fontFamilyStyle.getString()] = this;
                }
            } else if (child instanceof MissingGlyphElement) {
                this.missingGlyph = child;
            } else if (child instanceof GlyphElement) {
                if (child.arabicForm) {
                    this.isRTL = true;
                    this.isArabic = true;
                    const arabicGlyph = this.arabicGlyphs[child.unicode];
                    if (typeof arabicGlyph === 'undefined') {
                        this.arabicGlyphs[child.unicode] = {
                            [child.arabicForm]: child
                        };
                    } else {
                        arabicGlyph[child.arabicForm] = child;
                    }
                } else {
                    this.glyphs[child.unicode] = child;
                }
            }
        }
    }
}

class TRefElement extends TextElement {
    getText() {
        const element = this.getHrefAttribute().getDefinition();
        if (element) {
            const firstChild = element.children[0];
            if (firstChild) {
                return firstChild.getText();
            }
        }
        return '';
    }
    constructor(...args){
        super(...args);
        this.type = 'tref';
    }
}

class AElement extends TextElement {
    getText() {
        return this.text;
    }
    renderChildren(ctx) {
        if (this.hasText) {
            // render as text element
            super.renderChildren(ctx);
            const { document , x , y  } = this;
            const { mouse  } = document.screen;
            const fontSize = new Property(document, 'fontSize', Font.parse(document.ctx.font).fontSize);
            // Do not calc bounding box if mouse is not working.
            if (mouse.isWorking()) {
                mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels('y'), x + this.measureText(ctx), y));
            }
        } else if (this.children.length > 0) {
            // render as temporary group
            const g = new GElement(this.document);
            g.children = this.children;
            g.parent = this;
            g.render(ctx);
        }
    }
    onClick() {
        const { window  } = this.document;
        if (window) {
            window.open(this.getHrefAttribute().getString());
        }
    }
    onMouseMove() {
        const ctx = this.document.ctx;
        ctx.canvas.style.cursor = 'pointer';
    }
    constructor(document, node1, captureTextNodes){
        super(document, node1, captureTextNodes);
        this.type = 'a';
        const { childNodes  } = node1;
        const firstChild = childNodes[0];
        const hasText = childNodes.length > 0 && Array.from(childNodes).every((node)=>node.nodeType === 3
        );
        this.hasText = hasText;
        this.text = hasText ? this.getTextFromNode(firstChild) : '';
    }
}

class TextPathElement extends TextElement {
    getText() {
        return this.text;
    }
    path(ctx) {
        const { dataArray  } = this;
        if (ctx) {
            ctx.beginPath();
        }
        dataArray.forEach((param)=>{
            let { type , points  } = param;
            switch(type){
                case PathParser.LINE_TO:
                    if (ctx) {
                        ctx.lineTo(points[0], points[1]);
                    }
                    break;
                case PathParser.MOVE_TO:
                    if (ctx) {
                        ctx.moveTo(points[0], points[1]);
                    }
                    break;
                case PathParser.CURVE_TO:
                    if (ctx) {
                        ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
                    }
                    break;
                case PathParser.QUAD_TO:
                    if (ctx) {
                        ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
                    }
                    break;
                case PathParser.ARC:
                    {
                        const [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;
                        const r = rx > ry ? rx : ry;
                        const scaleX = rx > ry ? 1 : rx / ry;
                        const scaleY = rx > ry ? ry / rx : 1;
                        if (ctx) {
                            ctx.translate(cx, cy);
                            ctx.rotate(psi);
                            ctx.scale(scaleX, scaleY);
                            ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));
                            ctx.scale(1 / scaleX, 1 / scaleY);
                            ctx.rotate(-psi);
                            ctx.translate(-cx, -cy);
                        }
                        break;
                    }
                case PathParser.CLOSE_PATH:
                    if (ctx) {
                        ctx.closePath();
                    }
                    break;
            }
        });
    }
    renderChildren(ctx) {
        this.setTextData(ctx);
        ctx.save();
        const textDecoration = this.parent.getStyle('text-decoration').getString();
        const fontSize = this.getFontSize();
        const { glyphInfo  } = this;
        const fill = ctx.fillStyle;
        if (textDecoration === 'underline') {
            ctx.beginPath();
        }
        glyphInfo.forEach((glyph, i)=>{
            const { p0 , p1 , rotation , text: partialText  } = glyph;
            ctx.save();
            ctx.translate(p0.x, p0.y);
            ctx.rotate(rotation);
            if (ctx.fillStyle) {
                ctx.fillText(partialText, 0, 0);
            }
            if (ctx.strokeStyle) {
                ctx.strokeText(partialText, 0, 0);
            }
            ctx.restore();
            if (textDecoration === 'underline') {
                if (i === 0) {
                    ctx.moveTo(p0.x, p0.y + fontSize / 8);
                }
                ctx.lineTo(p1.x, p1.y + fontSize / 5);
            }
        // // To assist with debugging visually, uncomment following
        //
        // ctx.beginPath();
        // if (i % 2)
        //   ctx.strokeStyle = 'red';
        // else
        //   ctx.strokeStyle = 'green';
        // ctx.moveTo(p0.x, p0.y);
        // ctx.lineTo(p1.x, p1.y);
        // ctx.stroke();
        // ctx.closePath();
        });
        if (textDecoration === 'underline') {
            ctx.lineWidth = fontSize / 20;
            ctx.strokeStyle = fill;
            ctx.stroke();
            ctx.closePath();
        }
        ctx.restore();
    }
    getLetterSpacingAt() {
        let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        return this.letterSpacingCache[idx] || 0;
    }
    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {
        let offset = inputOffset;
        let glyphWidth = this.measureText(ctx, c);
        if (c === ' ' && anchor === 'justify' && textFullWidth < fullPathWidth) {
            glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
        }
        if (charI > -1) {
            offset += this.getLetterSpacingAt(charI);
        }
        const splineStep = this.textHeight / 20;
        const p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
        const p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
        const segment = {
            p0,
            p1
        };
        const rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;
        if (dy) {
            const dyX = Math.cos(Math.PI / 2 + rotation) * dy;
            const dyY = Math.cos(-rotation) * dy;
            segment.p0 = {
                ...p0,
                x: p0.x + dyX,
                y: p0.y + dyY
            };
            segment.p1 = {
                ...p1,
                x: p1.x + dyX,
                y: p1.y + dyY
            };
        }
        offset += glyphWidth;
        return {
            offset,
            segment,
            rotation
        };
    }
    measureText(ctx, text) {
        const { measuresCache  } = this;
        const targetText = text || this.getText();
        if (measuresCache.has(targetText)) {
            return measuresCache.get(targetText);
        }
        const measure = this.measureTargetText(ctx, targetText);
        measuresCache.set(targetText, measure);
        return measure;
    }
    // This method supposes what all custom fonts already loaded.
    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
    // You need to call this method manually to update glyphs cache.
    setTextData(ctx) {
        if (this.glyphInfo) {
            return;
        }
        const renderText = this.getText();
        const chars = renderText.split('');
        const spacesNumber = renderText.split(' ').length - 1;
        const dx = this.parent.getAttribute('dx').split().map((_)=>_.getPixels('x')
        );
        const dy = this.parent.getAttribute('dy').getPixels('y');
        const anchor = this.parent.getStyle('text-anchor').getString('start');
        const thisSpacing = this.getStyle('letter-spacing');
        const parentSpacing = this.parent.getStyle('letter-spacing');
        let letterSpacing = 0;
        if (!thisSpacing.hasValue() || thisSpacing.getValue() === 'inherit') {
            letterSpacing = parentSpacing.getPixels();
        } else if (thisSpacing.hasValue()) {
            if (thisSpacing.getValue() !== 'initial' && thisSpacing.getValue() !== 'unset') {
                letterSpacing = thisSpacing.getPixels();
            }
        }
        // fill letter-spacing cache
        const letterSpacingCache = [];
        const textLen = renderText.length;
        this.letterSpacingCache = letterSpacingCache;
        for(let i1 = 0; i1 < textLen; i1++){
            letterSpacingCache.push(typeof dx[i1] !== 'undefined' ? dx[i1] : letterSpacing);
        }
        const dxSum = letterSpacingCache.reduce((acc, cur, i)=>i === 0 ? 0 : acc + cur || 0
        , 0);
        const textWidth = this.measureText(ctx);
        const textFullWidth = Math.max(textWidth + dxSum, 0);
        this.textWidth = textWidth;
        this.textHeight = this.getFontSize();
        this.glyphInfo = [];
        const fullPathWidth = this.getPathLength();
        const startOffset = this.getStyle('startOffset').getNumber(0) * fullPathWidth;
        let offset = 0;
        if (anchor === 'middle' || anchor === 'center') {
            offset = -textFullWidth / 2;
        }
        if (anchor === 'end' || anchor === 'right') {
            offset = -textFullWidth;
        }
        offset += startOffset;
        chars.forEach((char, i)=>{
            // Find such segment what distance between p0 and p1 is approx. width of glyph
            const { offset: nextOffset , segment , rotation  } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);
            offset = nextOffset;
            if (!segment.p0 || !segment.p1) {
                return;
            }
            // const width = this.getLineLength(
            //   segment.p0.x,
            //   segment.p0.y,
            //   segment.p1.x,
            //   segment.p1.y
            // );
            // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
            // Can foresee having a rough pair table built in that the developer can override as needed.
            // Or use "dx" attribute of the <text> node as a naive replacement
            // const kern = 0;
            // placeholder for future implementation
            // const midpoint = this.getPointOnLine(
            //   kern + width / 2.0,
            //   segment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y
            // );
            this.glyphInfo.push({
                // transposeX: midpoint.x,
                // transposeY: midpoint.y,
                text: chars[i],
                p0: segment.p0,
                p1: segment.p1,
                rotation
            });
        });
    }
    parsePathData(path) {
        this.pathLength = -1 // reset path length
        ;
        if (!path) {
            return [];
        }
        const pathCommands = [];
        const { pathParser  } = path;
        pathParser.reset();
        // convert l, H, h, V, and v to L
        while(!pathParser.isEnd()){
            const { current  } = pathParser;
            const startX = current ? current.x : 0;
            const startY = current ? current.y : 0;
            const command = pathParser.next();
            let nextCommandType = command.type;
            let points = [];
            switch(command.type){
                case PathParser.MOVE_TO:
                    this.pathM(pathParser, points);
                    break;
                case PathParser.LINE_TO:
                    nextCommandType = this.pathL(pathParser, points);
                    break;
                case PathParser.HORIZ_LINE_TO:
                    nextCommandType = this.pathH(pathParser, points);
                    break;
                case PathParser.VERT_LINE_TO:
                    nextCommandType = this.pathV(pathParser, points);
                    break;
                case PathParser.CURVE_TO:
                    this.pathC(pathParser, points);
                    break;
                case PathParser.SMOOTH_CURVE_TO:
                    nextCommandType = this.pathS(pathParser, points);
                    break;
                case PathParser.QUAD_TO:
                    this.pathQ(pathParser, points);
                    break;
                case PathParser.SMOOTH_QUAD_TO:
                    nextCommandType = this.pathT(pathParser, points);
                    break;
                case PathParser.ARC:
                    points = this.pathA(pathParser);
                    break;
                case PathParser.CLOSE_PATH:
                    PathElement.pathZ(pathParser);
                    break;
            }
            if (command.type !== PathParser.CLOSE_PATH) {
                pathCommands.push({
                    type: nextCommandType,
                    points,
                    start: {
                        x: startX,
                        y: startY
                    },
                    pathLength: this.calcLength(startX, startY, nextCommandType, points)
                });
            } else {
                pathCommands.push({
                    type: PathParser.CLOSE_PATH,
                    points: [],
                    pathLength: 0
                });
            }
        }
        return pathCommands;
    }
    pathM(pathParser, points) {
        const { x , y  } = PathElement.pathM(pathParser).point;
        points.push(x, y);
    }
    pathL(pathParser, points) {
        const { x , y  } = PathElement.pathL(pathParser).point;
        points.push(x, y);
        return PathParser.LINE_TO;
    }
    pathH(pathParser, points) {
        const { x , y  } = PathElement.pathH(pathParser).point;
        points.push(x, y);
        return PathParser.LINE_TO;
    }
    pathV(pathParser, points) {
        const { x , y  } = PathElement.pathV(pathParser).point;
        points.push(x, y);
        return PathParser.LINE_TO;
    }
    pathC(pathParser, points) {
        const { point , controlPoint , currentPoint  } = PathElement.pathC(pathParser);
        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
    pathS(pathParser, points) {
        const { point , controlPoint , currentPoint  } = PathElement.pathS(pathParser);
        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        return PathParser.CURVE_TO;
    }
    pathQ(pathParser, points) {
        const { controlPoint , currentPoint  } = PathElement.pathQ(pathParser);
        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
    pathT(pathParser, points) {
        const { controlPoint , currentPoint  } = PathElement.pathT(pathParser);
        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        return PathParser.QUAD_TO;
    }
    pathA(pathParser) {
        let { rX , rY , sweepFlag , xAxisRotation , centp , a1 , ad  } = PathElement.pathA(pathParser);
        if (sweepFlag === 0 && ad > 0) {
            ad -= 2 * Math.PI;
        }
        if (sweepFlag === 1 && ad < 0) {
            ad += 2 * Math.PI;
        }
        return [
            centp.x,
            centp.y,
            rX,
            rY,
            a1,
            ad,
            xAxisRotation,
            sweepFlag
        ];
    }
    calcLength(x, y, commandType, points) {
        let len = 0;
        let p1 = null;
        let p2 = null;
        let t = 0;
        switch(commandType){
            case PathParser.LINE_TO:
                return this.getLineLength(x, y, points[0], points[1]);
            case PathParser.CURVE_TO:
                // Approximates by breaking curve into 100 line segments
                len = 0;
                p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                for(t = 0.01; t <= 1; t += 0.01){
                    p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
                return len;
            case PathParser.QUAD_TO:
                // Approximates by breaking curve into 100 line segments
                len = 0;
                p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
                for(t = 0.01; t <= 1; t += 0.01){
                    p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
                return len;
            case PathParser.ARC:
                {
                    // Approximates by breaking curve into line segments
                    len = 0;
                    const start = points[4];
                    // 4 = theta
                    const dTheta = points[5];
                    // 5 = dTheta
                    const end = points[4] + dTheta;
                    let inc = Math.PI / 180;
                    // 1 degree resolution
                    if (Math.abs(start - end) < inc) {
                        inc = Math.abs(start - end);
                    }
                    // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi
                    p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
                    if (dTheta < 0) {
                        for(t = start - inc; t > end; t -= inc){
                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                            p1 = p2;
                        }
                    } else {
                        for(t = start + inc; t < end; t += inc){
                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                            p1 = p2;
                        }
                    }
                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    return len;
                }
        }
        return 0;
    }
    getPointOnLine(dist, p1x, p1y, p2x, p2y) {
        let fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x, fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;
        const m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
        let run = Math.sqrt(dist * dist / (1 + m * m));
        if (p2x < p1x) {
            run *= -1;
        }
        let rise = m * run;
        let pt = null;
        if (p2x === p1x) {
            pt = {
                x: fromX,
                y: fromY + rise
            };
        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {
            pt = {
                x: fromX + run,
                y: fromY + rise
            };
        } else {
            let ix = 0;
            let iy = 0;
            const len = this.getLineLength(p1x, p1y, p2x, p2y);
            if (len < PSEUDO_ZERO) {
                return null;
            }
            let u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
            u /= len * len;
            ix = p1x + u * (p2x - p1x);
            iy = p1y + u * (p2y - p1y);
            const pRise = this.getLineLength(fromX, fromY, ix, iy);
            const pRun = Math.sqrt(dist * dist - pRise * pRise);
            run = Math.sqrt(pRun * pRun / (1 + m * m));
            if (p2x < p1x) {
                run *= -1;
            }
            rise = m * run;
            pt = {
                x: ix + run,
                y: iy + rise
            };
        }
        return pt;
    }
    getPointOnPath(distance) {
        const fullLen = this.getPathLength();
        let cumulativePathLength = 0;
        let p = null;
        if (distance < -0.00005 || distance - 0.00005 > fullLen) {
            return null;
        }
        const { dataArray  } = this;
        for (const command of dataArray){
            if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {
                cumulativePathLength += command.pathLength;
                continue;
            }
            const delta = distance - cumulativePathLength;
            let currentT = 0;
            switch(command.type){
                case PathParser.LINE_TO:
                    p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
                    break;
                case PathParser.ARC:
                    {
                        const start = command.points[4];
                        // 4 = theta
                        const dTheta = command.points[5];
                        // 5 = dTheta
                        const end = command.points[4] + dTheta;
                        currentT = start + delta / command.pathLength * dTheta;
                        if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                            break;
                        }
                        p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
                        break;
                    }
                case PathParser.CURVE_TO:
                    currentT = delta / command.pathLength;
                    if (currentT > 1) {
                        currentT = 1;
                    }
                    p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
                    break;
                case PathParser.QUAD_TO:
                    currentT = delta / command.pathLength;
                    if (currentT > 1) {
                        currentT = 1;
                    }
                    p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
                    break;
            }
            if (p) {
                return p;
            }
            break;
        }
        return null;
    }
    getLineLength(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    getPathLength() {
        if (this.pathLength === -1) {
            this.pathLength = this.dataArray.reduce((length, command)=>command.pathLength > 0 ? length + command.pathLength : length
            , 0);
        }
        return this.pathLength;
    }
    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
        const x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
        const y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
        return {
            x,
            y
        };
    }
    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
        const x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
        const y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
        return {
            x,
            y
        };
    }
    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
        const cosPsi = Math.cos(psi);
        const sinPsi = Math.sin(psi);
        const pt = {
            x: rx * Math.cos(theta),
            y: ry * Math.sin(theta)
        };
        return {
            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
            y: cy + (pt.x * sinPsi + pt.y * cosPsi)
        };
    }
    // TODO need some optimisations. possibly build cache only for curved segments?
    buildEquidistantCache(inputStep, inputPrecision) {
        const fullLen = this.getPathLength();
        const precision = inputPrecision || 0.25 // accuracy vs performance
        ;
        const step = inputStep || fullLen / 100;
        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
            // Prepare cache
            this.equidistantCache = {
                step,
                precision,
                points: []
            };
            // Calculate points
            let s = 0;
            for(let l = 0; l <= fullLen; l += precision){
                const p0 = this.getPointOnPath(l);
                const p1 = this.getPointOnPath(l + precision);
                if (!p0 || !p1) {
                    continue;
                }
                s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);
                if (s >= step) {
                    this.equidistantCache.points.push({
                        x: p0.x,
                        y: p0.y,
                        distance: l
                    });
                    s -= step;
                }
            }
        }
    }
    getEquidistantPointOnPath(targetDistance, step, precision) {
        this.buildEquidistantCache(step, precision);
        if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {
            return null;
        }
        const idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
        return this.equidistantCache.points[idx] || null;
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'textPath';
        this.textWidth = 0;
        this.textHeight = 0;
        this.pathLength = -1;
        this.glyphInfo = null;
        this.letterSpacingCache = [];
        this.measuresCache = new Map([
            [
                '',
                0
            ]
        ]);
        const pathElement = this.getHrefAttribute().getDefinition();
        this.text = this.getTextFromNode();
        this.dataArray = this.parsePathData(pathElement);
    }
}

// groups: 1: mime-type (+ charset), 2: mime-type (w/o charset), 3: charset, 4: base64?, 5: body
const dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
class ImageElement extends RenderedElement {
    async loadImage(href) {
        try {
            const image = await this.document.createImage(href);
            this.image = image;
        } catch (err) {
            console.error("Error while loading image \"".concat(href, "\":"), err);
        }
        this.loaded = true;
    }
    async loadSvg(href) {
        const match = dataUriRegex.exec(href);
        if (match) {
            const data = match[5];
            if (data) {
                if (match[4] === 'base64') {
                    this.image = atob(data);
                } else {
                    this.image = decodeURIComponent(data);
                }
            }
        } else {
            try {
                const response = await this.document.fetch(href);
                const svg = await response.text();
                this.image = svg;
            } catch (err) {
                console.error("Error while loading image \"".concat(href, "\":"), err);
            }
        }
        this.loaded = true;
    }
    renderChildren(ctx) {
        const { document , image , loaded  } = this;
        const x = this.getAttribute('x').getPixels('x');
        const y = this.getAttribute('y').getPixels('y');
        const width = this.getStyle('width').getPixels('x');
        const height = this.getStyle('height').getPixels('y');
        if (!loaded || !image || !width || !height) {
            return;
        }
        ctx.save();
        ctx.translate(x, y);
        if (typeof image === 'string') {
            const subDocument = document.canvg.forkString(ctx, image, {
                ignoreMouse: true,
                ignoreAnimation: true,
                ignoreDimensions: true,
                ignoreClear: true,
                offsetX: 0,
                offsetY: 0,
                scaleWidth: width,
                scaleHeight: height
            });
            const { documentElement  } = subDocument.document;
            if (documentElement) {
                documentElement.parent = this;
            }
            void subDocument.render();
        } else {
            document.setViewBox({
                ctx,
                aspectRatio: this.getAttribute('preserveAspectRatio').getString(),
                width,
                desiredWidth: image.width,
                height,
                desiredHeight: image.height
            });
            if (this.loaded) {
                if (!('complete' in image) || image.complete) {
                    ctx.drawImage(image, 0, 0);
                }
            }
        }
        ctx.restore();
    }
    getBoundingBox() {
        const x = this.getAttribute('x').getPixels('x');
        const y = this.getAttribute('y').getPixels('y');
        const width = this.getStyle('width').getPixels('x');
        const height = this.getStyle('height').getPixels('y');
        return new BoundingBox(x, y, x + width, y + height);
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'image';
        this.loaded = false;
        const href = this.getHrefAttribute().getString();
        if (!href) {
            return;
        }
        const isSvg = href.endsWith('.svg') || /^\s*data:image\/svg\+xml/i.test(href);
        document.images.push(this);
        if (!isSvg) {
            void this.loadImage(href);
        } else {
            void this.loadSvg(href);
        }
    }
}

class SymbolElement extends RenderedElement {
    render(_) {
    // NO RENDER
    }
    constructor(...args){
        super(...args);
        this.type = 'symbol';
    }
}

class SVGFontLoader {
    async load(fontFamily, url) {
        try {
            const { document  } = this;
            const svgDocument = await document.canvg.parser.load(url);
            const fonts = svgDocument.getElementsByTagName('font');
            Array.from(fonts).forEach((fontNode)=>{
                const font = document.createElement(fontNode);
                document.definitions[fontFamily] = font;
            });
        } catch (err) {
            console.error("Error while loading font \"".concat(url, "\":"), err);
        }
        this.loaded = true;
    }
    constructor(document){
        this.document = document;
        this.loaded = false;
        document.fonts.push(this);
    }
}

class StyleElement extends Element {
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'style';
        const css = compressSpaces(Array.from(node.childNodes)// NEED TEST
        .map((_)=>_.textContent
        ).join('').replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, '') // remove comments
        .replace(/@import.*;/g, '') // remove imports
        );
        const cssDefs = css.split('}');
        cssDefs.forEach((_1)=>{
            const def = _1.trim();
            if (!def) {
                return;
            }
            const cssParts = def.split('{');
            const cssClasses = cssParts[0].split(',');
            const cssProps = cssParts[1].split(';');
            cssClasses.forEach((_)=>{
                const cssClass = _.trim();
                if (!cssClass) {
                    return;
                }
                const props = document.styles[cssClass] || {};
                cssProps.forEach((cssProp)=>{
                    const prop = cssProp.indexOf(':');
                    const name = cssProp.substr(0, prop).trim();
                    const value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
                    if (name && value) {
                        props[name] = new Property(document, name, value);
                    }
                });
                document.styles[cssClass] = props;
                document.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
                if (cssClass === '@font-face') {
                    const fontFamily = props['font-family'].getString().replace(/"|'/g, '');
                    const srcs = props.src.getString().split(',');
                    srcs.forEach((src)=>{
                        if (src.indexOf('format("svg")') > 0) {
                            const url = parseExternalUrl(src);
                            if (url) {
                                void new SVGFontLoader(document).load(fontFamily, url);
                            }
                        }
                    });
                }
            });
        });
    }
}
StyleElement.parseExternalUrl = parseExternalUrl;

class UseElement extends RenderedElement {
    setContext(ctx) {
        super.setContext(ctx);
        const xAttr = this.getAttribute('x');
        const yAttr = this.getAttribute('y');
        if (xAttr.hasValue()) {
            ctx.translate(xAttr.getPixels('x'), 0);
        }
        if (yAttr.hasValue()) {
            ctx.translate(0, yAttr.getPixels('y'));
        }
    }
    path(ctx) {
        const { element  } = this;
        if (element) {
            element.path(ctx);
        }
    }
    renderChildren(ctx) {
        const { document , element  } = this;
        if (element) {
            let tempSvg = element;
            if (element.type === 'symbol') {
                // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
                tempSvg = new SVGElement(document);
                tempSvg.attributes.viewBox = new Property(document, 'viewBox', element.getAttribute('viewBox').getString());
                tempSvg.attributes.preserveAspectRatio = new Property(document, 'preserveAspectRatio', element.getAttribute('preserveAspectRatio').getString());
                tempSvg.attributes.overflow = new Property(document, 'overflow', element.getAttribute('overflow').getString());
                tempSvg.children = element.children;
                // element is still the parent of the children
                element.styles.opacity = new Property(document, 'opacity', this.calculateOpacity());
            }
            if (tempSvg.type === 'svg') {
                const widthStyle = this.getStyle('width', false, true);
                const heightStyle = this.getStyle('height', false, true);
                // if symbol or svg, inherit width/height from me
                if (widthStyle.hasValue()) {
                    tempSvg.attributes.width = new Property(document, 'width', widthStyle.getString());
                }
                if (heightStyle.hasValue()) {
                    tempSvg.attributes.height = new Property(document, 'height', heightStyle.getString());
                }
            }
            const oldParent = tempSvg.parent;
            tempSvg.parent = this;
            tempSvg.render(ctx);
            tempSvg.parent = oldParent;
        }
    }
    getBoundingBox(ctx) {
        const { element  } = this;
        if (element) {
            return element.getBoundingBox(ctx);
        }
        return null;
    }
    elementTransform() {
        const { document , element  } = this;
        if (!element) {
            return null;
        }
        return Transform.fromElement(document, element);
    }
    get element() {
        if (!this.cachedElement) {
            this.cachedElement = this.getHrefAttribute().getDefinition();
        }
        return this.cachedElement;
    }
    constructor(...args){
        super(...args);
        this.type = 'use';
    }
}

function imGet(img, x, y, width, _height, rgba) {
    return img[y * width * 4 + x * 4 + rgba];
}
function imSet(img, x, y, width, _height, rgba, val) {
    img[y * width * 4 + x * 4 + rgba] = val;
}
function m(matrix, i, v) {
    const mi = matrix[i];
    return mi * v;
}
function c(a, m1, m2, m3) {
    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;
}
class FeColorMatrixElement extends Element {
    apply(ctx, _x, _y, width, height) {
        // assuming x==0 && y==0 for now
        const { includeOpacity , matrix  } = this;
        const srcData = ctx.getImageData(0, 0, width, height);
        for(let y = 0; y < height; y++){
            for(let x = 0; x < width; x++){
                const r = imGet(srcData.data, x, y, width, height, 0);
                const g = imGet(srcData.data, x, y, width, height, 1);
                const b = imGet(srcData.data, x, y, width, height, 2);
                const a = imGet(srcData.data, x, y, width, height, 3);
                let nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);
                let ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);
                let nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);
                let na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);
                if (includeOpacity) {
                    nr = 0;
                    ng = 0;
                    nb = 0;
                    na *= a / 255;
                }
                imSet(srcData.data, x, y, width, height, 0, nr);
                imSet(srcData.data, x, y, width, height, 1, ng);
                imSet(srcData.data, x, y, width, height, 2, nb);
                imSet(srcData.data, x, y, width, height, 3, na);
            }
        }
        ctx.clearRect(0, 0, width, height);
        ctx.putImageData(srcData, 0, 0);
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'feColorMatrix';
        let matrix = toNumbers(this.getAttribute('values').getString());
        switch(this.getAttribute('type').getString('matrix')){
            case 'saturate':
                {
                    const s = matrix[0];
                    /* eslint-disable array-element-newline */ matrix = [
                        0.213 + 0.787 * s,
                        0.715 - 0.715 * s,
                        0.072 - 0.072 * s,
                        0,
                        0,
                        0.213 - 0.213 * s,
                        0.715 + 0.285 * s,
                        0.072 - 0.072 * s,
                        0,
                        0,
                        0.213 - 0.213 * s,
                        0.715 - 0.715 * s,
                        0.072 + 0.928 * s,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ];
                    break;
                }
            case 'hueRotate':
                {
                    const a = matrix[0] * Math.PI / 180;
                    /* eslint-disable array-element-newline */ matrix = [
                        c(a, 0.213, 0.787, -0.213),
                        c(a, 0.715, -0.715, -0.715),
                        c(a, 0.072, -0.072, 0.928),
                        0,
                        0,
                        c(a, 0.213, -0.213, 0.143),
                        c(a, 0.715, 0.285, 0.14),
                        c(a, 0.072, -0.072, -0.283),
                        0,
                        0,
                        c(a, 0.213, -0.213, -0.787),
                        c(a, 0.715, -0.715, 0.715),
                        c(a, 0.072, 0.928, 0.072),
                        0,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ];
                    break;
                }
            case 'luminanceToAlpha':
                /* eslint-disable array-element-newline */ matrix = [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0.2125,
                    0.7154,
                    0.0721,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ];
                break;
        }
        this.matrix = matrix;
        this.includeOpacity = this.getAttribute('includeOpacity').hasValue();
    }
}

class MaskElement extends Element {
    apply(ctx, element) {
        const { document  } = this;
        // render as temp svg
        let x = this.getAttribute('x').getPixels('x');
        let y = this.getAttribute('y').getPixels('y');
        let width = this.getStyle('width').getPixels('x');
        let height = this.getStyle('height').getPixels('y');
        if (!width && !height) {
            const boundingBox = new BoundingBox();
            this.children.forEach((child)=>{
                boundingBox.addBoundingBox(child.getBoundingBox(ctx));
            });
            x = Math.floor(boundingBox.x1);
            y = Math.floor(boundingBox.y1);
            width = Math.floor(boundingBox.width);
            height = Math.floor(boundingBox.height);
        }
        const ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
        const maskCanvas = document.createCanvas(x + width, y + height);
        const maskCtx = maskCanvas.getContext('2d');
        document.screen.setDefaults(maskCtx);
        this.renderChildren(maskCtx);
        // convert mask to alpha with a fake node
        // TODO: refactor out apply from feColorMatrix
        new FeColorMatrixElement(document, {
            nodeType: 1,
            childNodes: [],
            attributes: [
                {
                    nodeName: 'type',
                    value: 'luminanceToAlpha'
                },
                {
                    nodeName: 'includeOpacity',
                    value: 'true'
                }
            ]
        }).apply(maskCtx, 0, 0, x + width, y + height);
        const tmpCanvas = document.createCanvas(x + width, y + height);
        const tmpCtx = tmpCanvas.getContext('2d');
        document.screen.setDefaults(tmpCtx);
        element.render(tmpCtx);
        tmpCtx.globalCompositeOperation = 'destination-in';
        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, 'no-repeat');
        tmpCtx.fillRect(0, 0, x + width, y + height);
        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, 'no-repeat');
        ctx.fillRect(0, 0, x + width, y + height);
        // reassign mask
        this.restoreStyles(element, ignoredStyles);
    }
    render(_) {
    // NO RENDER
    }
    constructor(...args){
        super(...args);
        this.type = 'mask';
    }
}
MaskElement.ignoreStyles = [
    'mask',
    'transform',
    'clip-path'
];

const noop = ()=>{
// NOOP
};
class ClipPathElement extends Element {
    apply(ctx) {
        const { document  } = this;
        const contextProto = Reflect.getPrototypeOf(ctx);
        const { beginPath , closePath  } = ctx;
        if (contextProto) {
            contextProto.beginPath = noop;
            contextProto.closePath = noop;
        }
        Reflect.apply(beginPath, ctx, []);
        this.children.forEach((child)=>{
            if (!('path' in child)) {
                return;
            }
            let transform = 'elementTransform' in child ? child.elementTransform() : null // handle <use />
            ;
            if (!transform) {
                transform = Transform.fromElement(document, child);
            }
            if (transform) {
                transform.apply(ctx);
            }
            child.path(ctx);
            if (contextProto) {
                contextProto.closePath = closePath;
            }
            if (transform) {
                transform.unapply(ctx);
            }
        });
        Reflect.apply(closePath, ctx, []);
        ctx.clip();
        if (contextProto) {
            contextProto.beginPath = beginPath;
            contextProto.closePath = closePath;
        }
    }
    render(_) {
    // NO RENDER
    }
    constructor(...args){
        super(...args);
        this.type = 'clipPath';
    }
}

class FilterElement extends Element {
    apply(ctx, element) {
        // render as temp svg
        const { document , children  } = this;
        const boundingBox = 'getBoundingBox' in element ? element.getBoundingBox(ctx) : null;
        if (!boundingBox) {
            return;
        }
        let px = 0;
        let py = 0;
        children.forEach((child)=>{
            const efd = child.extraFilterDistance || 0;
            px = Math.max(px, efd);
            py = Math.max(py, efd);
        });
        const width = Math.floor(boundingBox.width);
        const height = Math.floor(boundingBox.height);
        const tmpCanvasWidth = width + 2 * px;
        const tmpCanvasHeight = height + 2 * py;
        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
            return;
        }
        const x = Math.floor(boundingBox.x);
        const y = Math.floor(boundingBox.y);
        const ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
        const tmpCanvas = document.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
        const tmpCtx = tmpCanvas.getContext('2d');
        document.screen.setDefaults(tmpCtx);
        tmpCtx.translate(-x + px, -y + py);
        element.render(tmpCtx);
        // apply filters
        children.forEach((child)=>{
            if (typeof child.apply === 'function') {
                child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
            }
        });
        // render on me
        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);
        this.restoreStyles(element, ignoredStyles);
    }
    render(_) {
    // NO RENDER
    }
    constructor(...args){
        super(...args);
        this.type = 'filter';
    }
}
FilterElement.ignoreStyles = [
    'filter',
    'transform',
    'clip-path'
];

class FeDropShadowElement extends Element {
    apply(_, _x, _y, _width, _height) {
    // TODO: implement
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'feDropShadow';
        this.addStylesFromStyleDefinition();
    }
}

class FeMorphologyElement extends Element {
    apply(_, _x, _y, _width, _height) {
    // TODO: implement
    }
    constructor(...args){
        super(...args);
        this.type = 'feMorphology';
    }
}

class FeCompositeElement extends Element {
    apply(_, _x, _y, _width, _height) {
    // TODO: implement
    }
    constructor(...args){
        super(...args);
        this.type = 'feComposite';
    }
}

class FeGaussianBlurElement extends Element {
    apply(ctx, x, y, width, height) {
        const { document , blurRadius  } = this;
        const body = document.window ? document.window.document.body : null;
        const canvas = ctx.canvas;
        // StackBlur requires canvas be on document
        canvas.id = document.getUniqueId();
        if (body) {
            canvas.style.display = 'none';
            body.appendChild(canvas);
        }
        (0,stackblur_canvas__WEBPACK_IMPORTED_MODULE_3__.canvasRGBA)(canvas, x, y, width, height, blurRadius);
        if (body) {
            body.removeChild(canvas);
        }
    }
    constructor(document, node, captureTextNodes){
        super(document, node, captureTextNodes);
        this.type = 'feGaussianBlur';
        this.blurRadius = Math.floor(this.getAttribute('stdDeviation').getNumber());
        this.extraFilterDistance = this.blurRadius;
    }
}

class TitleElement extends Element {
    constructor(...args){
        super(...args);
        this.type = 'title';
    }
}

class DescElement extends Element {
    constructor(...args){
        super(...args);
        this.type = 'desc';
    }
}

const elements = {
    'svg': SVGElement,
    'rect': RectElement,
    'circle': CircleElement,
    'ellipse': EllipseElement,
    'line': LineElement,
    'polyline': PolylineElement,
    'polygon': PolygonElement,
    'path': PathElement,
    'pattern': PatternElement,
    'marker': MarkerElement,
    'defs': DefsElement,
    'linearGradient': LinearGradientElement,
    'radialGradient': RadialGradientElement,
    'stop': StopElement,
    'animate': AnimateElement,
    'animateColor': AnimateColorElement,
    'animateTransform': AnimateTransformElement,
    'font': FontElement,
    'font-face': FontFaceElement,
    'missing-glyph': MissingGlyphElement,
    'glyph': GlyphElement,
    'text': TextElement,
    'tspan': TSpanElement,
    'tref': TRefElement,
    'a': AElement,
    'textPath': TextPathElement,
    'image': ImageElement,
    'g': GElement,
    'symbol': SymbolElement,
    'style': StyleElement,
    'use': UseElement,
    'mask': MaskElement,
    'clipPath': ClipPathElement,
    'filter': FilterElement,
    'feDropShadow': FeDropShadowElement,
    'feMorphology': FeMorphologyElement,
    'feComposite': FeCompositeElement,
    'feColorMatrix': FeColorMatrixElement,
    'feGaussianBlur': FeGaussianBlurElement,
    'title': TitleElement,
    'desc': DescElement
};

function createCanvas(width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    return canvas;
}
async function createImage(src) {
    let anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const image = document.createElement('img');
    if (anonymousCrossOrigin) {
        image.crossOrigin = 'Anonymous';
    }
    return new Promise((resolve, reject)=>{
        image.onload = ()=>{
            resolve(image);
        };
        image.onerror = (_event, _source, _lineno, _colno, error)=>{
            reject(error);
        };
        image.src = src;
    });
}
const DEFAULT_EM_SIZE = 12;
class Document {
    bindCreateImage(createImage1, anonymousCrossOrigin) {
        if (typeof anonymousCrossOrigin === 'boolean') {
            return (source, forceAnonymousCrossOrigin)=>createImage1(source, typeof forceAnonymousCrossOrigin === 'boolean' ? forceAnonymousCrossOrigin : anonymousCrossOrigin)
            ;
        }
        return createImage1;
    }
    get window() {
        return this.screen.window;
    }
    get fetch() {
        return this.screen.fetch;
    }
    get ctx() {
        return this.screen.ctx;
    }
    get emSize() {
        const { emSizeStack  } = this;
        return emSizeStack[emSizeStack.length - 1] || DEFAULT_EM_SIZE;
    }
    set emSize(value) {
        const { emSizeStack  } = this;
        emSizeStack.push(value);
    }
    popEmSize() {
        const { emSizeStack  } = this;
        emSizeStack.pop();
    }
    getUniqueId() {
        return "canvg".concat(++this.uniqueId);
    }
    isImagesLoaded() {
        return this.images.every((_)=>_.loaded
        );
    }
    isFontsLoaded() {
        return this.fonts.every((_)=>_.loaded
        );
    }
    createDocumentElement(document) {
        const documentElement = this.createElement(document.documentElement);
        documentElement.root = true;
        documentElement.addStylesFromStyleDefinition();
        this.documentElement = documentElement;
        return documentElement;
    }
    createElement(node) {
        const elementType = node.nodeName.replace(/^[^:]+:/, '');
        const ElementType = Document.elementTypes[elementType];
        if (ElementType) {
            return new ElementType(this, node);
        }
        return new UnknownElement(this, node);
    }
    createTextNode(node) {
        return new TextNode(this, node);
    }
    setViewBox(config) {
        this.screen.setViewBox({
            document: this,
            ...config
        });
    }
    constructor(canvg, { rootEmSize =DEFAULT_EM_SIZE , emSize =DEFAULT_EM_SIZE , createCanvas: createCanvas1 = Document.createCanvas , createImage: createImage2 = Document.createImage , anonymousCrossOrigin  } = {}){
        this.canvg = canvg;
        this.definitions = {};
        this.styles = {};
        this.stylesSpecificity = {};
        this.images = [];
        this.fonts = [];
        this.emSizeStack = [];
        this.uniqueId = 0;
        this.screen = canvg.screen;
        this.rootEmSize = rootEmSize;
        this.emSize = emSize;
        this.createCanvas = createCanvas1;
        this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);
        this.screen.wait(()=>this.isImagesLoaded()
        );
        this.screen.wait(()=>this.isFontsLoaded()
        );
    }
}
Document.createCanvas = createCanvas;
Document.createImage = createImage;
Document.elementTypes = elements;

/**
 * SVG renderer on canvas.
 */ class Canvg {
    /**
   * Create Canvg instance from SVG source string or URL.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */ static async from(ctx, svg) {
        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const parser = new Parser(options);
        const svgDocument = await parser.parse(svg);
        return new Canvg(ctx, svgDocument, options);
    }
    /**
   * Create Canvg instance from SVG source string.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */ static fromString(ctx, svg) {
        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const parser = new Parser(options);
        const svgDocument = parser.parseFromString(svg);
        return new Canvg(ctx, svgDocument, options);
    }
    /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */ fork(ctx, svg) {
        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return Canvg.from(ctx, svg, {
            ...this.options,
            ...options
        });
    }
    /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */ forkString(ctx, svg) {
        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return Canvg.fromString(ctx, svg, {
            ...this.options,
            ...options
        });
    }
    /**
   * Document is ready promise.
   * @returns Ready promise.
   */ ready() {
        return this.screen.ready();
    }
    /**
   * Document is ready value.
   * @returns Is ready or not.
   */ isReady() {
        return this.screen.isReady();
    }
    /**
   * Render only first frame, ignoring animations and mouse.
   * @param options - Rendering options.
   */ async render() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.start({
            enableRedraw: true,
            ignoreAnimation: true,
            ignoreMouse: true,
            ...options
        });
        await this.ready();
        this.stop();
    }
    /**
   * Start rendering.
   * @param options - Render options.
   */ start() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const { documentElement , screen , options: baseOptions  } = this;
        screen.start(documentElement, {
            enableRedraw: true,
            ...baseOptions,
            ...options
        });
    }
    /**
   * Stop rendering.
   */ stop() {
        this.screen.stop();
    }
    /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */ resize(width) {
        let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width, preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.documentElement.resize(width, height, preserveAspectRatio);
    }
    /**
   * Main constructor.
   * @param ctx - Rendering context.
   * @param svg - SVG Document.
   * @param options - Rendering options.
   */ constructor(ctx, svg, options = {}){
        this.parser = new Parser(options);
        this.screen = new Screen(ctx, options);
        this.options = options;
        const document = new Document(this, options);
        const documentElement = document.createDocumentElement(svg);
        this.document = document;
        this.documentElement = documentElement;
    }
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/svg-pathdata/lib/SVGPathData.module.js":
/*!*************************************************************!*\
  !*** ./node_modules/svg-pathdata/lib/SVGPathData.module.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "COMMAND_ARG_COUNTS": () => (/* binding */ N),
/* harmony export */   "SVGPathData": () => (/* binding */ _),
/* harmony export */   "SVGPathDataParser": () => (/* binding */ f),
/* harmony export */   "SVGPathDataTransformer": () => (/* binding */ u),
/* harmony export */   "encodeSVGPath": () => (/* binding */ e)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var t=function(r,e){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(t[e]=r[e])})(r,e)};function r(r,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function i(){this.constructor=r}t(r,e),r.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}function e(t){var r="";Array.isArray(t)||(t=[t]);for(var e=0;e<t.length;e++){var i=t[e];if(i.type===_.CLOSE_PATH)r+="z";else if(i.type===_.HORIZ_LINE_TO)r+=(i.relative?"h":"H")+i.x;else if(i.type===_.VERT_LINE_TO)r+=(i.relative?"v":"V")+i.y;else if(i.type===_.MOVE_TO)r+=(i.relative?"m":"M")+i.x+" "+i.y;else if(i.type===_.LINE_TO)r+=(i.relative?"l":"L")+i.x+" "+i.y;else if(i.type===_.CURVE_TO)r+=(i.relative?"c":"C")+i.x1+" "+i.y1+" "+i.x2+" "+i.y2+" "+i.x+" "+i.y;else if(i.type===_.SMOOTH_CURVE_TO)r+=(i.relative?"s":"S")+i.x2+" "+i.y2+" "+i.x+" "+i.y;else if(i.type===_.QUAD_TO)r+=(i.relative?"q":"Q")+i.x1+" "+i.y1+" "+i.x+" "+i.y;else if(i.type===_.SMOOTH_QUAD_TO)r+=(i.relative?"t":"T")+i.x+" "+i.y;else{if(i.type!==_.ARC)throw new Error('Unexpected command type "'+i.type+'" at index '+e+".");r+=(i.relative?"a":"A")+i.rX+" "+i.rY+" "+i.xRot+" "+ +i.lArcFlag+" "+ +i.sweepFlag+" "+i.x+" "+i.y}}return r}function i(t,r){var e=t[0],i=t[1];return[e*Math.cos(r)-i*Math.sin(r),e*Math.sin(r)+i*Math.cos(r)]}function a(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];for(var e=0;e<t.length;e++)if("number"!=typeof t[e])throw new Error("assertNumbers arguments["+e+"] is not a number. "+typeof t[e]+" == typeof "+t[e]);return!0}var n=Math.PI;function o(t,r,e){t.lArcFlag=0===t.lArcFlag?0:1,t.sweepFlag=0===t.sweepFlag?0:1;var a=t.rX,o=t.rY,s=t.x,u=t.y;a=Math.abs(t.rX),o=Math.abs(t.rY);var h=i([(r-s)/2,(e-u)/2],-t.xRot/180*n),c=h[0],y=h[1],p=Math.pow(c,2)/Math.pow(a,2)+Math.pow(y,2)/Math.pow(o,2);1<p&&(a*=Math.sqrt(p),o*=Math.sqrt(p)),t.rX=a,t.rY=o;var m=Math.pow(a,2)*Math.pow(y,2)+Math.pow(o,2)*Math.pow(c,2),O=(t.lArcFlag!==t.sweepFlag?1:-1)*Math.sqrt(Math.max(0,(Math.pow(a,2)*Math.pow(o,2)-m)/m)),l=a*y/o*O,T=-o*c/a*O,v=i([l,T],t.xRot/180*n);t.cX=v[0]+(r+s)/2,t.cY=v[1]+(e+u)/2,t.phi1=Math.atan2((y-T)/o,(c-l)/a),t.phi2=Math.atan2((-y-T)/o,(-c-l)/a),0===t.sweepFlag&&t.phi2>t.phi1&&(t.phi2-=2*n),1===t.sweepFlag&&t.phi2<t.phi1&&(t.phi2+=2*n),t.phi1*=180/n,t.phi2*=180/n}function s(t,r,e){a(t,r,e);var i=t*t+r*r-e*e;if(0>i)return[];if(0===i)return[[t*e/(t*t+r*r),r*e/(t*t+r*r)]];var n=Math.sqrt(i);return[[(t*e+r*n)/(t*t+r*r),(r*e-t*n)/(t*t+r*r)],[(t*e-r*n)/(t*t+r*r),(r*e+t*n)/(t*t+r*r)]]}var u,h=Math.PI/180;function c(t,r,e){return(1-e)*t+e*r}function y(t,r,e,i){return t+Math.cos(i/180*n)*r+Math.sin(i/180*n)*e}function p(t,r,e,i){var a=1e-6,n=r-t,o=e-r,s=3*n+3*(i-e)-6*o,u=6*(o-n),h=3*n;return Math.abs(s)<a?[-h/u]:function(t,r,e){void 0===e&&(e=1e-6);var i=t*t/4-r;if(i<-e)return[];if(i<=e)return[-t/2];var a=Math.sqrt(i);return[-t/2-a,-t/2+a]}(u/s,h/s,a)}function m(t,r,e,i,a){var n=1-a;return t*(n*n*n)+r*(3*n*n*a)+e*(3*n*a*a)+i*(a*a*a)}!function(t){function r(){return u((function(t,r,e){return t.relative&&(void 0!==t.x1&&(t.x1+=r),void 0!==t.y1&&(t.y1+=e),void 0!==t.x2&&(t.x2+=r),void 0!==t.y2&&(t.y2+=e),void 0!==t.x&&(t.x+=r),void 0!==t.y&&(t.y+=e),t.relative=!1),t}))}function e(){var t=NaN,r=NaN,e=NaN,i=NaN;return u((function(a,n,o){return a.type&_.SMOOTH_CURVE_TO&&(a.type=_.CURVE_TO,t=isNaN(t)?n:t,r=isNaN(r)?o:r,a.x1=a.relative?n-t:2*n-t,a.y1=a.relative?o-r:2*o-r),a.type&_.CURVE_TO?(t=a.relative?n+a.x2:a.x2,r=a.relative?o+a.y2:a.y2):(t=NaN,r=NaN),a.type&_.SMOOTH_QUAD_TO&&(a.type=_.QUAD_TO,e=isNaN(e)?n:e,i=isNaN(i)?o:i,a.x1=a.relative?n-e:2*n-e,a.y1=a.relative?o-i:2*o-i),a.type&_.QUAD_TO?(e=a.relative?n+a.x1:a.x1,i=a.relative?o+a.y1:a.y1):(e=NaN,i=NaN),a}))}function n(){var t=NaN,r=NaN;return u((function(e,i,a){if(e.type&_.SMOOTH_QUAD_TO&&(e.type=_.QUAD_TO,t=isNaN(t)?i:t,r=isNaN(r)?a:r,e.x1=e.relative?i-t:2*i-t,e.y1=e.relative?a-r:2*a-r),e.type&_.QUAD_TO){t=e.relative?i+e.x1:e.x1,r=e.relative?a+e.y1:e.y1;var n=e.x1,o=e.y1;e.type=_.CURVE_TO,e.x1=((e.relative?0:i)+2*n)/3,e.y1=((e.relative?0:a)+2*o)/3,e.x2=(e.x+2*n)/3,e.y2=(e.y+2*o)/3}else t=NaN,r=NaN;return e}))}function u(t){var r=0,e=0,i=NaN,a=NaN;return function(n){if(isNaN(i)&&!(n.type&_.MOVE_TO))throw new Error("path must start with moveto");var o=t(n,r,e,i,a);return n.type&_.CLOSE_PATH&&(r=i,e=a),void 0!==n.x&&(r=n.relative?r+n.x:n.x),void 0!==n.y&&(e=n.relative?e+n.y:n.y),n.type&_.MOVE_TO&&(i=r,a=e),o}}function O(t,r,e,i,n,o){return a(t,r,e,i,n,o),u((function(a,s,u,h){var c=a.x1,y=a.x2,p=a.relative&&!isNaN(h),m=void 0!==a.x?a.x:p?0:s,O=void 0!==a.y?a.y:p?0:u;function l(t){return t*t}a.type&_.HORIZ_LINE_TO&&0!==r&&(a.type=_.LINE_TO,a.y=a.relative?0:u),a.type&_.VERT_LINE_TO&&0!==e&&(a.type=_.LINE_TO,a.x=a.relative?0:s),void 0!==a.x&&(a.x=a.x*t+O*e+(p?0:n)),void 0!==a.y&&(a.y=m*r+a.y*i+(p?0:o)),void 0!==a.x1&&(a.x1=a.x1*t+a.y1*e+(p?0:n)),void 0!==a.y1&&(a.y1=c*r+a.y1*i+(p?0:o)),void 0!==a.x2&&(a.x2=a.x2*t+a.y2*e+(p?0:n)),void 0!==a.y2&&(a.y2=y*r+a.y2*i+(p?0:o));var T=t*i-r*e;if(void 0!==a.xRot&&(1!==t||0!==r||0!==e||1!==i))if(0===T)delete a.rX,delete a.rY,delete a.xRot,delete a.lArcFlag,delete a.sweepFlag,a.type=_.LINE_TO;else{var v=a.xRot*Math.PI/180,f=Math.sin(v),N=Math.cos(v),x=1/l(a.rX),d=1/l(a.rY),E=l(N)*x+l(f)*d,A=2*f*N*(x-d),C=l(f)*x+l(N)*d,M=E*i*i-A*r*i+C*r*r,R=A*(t*i+r*e)-2*(E*e*i+C*t*r),g=E*e*e-A*t*e+C*t*t,I=(Math.atan2(R,M-g)+Math.PI)%Math.PI/2,S=Math.sin(I),L=Math.cos(I);a.rX=Math.abs(T)/Math.sqrt(M*l(L)+R*S*L+g*l(S)),a.rY=Math.abs(T)/Math.sqrt(M*l(S)-R*S*L+g*l(L)),a.xRot=180*I/Math.PI}return void 0!==a.sweepFlag&&0>T&&(a.sweepFlag=+!a.sweepFlag),a}))}function l(){return function(t){var r={};for(var e in t)r[e]=t[e];return r}}t.ROUND=function(t){function r(r){return Math.round(r*t)/t}return void 0===t&&(t=1e13),a(t),function(t){return void 0!==t.x1&&(t.x1=r(t.x1)),void 0!==t.y1&&(t.y1=r(t.y1)),void 0!==t.x2&&(t.x2=r(t.x2)),void 0!==t.y2&&(t.y2=r(t.y2)),void 0!==t.x&&(t.x=r(t.x)),void 0!==t.y&&(t.y=r(t.y)),void 0!==t.rX&&(t.rX=r(t.rX)),void 0!==t.rY&&(t.rY=r(t.rY)),t}},t.TO_ABS=r,t.TO_REL=function(){return u((function(t,r,e){return t.relative||(void 0!==t.x1&&(t.x1-=r),void 0!==t.y1&&(t.y1-=e),void 0!==t.x2&&(t.x2-=r),void 0!==t.y2&&(t.y2-=e),void 0!==t.x&&(t.x-=r),void 0!==t.y&&(t.y-=e),t.relative=!0),t}))},t.NORMALIZE_HVZ=function(t,r,e){return void 0===t&&(t=!0),void 0===r&&(r=!0),void 0===e&&(e=!0),u((function(i,a,n,o,s){if(isNaN(o)&&!(i.type&_.MOVE_TO))throw new Error("path must start with moveto");return r&&i.type&_.HORIZ_LINE_TO&&(i.type=_.LINE_TO,i.y=i.relative?0:n),e&&i.type&_.VERT_LINE_TO&&(i.type=_.LINE_TO,i.x=i.relative?0:a),t&&i.type&_.CLOSE_PATH&&(i.type=_.LINE_TO,i.x=i.relative?o-a:o,i.y=i.relative?s-n:s),i.type&_.ARC&&(0===i.rX||0===i.rY)&&(i.type=_.LINE_TO,delete i.rX,delete i.rY,delete i.xRot,delete i.lArcFlag,delete i.sweepFlag),i}))},t.NORMALIZE_ST=e,t.QT_TO_C=n,t.INFO=u,t.SANITIZE=function(t){void 0===t&&(t=0),a(t);var r=NaN,e=NaN,i=NaN,n=NaN;return u((function(a,o,s,u,h){var c=Math.abs,y=!1,p=0,m=0;if(a.type&_.SMOOTH_CURVE_TO&&(p=isNaN(r)?0:o-r,m=isNaN(e)?0:s-e),a.type&(_.CURVE_TO|_.SMOOTH_CURVE_TO)?(r=a.relative?o+a.x2:a.x2,e=a.relative?s+a.y2:a.y2):(r=NaN,e=NaN),a.type&_.SMOOTH_QUAD_TO?(i=isNaN(i)?o:2*o-i,n=isNaN(n)?s:2*s-n):a.type&_.QUAD_TO?(i=a.relative?o+a.x1:a.x1,n=a.relative?s+a.y1:a.y2):(i=NaN,n=NaN),a.type&_.LINE_COMMANDS||a.type&_.ARC&&(0===a.rX||0===a.rY||!a.lArcFlag)||a.type&_.CURVE_TO||a.type&_.SMOOTH_CURVE_TO||a.type&_.QUAD_TO||a.type&_.SMOOTH_QUAD_TO){var O=void 0===a.x?0:a.relative?a.x:a.x-o,l=void 0===a.y?0:a.relative?a.y:a.y-s;p=isNaN(i)?void 0===a.x1?p:a.relative?a.x:a.x1-o:i-o,m=isNaN(n)?void 0===a.y1?m:a.relative?a.y:a.y1-s:n-s;var T=void 0===a.x2?0:a.relative?a.x:a.x2-o,v=void 0===a.y2?0:a.relative?a.y:a.y2-s;c(O)<=t&&c(l)<=t&&c(p)<=t&&c(m)<=t&&c(T)<=t&&c(v)<=t&&(y=!0)}return a.type&_.CLOSE_PATH&&c(o-u)<=t&&c(s-h)<=t&&(y=!0),y?[]:a}))},t.MATRIX=O,t.ROTATE=function(t,r,e){void 0===r&&(r=0),void 0===e&&(e=0),a(t,r,e);var i=Math.sin(t),n=Math.cos(t);return O(n,i,-i,n,r-r*n+e*i,e-r*i-e*n)},t.TRANSLATE=function(t,r){return void 0===r&&(r=0),a(t,r),O(1,0,0,1,t,r)},t.SCALE=function(t,r){return void 0===r&&(r=t),a(t,r),O(t,0,0,r,0,0)},t.SKEW_X=function(t){return a(t),O(1,0,Math.atan(t),1,0,0)},t.SKEW_Y=function(t){return a(t),O(1,Math.atan(t),0,1,0,0)},t.X_AXIS_SYMMETRY=function(t){return void 0===t&&(t=0),a(t),O(-1,0,0,1,t,0)},t.Y_AXIS_SYMMETRY=function(t){return void 0===t&&(t=0),a(t),O(1,0,0,-1,0,t)},t.A_TO_C=function(){return u((function(t,r,e){return _.ARC===t.type?function(t,r,e){var a,n,s,u;t.cX||o(t,r,e);for(var y=Math.min(t.phi1,t.phi2),p=Math.max(t.phi1,t.phi2)-y,m=Math.ceil(p/90),O=new Array(m),l=r,T=e,v=0;v<m;v++){var f=c(t.phi1,t.phi2,v/m),N=c(t.phi1,t.phi2,(v+1)/m),x=N-f,d=4/3*Math.tan(x*h/4),E=[Math.cos(f*h)-d*Math.sin(f*h),Math.sin(f*h)+d*Math.cos(f*h)],A=E[0],C=E[1],M=[Math.cos(N*h),Math.sin(N*h)],R=M[0],g=M[1],I=[R+d*Math.sin(N*h),g-d*Math.cos(N*h)],S=I[0],L=I[1];O[v]={relative:t.relative,type:_.CURVE_TO};var H=function(r,e){var a=i([r*t.rX,e*t.rY],t.xRot),n=a[0],o=a[1];return[t.cX+n,t.cY+o]};a=H(A,C),O[v].x1=a[0],O[v].y1=a[1],n=H(S,L),O[v].x2=n[0],O[v].y2=n[1],s=H(R,g),O[v].x=s[0],O[v].y=s[1],t.relative&&(O[v].x1-=l,O[v].y1-=T,O[v].x2-=l,O[v].y2-=T,O[v].x-=l,O[v].y-=T),l=(u=[O[v].x,O[v].y])[0],T=u[1]}return O}(t,t.relative?0:r,t.relative?0:e):t}))},t.ANNOTATE_ARCS=function(){return u((function(t,r,e){return t.relative&&(r=0,e=0),_.ARC===t.type&&o(t,r,e),t}))},t.CLONE=l,t.CALCULATE_BOUNDS=function(){var t=function(t){var r={};for(var e in t)r[e]=t[e];return r},i=r(),a=n(),h=e(),c=u((function(r,e,n){var u=h(a(i(t(r))));function O(t){t>c.maxX&&(c.maxX=t),t<c.minX&&(c.minX=t)}function l(t){t>c.maxY&&(c.maxY=t),t<c.minY&&(c.minY=t)}if(u.type&_.DRAWING_COMMANDS&&(O(e),l(n)),u.type&_.HORIZ_LINE_TO&&O(u.x),u.type&_.VERT_LINE_TO&&l(u.y),u.type&_.LINE_TO&&(O(u.x),l(u.y)),u.type&_.CURVE_TO){O(u.x),l(u.y);for(var T=0,v=p(e,u.x1,u.x2,u.x);T<v.length;T++){0<(w=v[T])&&1>w&&O(m(e,u.x1,u.x2,u.x,w))}for(var f=0,N=p(n,u.y1,u.y2,u.y);f<N.length;f++){0<(w=N[f])&&1>w&&l(m(n,u.y1,u.y2,u.y,w))}}if(u.type&_.ARC){O(u.x),l(u.y),o(u,e,n);for(var x=u.xRot/180*Math.PI,d=Math.cos(x)*u.rX,E=Math.sin(x)*u.rX,A=-Math.sin(x)*u.rY,C=Math.cos(x)*u.rY,M=u.phi1<u.phi2?[u.phi1,u.phi2]:-180>u.phi2?[u.phi2+360,u.phi1+360]:[u.phi2,u.phi1],R=M[0],g=M[1],I=function(t){var r=t[0],e=t[1],i=180*Math.atan2(e,r)/Math.PI;return i<R?i+360:i},S=0,L=s(A,-d,0).map(I);S<L.length;S++){(w=L[S])>R&&w<g&&O(y(u.cX,d,A,w))}for(var H=0,U=s(C,-E,0).map(I);H<U.length;H++){var w;(w=U[H])>R&&w<g&&l(y(u.cY,E,C,w))}}return r}));return c.minX=1/0,c.maxX=-1/0,c.minY=1/0,c.maxY=-1/0,c}}(u||(u={}));var O,l=function(){function t(){}return t.prototype.round=function(t){return this.transform(u.ROUND(t))},t.prototype.toAbs=function(){return this.transform(u.TO_ABS())},t.prototype.toRel=function(){return this.transform(u.TO_REL())},t.prototype.normalizeHVZ=function(t,r,e){return this.transform(u.NORMALIZE_HVZ(t,r,e))},t.prototype.normalizeST=function(){return this.transform(u.NORMALIZE_ST())},t.prototype.qtToC=function(){return this.transform(u.QT_TO_C())},t.prototype.aToC=function(){return this.transform(u.A_TO_C())},t.prototype.sanitize=function(t){return this.transform(u.SANITIZE(t))},t.prototype.translate=function(t,r){return this.transform(u.TRANSLATE(t,r))},t.prototype.scale=function(t,r){return this.transform(u.SCALE(t,r))},t.prototype.rotate=function(t,r,e){return this.transform(u.ROTATE(t,r,e))},t.prototype.matrix=function(t,r,e,i,a,n){return this.transform(u.MATRIX(t,r,e,i,a,n))},t.prototype.skewX=function(t){return this.transform(u.SKEW_X(t))},t.prototype.skewY=function(t){return this.transform(u.SKEW_Y(t))},t.prototype.xSymmetry=function(t){return this.transform(u.X_AXIS_SYMMETRY(t))},t.prototype.ySymmetry=function(t){return this.transform(u.Y_AXIS_SYMMETRY(t))},t.prototype.annotateArcs=function(){return this.transform(u.ANNOTATE_ARCS())},t}(),T=function(t){return" "===t||"\t"===t||"\r"===t||"\n"===t},v=function(t){return"0".charCodeAt(0)<=t.charCodeAt(0)&&t.charCodeAt(0)<="9".charCodeAt(0)},f=function(t){function e(){var r=t.call(this)||this;return r.curNumber="",r.curCommandType=-1,r.curCommandRelative=!1,r.canParseCommandOrComma=!0,r.curNumberHasExp=!1,r.curNumberHasExpDigits=!1,r.curNumberHasDecimal=!1,r.curArgs=[],r}return r(e,t),e.prototype.finish=function(t){if(void 0===t&&(t=[]),this.parse(" ",t),0!==this.curArgs.length||!this.canParseCommandOrComma)throw new SyntaxError("Unterminated command at the path end.");return t},e.prototype.parse=function(t,r){var e=this;void 0===r&&(r=[]);for(var i=function(t){r.push(t),e.curArgs.length=0,e.canParseCommandOrComma=!0},a=0;a<t.length;a++){var n=t[a],o=!(this.curCommandType!==_.ARC||3!==this.curArgs.length&&4!==this.curArgs.length||1!==this.curNumber.length||"0"!==this.curNumber&&"1"!==this.curNumber),s=v(n)&&("0"===this.curNumber&&"0"===n||o);if(!v(n)||s)if("e"!==n&&"E"!==n)if("-"!==n&&"+"!==n||!this.curNumberHasExp||this.curNumberHasExpDigits)if("."!==n||this.curNumberHasExp||this.curNumberHasDecimal||o){if(this.curNumber&&-1!==this.curCommandType){var u=Number(this.curNumber);if(isNaN(u))throw new SyntaxError("Invalid number ending at "+a);if(this.curCommandType===_.ARC)if(0===this.curArgs.length||1===this.curArgs.length){if(0>u)throw new SyntaxError('Expected positive number, got "'+u+'" at index "'+a+'"')}else if((3===this.curArgs.length||4===this.curArgs.length)&&"0"!==this.curNumber&&"1"!==this.curNumber)throw new SyntaxError('Expected a flag, got "'+this.curNumber+'" at index "'+a+'"');this.curArgs.push(u),this.curArgs.length===N[this.curCommandType]&&(_.HORIZ_LINE_TO===this.curCommandType?i({type:_.HORIZ_LINE_TO,relative:this.curCommandRelative,x:u}):_.VERT_LINE_TO===this.curCommandType?i({type:_.VERT_LINE_TO,relative:this.curCommandRelative,y:u}):this.curCommandType===_.MOVE_TO||this.curCommandType===_.LINE_TO||this.curCommandType===_.SMOOTH_QUAD_TO?(i({type:this.curCommandType,relative:this.curCommandRelative,x:this.curArgs[0],y:this.curArgs[1]}),_.MOVE_TO===this.curCommandType&&(this.curCommandType=_.LINE_TO)):this.curCommandType===_.CURVE_TO?i({type:_.CURVE_TO,relative:this.curCommandRelative,x1:this.curArgs[0],y1:this.curArgs[1],x2:this.curArgs[2],y2:this.curArgs[3],x:this.curArgs[4],y:this.curArgs[5]}):this.curCommandType===_.SMOOTH_CURVE_TO?i({type:_.SMOOTH_CURVE_TO,relative:this.curCommandRelative,x2:this.curArgs[0],y2:this.curArgs[1],x:this.curArgs[2],y:this.curArgs[3]}):this.curCommandType===_.QUAD_TO?i({type:_.QUAD_TO,relative:this.curCommandRelative,x1:this.curArgs[0],y1:this.curArgs[1],x:this.curArgs[2],y:this.curArgs[3]}):this.curCommandType===_.ARC&&i({type:_.ARC,relative:this.curCommandRelative,rX:this.curArgs[0],rY:this.curArgs[1],xRot:this.curArgs[2],lArcFlag:this.curArgs[3],sweepFlag:this.curArgs[4],x:this.curArgs[5],y:this.curArgs[6]})),this.curNumber="",this.curNumberHasExpDigits=!1,this.curNumberHasExp=!1,this.curNumberHasDecimal=!1,this.canParseCommandOrComma=!0}if(!T(n))if(","===n&&this.canParseCommandOrComma)this.canParseCommandOrComma=!1;else if("+"!==n&&"-"!==n&&"."!==n)if(s)this.curNumber=n,this.curNumberHasDecimal=!1;else{if(0!==this.curArgs.length)throw new SyntaxError("Unterminated command at index "+a+".");if(!this.canParseCommandOrComma)throw new SyntaxError('Unexpected character "'+n+'" at index '+a+". Command cannot follow comma");if(this.canParseCommandOrComma=!1,"z"!==n&&"Z"!==n)if("h"===n||"H"===n)this.curCommandType=_.HORIZ_LINE_TO,this.curCommandRelative="h"===n;else if("v"===n||"V"===n)this.curCommandType=_.VERT_LINE_TO,this.curCommandRelative="v"===n;else if("m"===n||"M"===n)this.curCommandType=_.MOVE_TO,this.curCommandRelative="m"===n;else if("l"===n||"L"===n)this.curCommandType=_.LINE_TO,this.curCommandRelative="l"===n;else if("c"===n||"C"===n)this.curCommandType=_.CURVE_TO,this.curCommandRelative="c"===n;else if("s"===n||"S"===n)this.curCommandType=_.SMOOTH_CURVE_TO,this.curCommandRelative="s"===n;else if("q"===n||"Q"===n)this.curCommandType=_.QUAD_TO,this.curCommandRelative="q"===n;else if("t"===n||"T"===n)this.curCommandType=_.SMOOTH_QUAD_TO,this.curCommandRelative="t"===n;else{if("a"!==n&&"A"!==n)throw new SyntaxError('Unexpected character "'+n+'" at index '+a+".");this.curCommandType=_.ARC,this.curCommandRelative="a"===n}else r.push({type:_.CLOSE_PATH}),this.canParseCommandOrComma=!0,this.curCommandType=-1}else this.curNumber=n,this.curNumberHasDecimal="."===n}else this.curNumber+=n,this.curNumberHasDecimal=!0;else this.curNumber+=n;else this.curNumber+=n,this.curNumberHasExp=!0;else this.curNumber+=n,this.curNumberHasExpDigits=this.curNumberHasExp}return r},e.prototype.transform=function(t){return Object.create(this,{parse:{value:function(r,e){void 0===e&&(e=[]);for(var i=0,a=Object.getPrototypeOf(this).parse.call(this,r);i<a.length;i++){var n=a[i],o=t(n);Array.isArray(o)?e.push.apply(e,o):e.push(o)}return e}}})},e}(l),_=function(t){function i(r){var e=t.call(this)||this;return e.commands="string"==typeof r?i.parse(r):r,e}return r(i,t),i.prototype.encode=function(){return i.encode(this.commands)},i.prototype.getBounds=function(){var t=u.CALCULATE_BOUNDS();return this.transform(t),t},i.prototype.transform=function(t){for(var r=[],e=0,i=this.commands;e<i.length;e++){var a=t(i[e]);Array.isArray(a)?r.push.apply(r,a):r.push(a)}return this.commands=r,this},i.encode=function(t){return e(t)},i.parse=function(t){var r=new f,e=[];return r.parse(t,e),r.finish(e),e},i.CLOSE_PATH=1,i.MOVE_TO=2,i.HORIZ_LINE_TO=4,i.VERT_LINE_TO=8,i.LINE_TO=16,i.CURVE_TO=32,i.SMOOTH_CURVE_TO=64,i.QUAD_TO=128,i.SMOOTH_QUAD_TO=256,i.ARC=512,i.LINE_COMMANDS=i.LINE_TO|i.HORIZ_LINE_TO|i.VERT_LINE_TO,i.DRAWING_COMMANDS=i.HORIZ_LINE_TO|i.VERT_LINE_TO|i.LINE_TO|i.CURVE_TO|i.SMOOTH_CURVE_TO|i.QUAD_TO|i.SMOOTH_QUAD_TO|i.ARC,i}(l),N=((O={})[_.MOVE_TO]=2,O[_.LINE_TO]=2,O[_.HORIZ_LINE_TO]=1,O[_.VERT_LINE_TO]=1,O[_.CLOSE_PATH]=0,O[_.QUAD_TO]=4,O[_.SMOOTH_QUAD_TO]=2,O[_.CURVE_TO]=6,O[_.SMOOTH_CURVE_TO]=4,O[_.ARC]=7,O);
//# sourceMappingURL=SVGPathData.module.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY2FudmdfZGlzdF9pbmRleF9qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7Ozs7QUNuQ0EsVUFBVSxtQkFBTyxDQUFDLDhFQUFpQjtBQUNuQywyQ0FBMkMscUJBQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUksU0FBUyxJQUFJLFNBQVMsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkIsSUFBSSxTQUFTLElBQUksU0FBUyxJQUFJO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrQkFBK0IsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrQkFBK0IsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsb0RBQW9EO0FBQ3BELGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdTQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHVHQUF1RztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLFdBQVcsMEJBQTBCO0FBQ3JDLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaLGFBQWEsV0FBVyxLQUFLO0FBQzdCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFlBQVk7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0w7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6bkJoSjtBQUNSO0FBQ1c7QUFDRzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUE4QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFDQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUE2QztBQUM3RCxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0pBQXNKO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUxBQWlMO0FBQy9MLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdDQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQ0FBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFpRCxJQUFJO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxREFBcUQsSUFBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVMsU0FBUyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUyxTQUFTLHVCQUF1QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx5Q0FBeUMsMkJBQTJCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIscURBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOERBQW9CLHdCQUF3QixxRUFBMkIsd0JBQXdCLDZEQUFtQix3QkFBd0Isb0VBQTBCO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXLGlCQUFpQixhQUFhLG9CQUFvQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsbUJBQW1CO0FBQ25DLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixtQkFBbUI7QUFDbkMsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0Isd0VBQXdFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0IsSUFBSSxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsb0JBQW9CLHNCQUFzQjtBQUMxQyxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4Qyw4QkFBOEIscUNBQVE7QUFDdEMsNEJBQTRCLHFDQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG9DQUFvQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQ0FBMEM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQTJDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBeUQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFNBQVMsT0FBTyxLQUFLLFFBQVEsWUFBWTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBLHVCQUF1QixZQUFZO0FBQ25DLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUIseUxBQXlMLElBQUk7QUFDdE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFtRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaXBDO0FBQ2pwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNybktBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQyxhQUFhLGdDQUFnQyxjQUFjLGdCQUFnQixzRUFBc0UsUUFBUSxnQkFBZ0Isd0hBQXdILGFBQWEsbUJBQW1CLDZFQUE2RSxjQUFjLFNBQVMsMEJBQTBCLFlBQVksV0FBVyxLQUFLLFdBQVcsZ0NBQWdDLDZEQUE2RCw0REFBNEQsK0RBQStELCtEQUErRCxvR0FBb0cseUZBQXlGLGlGQUFpRixzRUFBc0UsS0FBSywwRkFBMEYscUdBQXFHLFNBQVMsZ0JBQWdCLGtCQUFrQixnRUFBZ0UsYUFBYSxpQkFBaUIsbUJBQW1CLHNCQUFzQixZQUFZLFdBQVcsZ0lBQWdJLFNBQVMsY0FBYyxrQkFBa0IsOERBQThELDhCQUE4QixrQ0FBa0MsaUhBQWlILHFEQUFxRCxzTUFBc00sb09BQW9PLGtCQUFrQixTQUFTLGtCQUFrQixnQkFBZ0IsK0NBQStDLG1CQUFtQiw0RkFBNEYsb0JBQW9CLGtCQUFrQixrQkFBa0Isb0JBQW9CLGlEQUFpRCxvQkFBb0IseURBQXlELDRDQUE0QyxxQkFBcUIsY0FBYyxpQkFBaUIscUJBQXFCLG1CQUFtQixzQkFBc0IsWUFBWSxzQkFBc0IsVUFBVSxtREFBbUQsYUFBYSxhQUFhLDBCQUEwQix1TEFBdUwsR0FBRyxhQUFhLDRCQUE0QiwwQkFBMEIsOGFBQThhLEdBQUcsYUFBYSxnQkFBZ0IsMEJBQTBCLG1KQUFtSixrREFBa0Qsa0JBQWtCLGdIQUFnSCxpQkFBaUIsU0FBUyxHQUFHLGNBQWMsd0JBQXdCLG1CQUFtQixnRkFBZ0YsbUJBQW1CLG1KQUFtSix3QkFBd0IsMkNBQTJDLDRGQUE0RixjQUFjLFdBQVcsK1hBQStYLGNBQWMsc0pBQXNKLEtBQUsscVFBQXFRLHFIQUFxSCxnRUFBZ0UsR0FBRyxhQUFhLG1CQUFtQixTQUFTLHlCQUF5QixVQUFVLG9CQUFvQixjQUFjLHlCQUF5Qiw2Q0FBNkMsb1BBQW9QLGdDQUFnQywwQkFBMEIsdUxBQXVMLEdBQUcsaUNBQWlDLHVGQUF1RixnRkFBZ0YsaVdBQWlXLEdBQUcsOERBQThELHVCQUF1Qiw0QkFBNEIsOEJBQThCLDRCQUE0Qiw2ZEFBNmQsZ0ZBQWdGLDBHQUEwRyxvRkFBb0YsNkRBQTZELGdFQUFnRSxHQUFHLHFDQUFxQyw2Q0FBNkMsZ0NBQWdDLHVDQUF1QywyQkFBMkIsK0NBQStDLHVCQUF1QiwrQ0FBK0Msc0JBQXNCLHNDQUFzQyxzQkFBc0Isc0NBQXNDLCtCQUErQiw4Q0FBOEMsK0JBQStCLDhDQUE4QyxxQkFBcUIsMEJBQTBCLHNDQUFzQyxZQUFZLGVBQWUsMkdBQTJHLElBQUksS0FBSyxvUUFBb1EsTUFBTSxxQ0FBcUMsb0JBQW9CLDhDQUE4Qyx1QkFBdUIscU5BQXFOLFNBQVMsb0NBQW9DLEdBQUcsNEJBQTRCLDBCQUEwQix3REFBd0QsR0FBRyx5Q0FBeUMsa0JBQWtCLFNBQVMseUJBQXlCLFNBQVMsd0NBQXdDLG9CQUFvQixjQUFjLDBDQUEwQyxjQUFjLDBDQUEwQyw0SkFBNEosY0FBYyxpQ0FBaUMsV0FBVyxLQUFLLHlDQUF5QyxpQ0FBaUMsV0FBVyxLQUFLLDBDQUEwQyxpQkFBaUIsdUJBQXVCLDBOQUEwTixnREFBZ0QsbUJBQW1CLHdCQUF3QixXQUFXLEtBQUssa0NBQWtDLCtCQUErQixXQUFXLEtBQUssTUFBTSxtQ0FBbUMsU0FBUyxHQUFHLHdEQUF3RCxTQUFTLEdBQUcsbUJBQW1CLGNBQWMscUNBQXFDLGtDQUFrQyw4QkFBOEIsa0NBQWtDLDhCQUE4QixrQ0FBa0MsMENBQTBDLDhDQUE4QyxvQ0FBb0Msd0NBQXdDLDhCQUE4QixtQ0FBbUMsNkJBQTZCLGtDQUFrQyxrQ0FBa0MscUNBQXFDLHFDQUFxQyx3Q0FBd0MsaUNBQWlDLG9DQUFvQyxvQ0FBb0MsdUNBQXVDLDBDQUEwQyw2Q0FBNkMsK0JBQStCLG1DQUFtQywrQkFBK0IsbUNBQW1DLG1DQUFtQyw0Q0FBNEMsbUNBQW1DLDRDQUE0QyxxQ0FBcUMseUNBQXlDLEdBQUcsaUJBQWlCLDRDQUE0QyxlQUFlLDZFQUE2RSxlQUFlLGFBQWEseUJBQXlCLHNMQUFzTCw2Q0FBNkMsNkpBQTZKLFNBQVMsaUNBQWlDLFdBQVcsbUJBQW1CLHNCQUFzQix5REFBeUQsS0FBSyxXQUFXLEtBQUssZ05BQWdOLHNLQUFzSyw2Q0FBNkMsNkJBQTZCLGlFQUFpRSxvRkFBb0YsdUZBQXVGLDJMQUEyTCw2R0FBNkcsMERBQTBELDBDQUEwQyx5REFBeUQsK0dBQStHLDhGQUE4Rix3R0FBd0csaUtBQWlLLDZDQUE2QyxrSUFBa0kscUNBQXFDLDBIQUEwSCxrQ0FBa0MsOExBQThMLHNJQUFzSSxnRkFBZ0Ysb0ZBQW9GLEtBQUsseUZBQXlGLGtJQUFrSSwySUFBMkksNEZBQTRGLHVGQUF1Rix1RkFBdUYsd0ZBQXdGLCtGQUErRix1RkFBdUYsOEZBQThGLEtBQUssMEZBQTBGLDBEQUEwRCxhQUFhLGtCQUFrQix3REFBd0QsdURBQXVELG1EQUFtRCx1QkFBdUIsK0NBQStDLHVFQUF1RSxTQUFTLG1DQUFtQywyQkFBMkIsT0FBTyxvQkFBb0IsbUJBQW1CLDZEQUE2RCxXQUFXLEtBQUssa0JBQWtCLDZDQUE2QyxXQUFXLEVBQUUsR0FBRyxrQkFBa0IsY0FBYyx5QkFBeUIsb0RBQW9ELDRDQUE0QywrQkFBK0Isa0NBQWtDLDJCQUEyQiwyQkFBMkIsbUNBQW1DLGlDQUFpQyxXQUFXLEtBQUssY0FBYyw2Q0FBNkMsNEJBQTRCLHNCQUFzQixZQUFZLHFCQUFxQixpQkFBaUIsa0NBQWtDLGlWQUFpVixZQUFZLG1MQUEwUztBQUNoempCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWMtY2xpZW50Mi8uL25vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIndlYnBhY2s6Ly9hYy1jbGllbnQyLy4vbm9kZV9tb2R1bGVzL3JhZi9pbmRleC5qcyIsIndlYnBhY2s6Ly9hYy1jbGllbnQyLy4vbm9kZV9tb2R1bGVzL3JnYmNvbG9yL2luZGV4LmpzIiwid2VicGFjazovL2FjLWNsaWVudDIvLi9ub2RlX21vZHVsZXMvc3RhY2tibHVyLWNhbnZhcy9kaXN0L3N0YWNrYmx1ci1lcy5qcyIsIndlYnBhY2s6Ly9hYy1jbGllbnQyLy4vbm9kZV9tb2R1bGVzL2NhbnZnL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYWMtY2xpZW50Mi8uL25vZGVfbW9kdWxlcy9zdmctcGF0aGRhdGEvbGliL1NWR1BhdGhEYXRhLm1vZHVsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWUsIG1vZHVsZUxvYWRUaW1lLCBub2RlTG9hZFRpbWUsIHVwVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBub2RlTG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIG1vZHVsZUxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgICB1cFRpbWUgPSBwcm9jZXNzLnVwdGltZSgpICogMWU5O1xuICAgIG5vZGVMb2FkVGltZSA9IG1vZHVsZUxvYWRUaW1lIC0gdXBUaW1lO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJmb3JtYW5jZS1ub3cuanMubWFwXG4iLCJ2YXIgbm93ID0gcmVxdWlyZSgncGVyZm9ybWFuY2Utbm93JylcbiAgLCByb290ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3dcbiAgLCB2ZW5kb3JzID0gWydtb3onLCAnd2Via2l0J11cbiAgLCBzdWZmaXggPSAnQW5pbWF0aW9uRnJhbWUnXG4gICwgcmFmID0gcm9vdFsncmVxdWVzdCcgKyBzdWZmaXhdXG4gICwgY2FmID0gcm9vdFsnY2FuY2VsJyArIHN1ZmZpeF0gfHwgcm9vdFsnY2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG5cbmZvcih2YXIgaSA9IDA7ICFyYWYgJiYgaSA8IHZlbmRvcnMubGVuZ3RoOyBpKyspIHtcbiAgcmFmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ1JlcXVlc3QnICsgc3VmZml4XVxuICBjYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsJyArIHN1ZmZpeF1cbiAgICAgIHx8IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cbn1cblxuLy8gU29tZSB2ZXJzaW9ucyBvZiBGRiBoYXZlIHJBRiBidXQgbm90IGNBRlxuaWYoIXJhZiB8fCAhY2FmKSB7XG4gIHZhciBsYXN0ID0gMFxuICAgICwgaWQgPSAwXG4gICAgLCBxdWV1ZSA9IFtdXG4gICAgLCBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIDYwXG5cbiAgcmFmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZihxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBfbm93ID0gbm93KClcbiAgICAgICAgLCBuZXh0ID0gTWF0aC5tYXgoMCwgZnJhbWVEdXJhdGlvbiAtIChfbm93IC0gbGFzdCkpXG4gICAgICBsYXN0ID0gbmV4dCArIF9ub3dcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcCA9IHF1ZXVlLnNsaWNlKDApXG4gICAgICAgIC8vIENsZWFyIHF1ZXVlIGhlcmUgdG8gcHJldmVudFxuICAgICAgICAvLyBjYWxsYmFja3MgZnJvbSBhcHBlbmRpbmcgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGZyYW1lJ3MgcXVldWVcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZighY3BbaV0uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIGNwW2ldLmNhbGxiYWNrKGxhc3QpXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgZSB9LCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5yb3VuZChuZXh0KSlcbiAgICB9XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBoYW5kbGU6ICsraWQsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjYW5jZWxsZWQ6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIGNhZiA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYocXVldWVbaV0uaGFuZGxlID09PSBoYW5kbGUpIHtcbiAgICAgICAgcXVldWVbaV0uY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIC8vIFdyYXAgaW4gYSBuZXcgZnVuY3Rpb24gdG8gcHJldmVudFxuICAvLyBgY2FuY2VsYCBwb3RlbnRpYWxseSBiZWluZyBhc3NpZ25lZFxuICAvLyB0byB0aGUgbmF0aXZlIHJBRiBmdW5jdGlvblxuICByZXR1cm4gcmFmLmNhbGwocm9vdCwgZm4pXG59XG5tb2R1bGUuZXhwb3J0cy5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgY2FmLmFwcGx5KHJvb3QsIGFyZ3VtZW50cylcbn1cbm1vZHVsZS5leHBvcnRzLnBvbHlmaWxsID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgb2JqZWN0ID0gcm9vdDtcbiAgfVxuICBvYmplY3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmFmXG4gIG9iamVjdC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNhZlxufVxuIiwiLypcblx0QmFzZWQgb24gcmdiY29sb3IuanMgYnkgU3RveWFuIFN0ZWZhbm92IDxzc3Rvb0BnbWFpbC5jb20+XG5cdGh0dHA6Ly93d3cucGhwaWVkLmNvbS9yZ2ItY29sb3ItcGFyc2VyLWluLWphdmFzY3JpcHQvXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbG9yX3N0cmluZykge1xuICAgIHRoaXMub2sgPSBmYWxzZTtcbiAgICB0aGlzLmFscGhhID0gMS4wO1xuXG4gICAgLy8gc3RyaXAgYW55IGxlYWRpbmcgI1xuICAgIGlmIChjb2xvcl9zdHJpbmcuY2hhckF0KDApID09ICcjJykgeyAvLyByZW1vdmUgIyBpZiBhbnlcbiAgICAgICAgY29sb3Jfc3RyaW5nID0gY29sb3Jfc3RyaW5nLnN1YnN0cigxLDYpO1xuICAgIH1cblxuICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy5yZXBsYWNlKC8gL2csJycpO1xuICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gYmVmb3JlIGdldHRpbmcgaW50byByZWdleHBzLCB0cnkgc2ltcGxlIG1hdGNoZXNcbiAgICAvLyBhbmQgb3ZlcndyaXRlIHRoZSBpbnB1dFxuICAgIHZhciBzaW1wbGVfY29sb3JzID0ge1xuICAgICAgICBhbGljZWJsdWU6ICdmMGY4ZmYnLFxuICAgICAgICBhbnRpcXVld2hpdGU6ICdmYWViZDcnLFxuICAgICAgICBhcXVhOiAnMDBmZmZmJyxcbiAgICAgICAgYXF1YW1hcmluZTogJzdmZmZkNCcsXG4gICAgICAgIGF6dXJlOiAnZjBmZmZmJyxcbiAgICAgICAgYmVpZ2U6ICdmNWY1ZGMnLFxuICAgICAgICBiaXNxdWU6ICdmZmU0YzQnLFxuICAgICAgICBibGFjazogJzAwMDAwMCcsXG4gICAgICAgIGJsYW5jaGVkYWxtb25kOiAnZmZlYmNkJyxcbiAgICAgICAgYmx1ZTogJzAwMDBmZicsXG4gICAgICAgIGJsdWV2aW9sZXQ6ICc4YTJiZTInLFxuICAgICAgICBicm93bjogJ2E1MmEyYScsXG4gICAgICAgIGJ1cmx5d29vZDogJ2RlYjg4NycsXG4gICAgICAgIGNhZGV0Ymx1ZTogJzVmOWVhMCcsXG4gICAgICAgIGNoYXJ0cmV1c2U6ICc3ZmZmMDAnLFxuICAgICAgICBjaG9jb2xhdGU6ICdkMjY5MWUnLFxuICAgICAgICBjb3JhbDogJ2ZmN2Y1MCcsXG4gICAgICAgIGNvcm5mbG93ZXJibHVlOiAnNjQ5NWVkJyxcbiAgICAgICAgY29ybnNpbGs6ICdmZmY4ZGMnLFxuICAgICAgICBjcmltc29uOiAnZGMxNDNjJyxcbiAgICAgICAgY3lhbjogJzAwZmZmZicsXG4gICAgICAgIGRhcmtibHVlOiAnMDAwMDhiJyxcbiAgICAgICAgZGFya2N5YW46ICcwMDhiOGInLFxuICAgICAgICBkYXJrZ29sZGVucm9kOiAnYjg4NjBiJyxcbiAgICAgICAgZGFya2dyYXk6ICdhOWE5YTknLFxuICAgICAgICBkYXJrZ3JlZW46ICcwMDY0MDAnLFxuICAgICAgICBkYXJra2hha2k6ICdiZGI3NmInLFxuICAgICAgICBkYXJrbWFnZW50YTogJzhiMDA4YicsXG4gICAgICAgIGRhcmtvbGl2ZWdyZWVuOiAnNTU2YjJmJyxcbiAgICAgICAgZGFya29yYW5nZTogJ2ZmOGMwMCcsXG4gICAgICAgIGRhcmtvcmNoaWQ6ICc5OTMyY2MnLFxuICAgICAgICBkYXJrcmVkOiAnOGIwMDAwJyxcbiAgICAgICAgZGFya3NhbG1vbjogJ2U5OTY3YScsXG4gICAgICAgIGRhcmtzZWFncmVlbjogJzhmYmM4ZicsXG4gICAgICAgIGRhcmtzbGF0ZWJsdWU6ICc0ODNkOGInLFxuICAgICAgICBkYXJrc2xhdGVncmF5OiAnMmY0ZjRmJyxcbiAgICAgICAgZGFya3R1cnF1b2lzZTogJzAwY2VkMScsXG4gICAgICAgIGRhcmt2aW9sZXQ6ICc5NDAwZDMnLFxuICAgICAgICBkZWVwcGluazogJ2ZmMTQ5MycsXG4gICAgICAgIGRlZXBza3libHVlOiAnMDBiZmZmJyxcbiAgICAgICAgZGltZ3JheTogJzY5Njk2OScsXG4gICAgICAgIGRvZGdlcmJsdWU6ICcxZTkwZmYnLFxuICAgICAgICBmZWxkc3BhcjogJ2QxOTI3NScsXG4gICAgICAgIGZpcmVicmljazogJ2IyMjIyMicsXG4gICAgICAgIGZsb3JhbHdoaXRlOiAnZmZmYWYwJyxcbiAgICAgICAgZm9yZXN0Z3JlZW46ICcyMjhiMjInLFxuICAgICAgICBmdWNoc2lhOiAnZmYwMGZmJyxcbiAgICAgICAgZ2FpbnNib3JvOiAnZGNkY2RjJyxcbiAgICAgICAgZ2hvc3R3aGl0ZTogJ2Y4ZjhmZicsXG4gICAgICAgIGdvbGQ6ICdmZmQ3MDAnLFxuICAgICAgICBnb2xkZW5yb2Q6ICdkYWE1MjAnLFxuICAgICAgICBncmF5OiAnODA4MDgwJyxcbiAgICAgICAgZ3JlZW46ICcwMDgwMDAnLFxuICAgICAgICBncmVlbnllbGxvdzogJ2FkZmYyZicsXG4gICAgICAgIGhvbmV5ZGV3OiAnZjBmZmYwJyxcbiAgICAgICAgaG90cGluazogJ2ZmNjliNCcsXG4gICAgICAgIGluZGlhbnJlZCA6ICdjZDVjNWMnLFxuICAgICAgICBpbmRpZ28gOiAnNGIwMDgyJyxcbiAgICAgICAgaXZvcnk6ICdmZmZmZjAnLFxuICAgICAgICBraGFraTogJ2YwZTY4YycsXG4gICAgICAgIGxhdmVuZGVyOiAnZTZlNmZhJyxcbiAgICAgICAgbGF2ZW5kZXJibHVzaDogJ2ZmZjBmNScsXG4gICAgICAgIGxhd25ncmVlbjogJzdjZmMwMCcsXG4gICAgICAgIGxlbW9uY2hpZmZvbjogJ2ZmZmFjZCcsXG4gICAgICAgIGxpZ2h0Ymx1ZTogJ2FkZDhlNicsXG4gICAgICAgIGxpZ2h0Y29yYWw6ICdmMDgwODAnLFxuICAgICAgICBsaWdodGN5YW46ICdlMGZmZmYnLFxuICAgICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJ2ZhZmFkMicsXG4gICAgICAgIGxpZ2h0Z3JleTogJ2QzZDNkMycsXG4gICAgICAgIGxpZ2h0Z3JlZW46ICc5MGVlOTAnLFxuICAgICAgICBsaWdodHBpbms6ICdmZmI2YzEnLFxuICAgICAgICBsaWdodHNhbG1vbjogJ2ZmYTA3YScsXG4gICAgICAgIGxpZ2h0c2VhZ3JlZW46ICcyMGIyYWEnLFxuICAgICAgICBsaWdodHNreWJsdWU6ICc4N2NlZmEnLFxuICAgICAgICBsaWdodHNsYXRlYmx1ZTogJzg0NzBmZicsXG4gICAgICAgIGxpZ2h0c2xhdGVncmF5OiAnNzc4ODk5JyxcbiAgICAgICAgbGlnaHRzdGVlbGJsdWU6ICdiMGM0ZGUnLFxuICAgICAgICBsaWdodHllbGxvdzogJ2ZmZmZlMCcsXG4gICAgICAgIGxpbWU6ICcwMGZmMDAnLFxuICAgICAgICBsaW1lZ3JlZW46ICczMmNkMzInLFxuICAgICAgICBsaW5lbjogJ2ZhZjBlNicsXG4gICAgICAgIG1hZ2VudGE6ICdmZjAwZmYnLFxuICAgICAgICBtYXJvb246ICc4MDAwMDAnLFxuICAgICAgICBtZWRpdW1hcXVhbWFyaW5lOiAnNjZjZGFhJyxcbiAgICAgICAgbWVkaXVtYmx1ZTogJzAwMDBjZCcsXG4gICAgICAgIG1lZGl1bW9yY2hpZDogJ2JhNTVkMycsXG4gICAgICAgIG1lZGl1bXB1cnBsZTogJzkzNzBkOCcsXG4gICAgICAgIG1lZGl1bXNlYWdyZWVuOiAnM2NiMzcxJyxcbiAgICAgICAgbWVkaXVtc2xhdGVibHVlOiAnN2I2OGVlJyxcbiAgICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46ICcwMGZhOWEnLFxuICAgICAgICBtZWRpdW10dXJxdW9pc2U6ICc0OGQxY2MnLFxuICAgICAgICBtZWRpdW12aW9sZXRyZWQ6ICdjNzE1ODUnLFxuICAgICAgICBtaWRuaWdodGJsdWU6ICcxOTE5NzAnLFxuICAgICAgICBtaW50Y3JlYW06ICdmNWZmZmEnLFxuICAgICAgICBtaXN0eXJvc2U6ICdmZmU0ZTEnLFxuICAgICAgICBtb2NjYXNpbjogJ2ZmZTRiNScsXG4gICAgICAgIG5hdmFqb3doaXRlOiAnZmZkZWFkJyxcbiAgICAgICAgbmF2eTogJzAwMDA4MCcsXG4gICAgICAgIG9sZGxhY2U6ICdmZGY1ZTYnLFxuICAgICAgICBvbGl2ZTogJzgwODAwMCcsXG4gICAgICAgIG9saXZlZHJhYjogJzZiOGUyMycsXG4gICAgICAgIG9yYW5nZTogJ2ZmYTUwMCcsXG4gICAgICAgIG9yYW5nZXJlZDogJ2ZmNDUwMCcsXG4gICAgICAgIG9yY2hpZDogJ2RhNzBkNicsXG4gICAgICAgIHBhbGVnb2xkZW5yb2Q6ICdlZWU4YWEnLFxuICAgICAgICBwYWxlZ3JlZW46ICc5OGZiOTgnLFxuICAgICAgICBwYWxldHVycXVvaXNlOiAnYWZlZWVlJyxcbiAgICAgICAgcGFsZXZpb2xldHJlZDogJ2Q4NzA5MycsXG4gICAgICAgIHBhcGF5YXdoaXA6ICdmZmVmZDUnLFxuICAgICAgICBwZWFjaHB1ZmY6ICdmZmRhYjknLFxuICAgICAgICBwZXJ1OiAnY2Q4NTNmJyxcbiAgICAgICAgcGluazogJ2ZmYzBjYicsXG4gICAgICAgIHBsdW06ICdkZGEwZGQnLFxuICAgICAgICBwb3dkZXJibHVlOiAnYjBlMGU2JyxcbiAgICAgICAgcHVycGxlOiAnODAwMDgwJyxcbiAgICAgICAgcmViZWNjYXB1cnBsZTogJzY2MzM5OScsXG4gICAgICAgIHJlZDogJ2ZmMDAwMCcsXG4gICAgICAgIHJvc3licm93bjogJ2JjOGY4ZicsXG4gICAgICAgIHJveWFsYmx1ZTogJzQxNjllMScsXG4gICAgICAgIHNhZGRsZWJyb3duOiAnOGI0NTEzJyxcbiAgICAgICAgc2FsbW9uOiAnZmE4MDcyJyxcbiAgICAgICAgc2FuZHlicm93bjogJ2Y0YTQ2MCcsXG4gICAgICAgIHNlYWdyZWVuOiAnMmU4YjU3JyxcbiAgICAgICAgc2Vhc2hlbGw6ICdmZmY1ZWUnLFxuICAgICAgICBzaWVubmE6ICdhMDUyMmQnLFxuICAgICAgICBzaWx2ZXI6ICdjMGMwYzAnLFxuICAgICAgICBza3libHVlOiAnODdjZWViJyxcbiAgICAgICAgc2xhdGVibHVlOiAnNmE1YWNkJyxcbiAgICAgICAgc2xhdGVncmF5OiAnNzA4MDkwJyxcbiAgICAgICAgc25vdzogJ2ZmZmFmYScsXG4gICAgICAgIHNwcmluZ2dyZWVuOiAnMDBmZjdmJyxcbiAgICAgICAgc3RlZWxibHVlOiAnNDY4MmI0JyxcbiAgICAgICAgdGFuOiAnZDJiNDhjJyxcbiAgICAgICAgdGVhbDogJzAwODA4MCcsXG4gICAgICAgIHRoaXN0bGU6ICdkOGJmZDgnLFxuICAgICAgICB0b21hdG86ICdmZjYzNDcnLFxuICAgICAgICB0dXJxdW9pc2U6ICc0MGUwZDAnLFxuICAgICAgICB2aW9sZXQ6ICdlZTgyZWUnLFxuICAgICAgICB2aW9sZXRyZWQ6ICdkMDIwOTAnLFxuICAgICAgICB3aGVhdDogJ2Y1ZGViMycsXG4gICAgICAgIHdoaXRlOiAnZmZmZmZmJyxcbiAgICAgICAgd2hpdGVzbW9rZTogJ2Y1ZjVmNScsXG4gICAgICAgIHllbGxvdzogJ2ZmZmYwMCcsXG4gICAgICAgIHllbGxvd2dyZWVuOiAnOWFjZDMyJ1xuICAgIH07XG4gICAgY29sb3Jfc3RyaW5nID0gc2ltcGxlX2NvbG9yc1tjb2xvcl9zdHJpbmddIHx8IGNvbG9yX3N0cmluZztcbiAgICAvLyBlbWQgb2Ygc2ltcGxlIHR5cGUtaW4gY29sb3JzXG5cbiAgICAvLyBhcnJheSBvZiBjb2xvciBkZWZpbml0aW9uIG9iamVjdHNcbiAgICB2YXIgY29sb3JfZGVmcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9ecmdiYVxcKChcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKigoPzpcXGQ/XFwuKT9cXGQpXFwpJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJ3JnYmEoMTIzLCAyMzQsIDQ1LCAwLjgpJywgJ3JnYmEoMjU1LDIzNCwyNDUsMS4wKSddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1szXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoYml0c1s0XSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByZTogL15yZ2JcXCgoXFxkezEsM30pLFxccyooXFxkezEsM30pLFxccyooXFxkezEsM30pXFwpJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJ3JnYigxMjMsIDIzNCwgNDUpJywgJ3JnYigyNTUsMjM0LDI0NSknXSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChiaXRzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1syXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbM10pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9eKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJyMwMGZmMDAnLCAnMzM2Njk5J10sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoYml0cyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1sxXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbM10sIDE2KVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlOiAvXihbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuICAgICAgICAgICAgZXhhbXBsZTogWycjZmIwJywgJ2YwZiddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0gKyBiaXRzWzFdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMl0gKyBiaXRzWzJdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbM10gKyBiaXRzWzNdLCAxNilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXTtcblxuICAgIC8vIHNlYXJjaCB0aHJvdWdoIHRoZSBkZWZpbml0aW9ucyB0byBmaW5kIGEgbWF0Y2hcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yX2RlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlID0gY29sb3JfZGVmc1tpXS5yZTtcbiAgICAgICAgdmFyIHByb2Nlc3NvciA9IGNvbG9yX2RlZnNbaV0ucHJvY2VzcztcbiAgICAgICAgdmFyIGJpdHMgPSByZS5leGVjKGNvbG9yX3N0cmluZyk7XG4gICAgICAgIGlmIChiaXRzKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbHMgPSBwcm9jZXNzb3IoYml0cyk7XG4gICAgICAgICAgICB0aGlzLnIgPSBjaGFubmVsc1swXTtcbiAgICAgICAgICAgIHRoaXMuZyA9IGNoYW5uZWxzWzFdO1xuICAgICAgICAgICAgdGhpcy5iID0gY2hhbm5lbHNbMl07XG4gICAgICAgICAgICBpZiAoY2hhbm5lbHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEgPSBjaGFubmVsc1szXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZS9jbGVhbnVwIHZhbHVlc1xuICAgIHRoaXMuciA9ICh0aGlzLnIgPCAwIHx8IGlzTmFOKHRoaXMucikpID8gMCA6ICgodGhpcy5yID4gMjU1KSA/IDI1NSA6IHRoaXMucik7XG4gICAgdGhpcy5nID0gKHRoaXMuZyA8IDAgfHwgaXNOYU4odGhpcy5nKSkgPyAwIDogKCh0aGlzLmcgPiAyNTUpID8gMjU1IDogdGhpcy5nKTtcbiAgICB0aGlzLmIgPSAodGhpcy5iIDwgMCB8fCBpc05hTih0aGlzLmIpKSA/IDAgOiAoKHRoaXMuYiA+IDI1NSkgPyAyNTUgOiB0aGlzLmIpO1xuICAgIHRoaXMuYWxwaGEgPSAodGhpcy5hbHBoYSA8IDApID8gMCA6ICgodGhpcy5hbHBoYSA+IDEuMCB8fCBpc05hTih0aGlzLmFscGhhKSkgPyAxLjAgOiB0aGlzLmFscGhhKTtcblxuICAgIC8vIHNvbWUgZ2V0dGVyc1xuICAgIHRoaXMudG9SR0IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyB0aGlzLnIgKyAnLCAnICsgdGhpcy5nICsgJywgJyArIHRoaXMuYiArICcpJztcbiAgICB9XG4gICAgdGhpcy50b1JHQkEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAncmdiYSgnICsgdGhpcy5yICsgJywgJyArIHRoaXMuZyArICcsICcgKyB0aGlzLmIgKyAnLCAnICsgdGhpcy5hbHBoYSArICcpJztcbiAgICB9XG4gICAgdGhpcy50b0hleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnIudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgZyA9IHRoaXMuZy50b1N0cmluZygxNik7XG4gICAgICAgIHZhciBiID0gdGhpcy5iLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHIubGVuZ3RoID09IDEpIHIgPSAnMCcgKyByO1xuICAgICAgICBpZiAoZy5sZW5ndGggPT0gMSkgZyA9ICcwJyArIGc7XG4gICAgICAgIGlmIChiLmxlbmd0aCA9PSAxKSBiID0gJzAnICsgYjtcbiAgICAgICAgcmV0dXJuICcjJyArIHIgKyBnICsgYjtcbiAgICB9XG5cbiAgICAvLyBoZWxwXG4gICAgdGhpcy5nZXRIZWxwWE1MID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBleGFtcGxlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAvLyBhZGQgcmVnZXhwc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yX2RlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleGFtcGxlID0gY29sb3JfZGVmc1tpXS5leGFtcGxlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleGFtcGxlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZXhhbXBsZXNbZXhhbXBsZXMubGVuZ3RoXSA9IGV4YW1wbGVbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHR5cGUtaW4gY29sb3JzXG4gICAgICAgIGZvciAodmFyIHNjIGluIHNpbXBsZV9jb2xvcnMpIHtcbiAgICAgICAgICAgIGV4YW1wbGVzW2V4YW1wbGVzLmxlbmd0aF0gPSBzYztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICB4bWwuc2V0QXR0cmlidXRlKCdpZCcsICdyZ2Jjb2xvci1leGFtcGxlcycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4YW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2l0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2NvbG9yID0gbmV3IFJHQkNvbG9yKGV4YW1wbGVzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhhbXBsZV9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBleGFtcGxlX2Rpdi5zdHlsZS5jc3NUZXh0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW46IDNweDsgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnYm9yZGVyOiAxcHggc29saWQgYmxhY2s7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2JhY2tncm91bmQ6JyArIGxpc3RfY29sb3IudG9IZXgoKSArICc7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2NvbG9yOicgKyBsaXN0X2NvbG9yLnRvSGV4KClcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgZXhhbXBsZV9kaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3Rlc3QnKSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RfaXRlbV92YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgICAgICAgICAgICAgICAgICAnICcgKyBleGFtcGxlc1tpXSArICcgLT4gJyArIGxpc3RfY29sb3IudG9SR0IoKSArICcgLT4gJyArIGxpc3RfY29sb3IudG9IZXgoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGlzdF9pdGVtLmFwcGVuZENoaWxkKGV4YW1wbGVfZGl2KTtcbiAgICAgICAgICAgICAgICBsaXN0X2l0ZW0uYXBwZW5kQ2hpbGQobGlzdF9pdGVtX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB4bWwuYXBwZW5kQ2hpbGQobGlzdF9pdGVtKTtcblxuICAgICAgICAgICAgfSBjYXRjaChlKXt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhtbDtcblxuICAgIH1cblxufVxuIiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAtLSB1c2VkIGZvciBjYWxjdWxhdGlvbnMgKi9cblxuLyogZXNsaW50LWRpc2FibGUgdW5pY29ybi9wcmVmZXItcXVlcnktc2VsZWN0b3IgLS0gYWltaW5nIGF0XG4gIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkgKi9cblxuLyoqXG4qIFN0YWNrQmx1ciAtIGEgZmFzdCBhbG1vc3QgR2F1c3NpYW4gQmx1ciBGb3IgQ2FudmFzXG4qXG4qIEluIGNhc2UgeW91IGZpbmQgdGhpcyBjbGFzcyB1c2VmdWwgLSBlc3BlY2lhbGx5IGluIGNvbW1lcmNpYWwgcHJvamVjdHMgLVxuKiBJIGFtIG5vdCB0b3RhbGx5IHVuaGFwcHkgZm9yIGEgc21hbGwgZG9uYXRpb24gdG8gbXkgUGF5UGFsIGFjY291bnRcbiogbWFyaW9AcXVhc2ltb25kby5kZVxuKlxuKiBPciBzdXBwb3J0IG1lIG9uIGZsYXR0cjpcbioge0BsaW5rIGh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdH0uXG4qXG4qIEBtb2R1bGUgU3RhY2tCbHVyXG4qIEBhdXRob3IgTWFyaW8gS2xpbmdlbWFublxuKiBDb250YWN0OiBtYXJpb0BxdWFzaW1vbmRvLmNvbVxuKiBXZWJzaXRlOiB7QGxpbmsgaHR0cDovL3d3dy5xdWFzaW1vbmRvLmNvbS9TdGFja0JsdXJGb3JDYW52YXMvU3RhY2tCbHVyRGVtby5odG1sfVxuKiBUd2l0dGVyOiBAcXVhc2ltb25kb1xuKlxuKiBAY29weXJpZ2h0IChjKSAyMDEwIE1hcmlvIEtsaW5nZW1hbm5cbipcbiogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4qIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiogY29uZGl0aW9uczpcbipcbiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4qIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cbnZhciBtdWxUYWJsZSA9IFs1MTIsIDUxMiwgNDU2LCA1MTIsIDMyOCwgNDU2LCAzMzUsIDUxMiwgNDA1LCAzMjgsIDI3MSwgNDU2LCAzODgsIDMzNSwgMjkyLCA1MTIsIDQ1NCwgNDA1LCAzNjQsIDMyOCwgMjk4LCAyNzEsIDQ5NiwgNDU2LCA0MjAsIDM4OCwgMzYwLCAzMzUsIDMxMiwgMjkyLCAyNzMsIDUxMiwgNDgyLCA0NTQsIDQyOCwgNDA1LCAzODMsIDM2NCwgMzQ1LCAzMjgsIDMxMiwgMjk4LCAyODQsIDI3MSwgMjU5LCA0OTYsIDQ3NSwgNDU2LCA0MzcsIDQyMCwgNDA0LCAzODgsIDM3NCwgMzYwLCAzNDcsIDMzNSwgMzIzLCAzMTIsIDMwMiwgMjkyLCAyODIsIDI3MywgMjY1LCA1MTIsIDQ5NywgNDgyLCA0NjgsIDQ1NCwgNDQxLCA0MjgsIDQxNywgNDA1LCAzOTQsIDM4MywgMzczLCAzNjQsIDM1NCwgMzQ1LCAzMzcsIDMyOCwgMzIwLCAzMTIsIDMwNSwgMjk4LCAyOTEsIDI4NCwgMjc4LCAyNzEsIDI2NSwgMjU5LCA1MDcsIDQ5NiwgNDg1LCA0NzUsIDQ2NSwgNDU2LCA0NDYsIDQzNywgNDI4LCA0MjAsIDQxMiwgNDA0LCAzOTYsIDM4OCwgMzgxLCAzNzQsIDM2NywgMzYwLCAzNTQsIDM0NywgMzQxLCAzMzUsIDMyOSwgMzIzLCAzMTgsIDMxMiwgMzA3LCAzMDIsIDI5NywgMjkyLCAyODcsIDI4MiwgMjc4LCAyNzMsIDI2OSwgMjY1LCAyNjEsIDUxMiwgNTA1LCA0OTcsIDQ4OSwgNDgyLCA0NzUsIDQ2OCwgNDYxLCA0NTQsIDQ0NywgNDQxLCA0MzUsIDQyOCwgNDIyLCA0MTcsIDQxMSwgNDA1LCAzOTksIDM5NCwgMzg5LCAzODMsIDM3OCwgMzczLCAzNjgsIDM2NCwgMzU5LCAzNTQsIDM1MCwgMzQ1LCAzNDEsIDMzNywgMzMyLCAzMjgsIDMyNCwgMzIwLCAzMTYsIDMxMiwgMzA5LCAzMDUsIDMwMSwgMjk4LCAyOTQsIDI5MSwgMjg3LCAyODQsIDI4MSwgMjc4LCAyNzQsIDI3MSwgMjY4LCAyNjUsIDI2MiwgMjU5LCAyNTcsIDUwNywgNTAxLCA0OTYsIDQ5MSwgNDg1LCA0ODAsIDQ3NSwgNDcwLCA0NjUsIDQ2MCwgNDU2LCA0NTEsIDQ0NiwgNDQyLCA0MzcsIDQzMywgNDI4LCA0MjQsIDQyMCwgNDE2LCA0MTIsIDQwOCwgNDA0LCA0MDAsIDM5NiwgMzkyLCAzODgsIDM4NSwgMzgxLCAzNzcsIDM3NCwgMzcwLCAzNjcsIDM2MywgMzYwLCAzNTcsIDM1NCwgMzUwLCAzNDcsIDM0NCwgMzQxLCAzMzgsIDMzNSwgMzMyLCAzMjksIDMyNiwgMzIzLCAzMjAsIDMxOCwgMzE1LCAzMTIsIDMxMCwgMzA3LCAzMDQsIDMwMiwgMjk5LCAyOTcsIDI5NCwgMjkyLCAyODksIDI4NywgMjg1LCAyODIsIDI4MCwgMjc4LCAyNzUsIDI3MywgMjcxLCAyNjksIDI2NywgMjY1LCAyNjMsIDI2MSwgMjU5XTtcbnZhciBzaGdUYWJsZSA9IFs5LCAxMSwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjRdO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fSBpbWdcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7RmxvYXR9IHJhZGl1c1xuICogQHBhcmFtIHtib29sZWFufSBibHVyQWxwaGFDaGFubmVsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZU9mZnNldFxuICogQHBhcmFtIHtib29sZWFufSBza2lwU3R5bGVzXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3NJbWFnZShpbWcsIGNhbnZhcywgcmFkaXVzLCBibHVyQWxwaGFDaGFubmVsLCB1c2VPZmZzZXQsIHNraXBTdHlsZXMpIHtcbiAgaWYgKHR5cGVvZiBpbWcgPT09ICdzdHJpbmcnKSB7XG4gICAgaW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaW1nKTtcbiAgfVxuXG4gIGlmICghaW1nIHx8ICEoJ25hdHVyYWxXaWR0aCcgaW4gaW1nKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkaW1lbnNpb25UeXBlID0gdXNlT2Zmc2V0ID8gJ29mZnNldCcgOiAnbmF0dXJhbCc7XG4gIHZhciB3ID0gaW1nW2RpbWVuc2lvblR5cGUgKyAnV2lkdGgnXTtcbiAgdmFyIGggPSBpbWdbZGltZW5zaW9uVHlwZSArICdIZWlnaHQnXTtcblxuICBpZiAodHlwZW9mIGNhbnZhcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpO1xuICB9XG5cbiAgaWYgKCFjYW52YXMgfHwgISgnZ2V0Q29udGV4dCcgaW4gY2FudmFzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghc2tpcFN0eWxlcykge1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgfVxuXG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcbiAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWcubmF0dXJhbFdpZHRoLCBpbWcubmF0dXJhbEhlaWdodCwgMCwgMCwgdywgaCk7XG5cbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDwgMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChibHVyQWxwaGFDaGFubmVsKSB7XG4gICAgcHJvY2Vzc0NhbnZhc1JHQkEoY2FudmFzLCAwLCAwLCB3LCBoLCByYWRpdXMpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3NDYW52YXNSR0IoY2FudmFzLCAwLCAwLCB3LCBoLCByYWRpdXMpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gdG9wWFxuICogQHBhcmFtIHtJbnRlZ2VyfSB0b3BZXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGhlaWdodFxuICogQHRocm93cyB7RXJyb3J8VHlwZUVycm9yfVxuICogQHJldHVybnMge0ltYWdlRGF0YX0gU2VlIHtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jYW52YXMuaHRtbCNpbWFnZWRhdGF9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJbWFnZURhdGFGcm9tQ2FudmFzKGNhbnZhcywgdG9wWCwgdG9wWSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAodHlwZW9mIGNhbnZhcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpO1xuICB9XG5cbiAgaWYgKCFjYW52YXMgfHwgX3R5cGVvZihjYW52YXMpICE9PSAnb2JqZWN0JyB8fCAhKCdnZXRDb250ZXh0JyBpbiBjYW52YXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0aW5nIGNhbnZhcyB3aXRoIGBnZXRDb250ZXh0YCBtZXRob2QgJyArICdpbiBwcm9jZXNzQ2FudmFzUkdCKEEpIGNhbGxzIScpO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICB0cnkge1xuICAgIHJldHVybiBjb250ZXh0LmdldEltYWdlRGF0YSh0b3BYLCB0b3BZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGFjY2VzcyBpbWFnZSBkYXRhOiAnICsgZSk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHRvcFhcbiAqIEBwYXJhbSB7SW50ZWdlcn0gdG9wWVxuICogQHBhcmFtIHtJbnRlZ2VyfSB3aWR0aFxuICogQHBhcmFtIHtJbnRlZ2VyfSBoZWlnaHRcbiAqIEBwYXJhbSB7RmxvYXR9IHJhZGl1c1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5cbmZ1bmN0aW9uIHByb2Nlc3NDYW52YXNSR0JBKGNhbnZhcywgdG9wWCwgdG9wWSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8IDEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByYWRpdXMgfD0gMDtcbiAgdmFyIGltYWdlRGF0YSA9IGdldEltYWdlRGF0YUZyb21DYW52YXMoY2FudmFzLCB0b3BYLCB0b3BZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgaW1hZ2VEYXRhID0gcHJvY2Vzc0ltYWdlRGF0YVJHQkEoaW1hZ2VEYXRhLCB0b3BYLCB0b3BZLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCB0b3BYLCB0b3BZKTtcbn1cbi8qKlxuICogQHBhcmFtIHtJbWFnZURhdGF9IGltYWdlRGF0YVxuICogQHBhcmFtIHtJbnRlZ2VyfSB0b3BYXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHRvcFlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gd2lkdGhcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge0Zsb2F0fSByYWRpdXNcbiAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gKi9cblxuXG5mdW5jdGlvbiBwcm9jZXNzSW1hZ2VEYXRhUkdCQShpbWFnZURhdGEsIHRvcFgsIHRvcFksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICB2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGE7XG4gIHZhciBkaXYgPSAyICogcmFkaXVzICsgMTsgLy8gY29uc3QgdzQgPSB3aWR0aCA8PCAyO1xuXG4gIHZhciB3aWR0aE1pbnVzMSA9IHdpZHRoIC0gMTtcbiAgdmFyIGhlaWdodE1pbnVzMSA9IGhlaWdodCAtIDE7XG4gIHZhciByYWRpdXNQbHVzMSA9IHJhZGl1cyArIDE7XG4gIHZhciBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqIChyYWRpdXNQbHVzMSArIDEpIC8gMjtcbiAgdmFyIHN0YWNrU3RhcnQgPSBuZXcgQmx1clN0YWNrKCk7XG4gIHZhciBzdGFjayA9IHN0YWNrU3RhcnQ7XG4gIHZhciBzdGFja0VuZDtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGRpdjsgaSsrKSB7XG4gICAgc3RhY2sgPSBzdGFjay5uZXh0ID0gbmV3IEJsdXJTdGFjaygpO1xuXG4gICAgaWYgKGkgPT09IHJhZGl1c1BsdXMxKSB7XG4gICAgICBzdGFja0VuZCA9IHN0YWNrO1xuICAgIH1cbiAgfVxuXG4gIHN0YWNrLm5leHQgPSBzdGFja1N0YXJ0O1xuICB2YXIgc3RhY2tJbiA9IG51bGwsXG4gICAgICBzdGFja091dCA9IG51bGwsXG4gICAgICB5dyA9IDAsXG4gICAgICB5aSA9IDA7XG4gIHZhciBtdWxTdW0gPSBtdWxUYWJsZVtyYWRpdXNdO1xuICB2YXIgc2hnU3VtID0gc2hnVGFibGVbcmFkaXVzXTtcblxuICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuICAgIHZhciBwciA9IHBpeGVsc1t5aV0sXG4gICAgICAgIHBnID0gcGl4ZWxzW3lpICsgMV0sXG4gICAgICAgIHBiID0gcGl4ZWxzW3lpICsgMl0sXG4gICAgICAgIHBhID0gcGl4ZWxzW3lpICsgM107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmFkaXVzUGx1czE7IF9pKyspIHtcbiAgICAgIHN0YWNrLnIgPSBwcjtcbiAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgIHN0YWNrLmEgPSBwYTtcbiAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICB9XG5cbiAgICB2YXIgckluU3VtID0gMCxcbiAgICAgICAgZ0luU3VtID0gMCxcbiAgICAgICAgYkluU3VtID0gMCxcbiAgICAgICAgYUluU3VtID0gMCxcbiAgICAgICAgck91dFN1bSA9IHJhZGl1c1BsdXMxICogcHIsXG4gICAgICAgIGdPdXRTdW0gPSByYWRpdXNQbHVzMSAqIHBnLFxuICAgICAgICBiT3V0U3VtID0gcmFkaXVzUGx1czEgKiBwYixcbiAgICAgICAgYU91dFN1bSA9IHJhZGl1c1BsdXMxICogcGEsXG4gICAgICAgIHJTdW0gPSBzdW1GYWN0b3IgKiBwcixcbiAgICAgICAgZ1N1bSA9IHN1bUZhY3RvciAqIHBnLFxuICAgICAgICBiU3VtID0gc3VtRmFjdG9yICogcGIsXG4gICAgICAgIGFTdW0gPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgIGZvciAodmFyIF9pMiA9IDE7IF9pMiA8IHJhZGl1c1BsdXMxOyBfaTIrKykge1xuICAgICAgdmFyIHAgPSB5aSArICgod2lkdGhNaW51czEgPCBfaTIgPyB3aWR0aE1pbnVzMSA6IF9pMikgPDwgMik7XG4gICAgICB2YXIgciA9IHBpeGVsc1twXSxcbiAgICAgICAgICBnID0gcGl4ZWxzW3AgKyAxXSxcbiAgICAgICAgICBiID0gcGl4ZWxzW3AgKyAyXSxcbiAgICAgICAgICBhID0gcGl4ZWxzW3AgKyAzXTtcbiAgICAgIHZhciByYnMgPSByYWRpdXNQbHVzMSAtIF9pMjtcbiAgICAgIHJTdW0gKz0gKHN0YWNrLnIgPSByKSAqIHJicztcbiAgICAgIGdTdW0gKz0gKHN0YWNrLmcgPSBnKSAqIHJicztcbiAgICAgIGJTdW0gKz0gKHN0YWNrLmIgPSBiKSAqIHJicztcbiAgICAgIGFTdW0gKz0gKHN0YWNrLmEgPSBhKSAqIHJicztcbiAgICAgIHJJblN1bSArPSByO1xuICAgICAgZ0luU3VtICs9IGc7XG4gICAgICBiSW5TdW0gKz0gYjtcbiAgICAgIGFJblN1bSArPSBhO1xuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgIH1cblxuICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG5cbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgIHZhciBwYUluaXRpYWwgPSBhU3VtICogbXVsU3VtID4+IHNoZ1N1bTtcbiAgICAgIHBpeGVsc1t5aSArIDNdID0gcGFJbml0aWFsO1xuXG4gICAgICBpZiAocGFJbml0aWFsICE9PSAwKSB7XG4gICAgICAgIHZhciBfYTIgPSAyNTUgLyBwYUluaXRpYWw7XG5cbiAgICAgICAgcGl4ZWxzW3lpXSA9IChyU3VtICogbXVsU3VtID4+IHNoZ1N1bSkgKiBfYTI7XG4gICAgICAgIHBpeGVsc1t5aSArIDFdID0gKGdTdW0gKiBtdWxTdW0gPj4gc2hnU3VtKSAqIF9hMjtcbiAgICAgICAgcGl4ZWxzW3lpICsgMl0gPSAoYlN1bSAqIG11bFN1bSA+PiBzaGdTdW0pICogX2EyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl4ZWxzW3lpXSA9IHBpeGVsc1t5aSArIDFdID0gcGl4ZWxzW3lpICsgMl0gPSAwO1xuICAgICAgfVxuXG4gICAgICByU3VtIC09IHJPdXRTdW07XG4gICAgICBnU3VtIC09IGdPdXRTdW07XG4gICAgICBiU3VtIC09IGJPdXRTdW07XG4gICAgICBhU3VtIC09IGFPdXRTdW07XG4gICAgICByT3V0U3VtIC09IHN0YWNrSW4ucjtcbiAgICAgIGdPdXRTdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgYk91dFN1bSAtPSBzdGFja0luLmI7XG4gICAgICBhT3V0U3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgdmFyIF9wID0geCArIHJhZGl1cyArIDE7XG5cbiAgICAgIF9wID0geXcgKyAoX3AgPCB3aWR0aE1pbnVzMSA/IF9wIDogd2lkdGhNaW51czEpIDw8IDI7XG4gICAgICBySW5TdW0gKz0gc3RhY2tJbi5yID0gcGl4ZWxzW19wXTtcbiAgICAgIGdJblN1bSArPSBzdGFja0luLmcgPSBwaXhlbHNbX3AgKyAxXTtcbiAgICAgIGJJblN1bSArPSBzdGFja0luLmIgPSBwaXhlbHNbX3AgKyAyXTtcbiAgICAgIGFJblN1bSArPSBzdGFja0luLmEgPSBwaXhlbHNbX3AgKyAzXTtcbiAgICAgIHJTdW0gKz0gckluU3VtO1xuICAgICAgZ1N1bSArPSBnSW5TdW07XG4gICAgICBiU3VtICs9IGJJblN1bTtcbiAgICAgIGFTdW0gKz0gYUluU3VtO1xuICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcbiAgICAgIHZhciBfc3RhY2tPdXQgPSBzdGFja091dCxcbiAgICAgICAgICBfciA9IF9zdGFja091dC5yLFxuICAgICAgICAgIF9nID0gX3N0YWNrT3V0LmcsXG4gICAgICAgICAgX2IgPSBfc3RhY2tPdXQuYixcbiAgICAgICAgICBfYSA9IF9zdGFja091dC5hO1xuICAgICAgck91dFN1bSArPSBfcjtcbiAgICAgIGdPdXRTdW0gKz0gX2c7XG4gICAgICBiT3V0U3VtICs9IF9iO1xuICAgICAgYU91dFN1bSArPSBfYTtcbiAgICAgIHJJblN1bSAtPSBfcjtcbiAgICAgIGdJblN1bSAtPSBfZztcbiAgICAgIGJJblN1bSAtPSBfYjtcbiAgICAgIGFJblN1bSAtPSBfYTtcbiAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcbiAgICAgIHlpICs9IDQ7XG4gICAgfVxuXG4gICAgeXcgKz0gd2lkdGg7XG4gIH1cblxuICBmb3IgKHZhciBfeCA9IDA7IF94IDwgd2lkdGg7IF94KyspIHtcbiAgICB5aSA9IF94IDw8IDI7XG5cbiAgICB2YXIgX3ByID0gcGl4ZWxzW3lpXSxcbiAgICAgICAgX3BnID0gcGl4ZWxzW3lpICsgMV0sXG4gICAgICAgIF9wYiA9IHBpeGVsc1t5aSArIDJdLFxuICAgICAgICBfcGEgPSBwaXhlbHNbeWkgKyAzXSxcbiAgICAgICAgX3JPdXRTdW0gPSByYWRpdXNQbHVzMSAqIF9wcixcbiAgICAgICAgX2dPdXRTdW0gPSByYWRpdXNQbHVzMSAqIF9wZyxcbiAgICAgICAgX2JPdXRTdW0gPSByYWRpdXNQbHVzMSAqIF9wYixcbiAgICAgICAgX2FPdXRTdW0gPSByYWRpdXNQbHVzMSAqIF9wYSxcbiAgICAgICAgX3JTdW0gPSBzdW1GYWN0b3IgKiBfcHIsXG4gICAgICAgIF9nU3VtID0gc3VtRmFjdG9yICogX3BnLFxuICAgICAgICBfYlN1bSA9IHN1bUZhY3RvciAqIF9wYixcbiAgICAgICAgX2FTdW0gPSBzdW1GYWN0b3IgKiBfcGE7XG5cbiAgICBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCByYWRpdXNQbHVzMTsgX2kzKyspIHtcbiAgICAgIHN0YWNrLnIgPSBfcHI7XG4gICAgICBzdGFjay5nID0gX3BnO1xuICAgICAgc3RhY2suYiA9IF9wYjtcbiAgICAgIHN0YWNrLmEgPSBfcGE7XG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgfVxuXG4gICAgdmFyIHlwID0gd2lkdGg7XG4gICAgdmFyIF9nSW5TdW0gPSAwLFxuICAgICAgICBfYkluU3VtID0gMCxcbiAgICAgICAgX2FJblN1bSA9IDAsXG4gICAgICAgIF9ySW5TdW0gPSAwO1xuXG4gICAgZm9yICh2YXIgX2k0ID0gMTsgX2k0IDw9IHJhZGl1czsgX2k0KyspIHtcbiAgICAgIHlpID0geXAgKyBfeCA8PCAyO1xuXG4gICAgICB2YXIgX3JicyA9IHJhZGl1c1BsdXMxIC0gX2k0O1xuXG4gICAgICBfclN1bSArPSAoc3RhY2suciA9IF9wciA9IHBpeGVsc1t5aV0pICogX3JicztcbiAgICAgIF9nU3VtICs9IChzdGFjay5nID0gX3BnID0gcGl4ZWxzW3lpICsgMV0pICogX3JicztcbiAgICAgIF9iU3VtICs9IChzdGFjay5iID0gX3BiID0gcGl4ZWxzW3lpICsgMl0pICogX3JicztcbiAgICAgIF9hU3VtICs9IChzdGFjay5hID0gX3BhID0gcGl4ZWxzW3lpICsgM10pICogX3JicztcbiAgICAgIF9ySW5TdW0gKz0gX3ByO1xuICAgICAgX2dJblN1bSArPSBfcGc7XG4gICAgICBfYkluU3VtICs9IF9wYjtcbiAgICAgIF9hSW5TdW0gKz0gX3BhO1xuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuXG4gICAgICBpZiAoX2k0IDwgaGVpZ2h0TWludXMxKSB7XG4gICAgICAgIHlwICs9IHdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHlpID0gX3g7XG4gICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcblxuICAgIGZvciAodmFyIF95ID0gMDsgX3kgPCBoZWlnaHQ7IF95KyspIHtcbiAgICAgIHZhciBfcDIgPSB5aSA8PCAyO1xuXG4gICAgICBwaXhlbHNbX3AyICsgM10gPSBfcGEgPSBfYVN1bSAqIG11bFN1bSA+PiBzaGdTdW07XG5cbiAgICAgIGlmIChfcGEgPiAwKSB7XG4gICAgICAgIF9wYSA9IDI1NSAvIF9wYTtcbiAgICAgICAgcGl4ZWxzW19wMl0gPSAoX3JTdW0gKiBtdWxTdW0gPj4gc2hnU3VtKSAqIF9wYTtcbiAgICAgICAgcGl4ZWxzW19wMiArIDFdID0gKF9nU3VtICogbXVsU3VtID4+IHNoZ1N1bSkgKiBfcGE7XG4gICAgICAgIHBpeGVsc1tfcDIgKyAyXSA9IChfYlN1bSAqIG11bFN1bSA+PiBzaGdTdW0pICogX3BhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl4ZWxzW19wMl0gPSBwaXhlbHNbX3AyICsgMV0gPSBwaXhlbHNbX3AyICsgMl0gPSAwO1xuICAgICAgfVxuXG4gICAgICBfclN1bSAtPSBfck91dFN1bTtcbiAgICAgIF9nU3VtIC09IF9nT3V0U3VtO1xuICAgICAgX2JTdW0gLT0gX2JPdXRTdW07XG4gICAgICBfYVN1bSAtPSBfYU91dFN1bTtcbiAgICAgIF9yT3V0U3VtIC09IHN0YWNrSW4ucjtcbiAgICAgIF9nT3V0U3VtIC09IHN0YWNrSW4uZztcbiAgICAgIF9iT3V0U3VtIC09IHN0YWNrSW4uYjtcbiAgICAgIF9hT3V0U3VtIC09IHN0YWNrSW4uYTtcbiAgICAgIF9wMiA9IF94ICsgKChfcDIgPSBfeSArIHJhZGl1c1BsdXMxKSA8IGhlaWdodE1pbnVzMSA/IF9wMiA6IGhlaWdodE1pbnVzMSkgKiB3aWR0aCA8PCAyO1xuICAgICAgX3JTdW0gKz0gX3JJblN1bSArPSBzdGFja0luLnIgPSBwaXhlbHNbX3AyXTtcbiAgICAgIF9nU3VtICs9IF9nSW5TdW0gKz0gc3RhY2tJbi5nID0gcGl4ZWxzW19wMiArIDFdO1xuICAgICAgX2JTdW0gKz0gX2JJblN1bSArPSBzdGFja0luLmIgPSBwaXhlbHNbX3AyICsgMl07XG4gICAgICBfYVN1bSArPSBfYUluU3VtICs9IHN0YWNrSW4uYSA9IHBpeGVsc1tfcDIgKyAzXTtcbiAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG4gICAgICBfck91dFN1bSArPSBfcHIgPSBzdGFja091dC5yO1xuICAgICAgX2dPdXRTdW0gKz0gX3BnID0gc3RhY2tPdXQuZztcbiAgICAgIF9iT3V0U3VtICs9IF9wYiA9IHN0YWNrT3V0LmI7XG4gICAgICBfYU91dFN1bSArPSBfcGEgPSBzdGFja091dC5hO1xuICAgICAgX3JJblN1bSAtPSBfcHI7XG4gICAgICBfZ0luU3VtIC09IF9wZztcbiAgICAgIF9iSW5TdW0gLT0gX3BiO1xuICAgICAgX2FJblN1bSAtPSBfcGE7XG4gICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG4gICAgICB5aSArPSB3aWR0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW1hZ2VEYXRhO1xufVxuLyoqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gdG9wWFxuICogQHBhcmFtIHtJbnRlZ2VyfSB0b3BZXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGhlaWdodFxuICogQHBhcmFtIHtGbG9hdH0gcmFkaXVzXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cblxuZnVuY3Rpb24gcHJvY2Vzc0NhbnZhc1JHQihjYW52YXMsIHRvcFgsIHRvcFksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPCAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmFkaXVzIHw9IDA7XG4gIHZhciBpbWFnZURhdGEgPSBnZXRJbWFnZURhdGFGcm9tQ2FudmFzKGNhbnZhcywgdG9wWCwgdG9wWSwgd2lkdGgsIGhlaWdodCk7XG4gIGltYWdlRGF0YSA9IHByb2Nlc3NJbWFnZURhdGFSR0IoaW1hZ2VEYXRhLCB0b3BYLCB0b3BZLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCB0b3BYLCB0b3BZKTtcbn1cbi8qKlxuICogQHBhcmFtIHtJbWFnZURhdGF9IGltYWdlRGF0YVxuICogQHBhcmFtIHtJbnRlZ2VyfSB0b3BYXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHRvcFlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gd2lkdGhcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge0Zsb2F0fSByYWRpdXNcbiAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gKi9cblxuXG5mdW5jdGlvbiBwcm9jZXNzSW1hZ2VEYXRhUkdCKGltYWdlRGF0YSwgdG9wWCwgdG9wWSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIHZhciBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YTtcbiAgdmFyIGRpdiA9IDIgKiByYWRpdXMgKyAxOyAvLyBjb25zdCB3NCA9IHdpZHRoIDw8IDI7XG5cbiAgdmFyIHdpZHRoTWludXMxID0gd2lkdGggLSAxO1xuICB2YXIgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMTtcbiAgdmFyIHJhZGl1c1BsdXMxID0gcmFkaXVzICsgMTtcbiAgdmFyIHN1bUZhY3RvciA9IHJhZGl1c1BsdXMxICogKHJhZGl1c1BsdXMxICsgMSkgLyAyO1xuICB2YXIgc3RhY2tTdGFydCA9IG5ldyBCbHVyU3RhY2soKTtcbiAgdmFyIHN0YWNrID0gc3RhY2tTdGFydDtcbiAgdmFyIHN0YWNrRW5kO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgZGl2OyBpKyspIHtcbiAgICBzdGFjayA9IHN0YWNrLm5leHQgPSBuZXcgQmx1clN0YWNrKCk7XG5cbiAgICBpZiAoaSA9PT0gcmFkaXVzUGx1czEpIHtcbiAgICAgIHN0YWNrRW5kID0gc3RhY2s7XG4gICAgfVxuICB9XG5cbiAgc3RhY2submV4dCA9IHN0YWNrU3RhcnQ7XG4gIHZhciBzdGFja0luID0gbnVsbDtcbiAgdmFyIHN0YWNrT3V0ID0gbnVsbDtcbiAgdmFyIG11bFN1bSA9IG11bFRhYmxlW3JhZGl1c107XG4gIHZhciBzaGdTdW0gPSBzaGdUYWJsZVtyYWRpdXNdO1xuICB2YXIgcCwgcmJzO1xuICB2YXIgeXcgPSAwLFxuICAgICAgeWkgPSAwO1xuXG4gIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICB2YXIgcHIgPSBwaXhlbHNbeWldLFxuICAgICAgICBwZyA9IHBpeGVsc1t5aSArIDFdLFxuICAgICAgICBwYiA9IHBpeGVsc1t5aSArIDJdLFxuICAgICAgICByT3V0U3VtID0gcmFkaXVzUGx1czEgKiBwcixcbiAgICAgICAgZ091dFN1bSA9IHJhZGl1c1BsdXMxICogcGcsXG4gICAgICAgIGJPdXRTdW0gPSByYWRpdXNQbHVzMSAqIHBiLFxuICAgICAgICByU3VtID0gc3VtRmFjdG9yICogcHIsXG4gICAgICAgIGdTdW0gPSBzdW1GYWN0b3IgKiBwZyxcbiAgICAgICAgYlN1bSA9IHN1bUZhY3RvciAqIHBiO1xuICAgIHN0YWNrID0gc3RhY2tTdGFydDtcblxuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHJhZGl1c1BsdXMxOyBfaTUrKykge1xuICAgICAgc3RhY2suciA9IHByO1xuICAgICAgc3RhY2suZyA9IHBnO1xuICAgICAgc3RhY2suYiA9IHBiO1xuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgIH1cblxuICAgIHZhciBySW5TdW0gPSAwLFxuICAgICAgICBnSW5TdW0gPSAwLFxuICAgICAgICBiSW5TdW0gPSAwO1xuXG4gICAgZm9yICh2YXIgX2k2ID0gMTsgX2k2IDwgcmFkaXVzUGx1czE7IF9pNisrKSB7XG4gICAgICBwID0geWkgKyAoKHdpZHRoTWludXMxIDwgX2k2ID8gd2lkdGhNaW51czEgOiBfaTYpIDw8IDIpO1xuICAgICAgclN1bSArPSAoc3RhY2suciA9IHByID0gcGl4ZWxzW3BdKSAqIChyYnMgPSByYWRpdXNQbHVzMSAtIF9pNik7XG4gICAgICBnU3VtICs9IChzdGFjay5nID0gcGcgPSBwaXhlbHNbcCArIDFdKSAqIHJicztcbiAgICAgIGJTdW0gKz0gKHN0YWNrLmIgPSBwYiA9IHBpeGVsc1twICsgMl0pICogcmJzO1xuICAgICAgckluU3VtICs9IHByO1xuICAgICAgZ0luU3VtICs9IHBnO1xuICAgICAgYkluU3VtICs9IHBiO1xuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgIH1cblxuICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG5cbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgIHBpeGVsc1t5aV0gPSByU3VtICogbXVsU3VtID4+IHNoZ1N1bTtcbiAgICAgIHBpeGVsc1t5aSArIDFdID0gZ1N1bSAqIG11bFN1bSA+PiBzaGdTdW07XG4gICAgICBwaXhlbHNbeWkgKyAyXSA9IGJTdW0gKiBtdWxTdW0gPj4gc2hnU3VtO1xuICAgICAgclN1bSAtPSByT3V0U3VtO1xuICAgICAgZ1N1bSAtPSBnT3V0U3VtO1xuICAgICAgYlN1bSAtPSBiT3V0U3VtO1xuICAgICAgck91dFN1bSAtPSBzdGFja0luLnI7XG4gICAgICBnT3V0U3VtIC09IHN0YWNrSW4uZztcbiAgICAgIGJPdXRTdW0gLT0gc3RhY2tJbi5iO1xuICAgICAgcCA9IHl3ICsgKChwID0geCArIHJhZGl1cyArIDEpIDwgd2lkdGhNaW51czEgPyBwIDogd2lkdGhNaW51czEpIDw8IDI7XG4gICAgICBySW5TdW0gKz0gc3RhY2tJbi5yID0gcGl4ZWxzW3BdO1xuICAgICAgZ0luU3VtICs9IHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV07XG4gICAgICBiSW5TdW0gKz0gc3RhY2tJbi5iID0gcGl4ZWxzW3AgKyAyXTtcbiAgICAgIHJTdW0gKz0gckluU3VtO1xuICAgICAgZ1N1bSArPSBnSW5TdW07XG4gICAgICBiU3VtICs9IGJJblN1bTtcbiAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG4gICAgICByT3V0U3VtICs9IHByID0gc3RhY2tPdXQucjtcbiAgICAgIGdPdXRTdW0gKz0gcGcgPSBzdGFja091dC5nO1xuICAgICAgYk91dFN1bSArPSBwYiA9IHN0YWNrT3V0LmI7XG4gICAgICBySW5TdW0gLT0gcHI7XG4gICAgICBnSW5TdW0gLT0gcGc7XG4gICAgICBiSW5TdW0gLT0gcGI7XG4gICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG4gICAgICB5aSArPSA0O1xuICAgIH1cblxuICAgIHl3ICs9IHdpZHRoO1xuICB9XG5cbiAgZm9yICh2YXIgX3gyID0gMDsgX3gyIDwgd2lkdGg7IF94MisrKSB7XG4gICAgeWkgPSBfeDIgPDwgMjtcblxuICAgIHZhciBfcHIyID0gcGl4ZWxzW3lpXSxcbiAgICAgICAgX3BnMiA9IHBpeGVsc1t5aSArIDFdLFxuICAgICAgICBfcGIyID0gcGl4ZWxzW3lpICsgMl0sXG4gICAgICAgIF9yT3V0U3VtMiA9IHJhZGl1c1BsdXMxICogX3ByMixcbiAgICAgICAgX2dPdXRTdW0yID0gcmFkaXVzUGx1czEgKiBfcGcyLFxuICAgICAgICBfYk91dFN1bTIgPSByYWRpdXNQbHVzMSAqIF9wYjIsXG4gICAgICAgIF9yU3VtMiA9IHN1bUZhY3RvciAqIF9wcjIsXG4gICAgICAgIF9nU3VtMiA9IHN1bUZhY3RvciAqIF9wZzIsXG4gICAgICAgIF9iU3VtMiA9IHN1bUZhY3RvciAqIF9wYjI7XG5cbiAgICBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCByYWRpdXNQbHVzMTsgX2k3KyspIHtcbiAgICAgIHN0YWNrLnIgPSBfcHIyO1xuICAgICAgc3RhY2suZyA9IF9wZzI7XG4gICAgICBzdGFjay5iID0gX3BiMjtcbiAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICB9XG5cbiAgICB2YXIgX3JJblN1bTIgPSAwLFxuICAgICAgICBfZ0luU3VtMiA9IDAsXG4gICAgICAgIF9iSW5TdW0yID0gMDtcblxuICAgIGZvciAodmFyIF9pOCA9IDEsIHlwID0gd2lkdGg7IF9pOCA8PSByYWRpdXM7IF9pOCsrKSB7XG4gICAgICB5aSA9IHlwICsgX3gyIDw8IDI7XG4gICAgICBfclN1bTIgKz0gKHN0YWNrLnIgPSBfcHIyID0gcGl4ZWxzW3lpXSkgKiAocmJzID0gcmFkaXVzUGx1czEgLSBfaTgpO1xuICAgICAgX2dTdW0yICs9IChzdGFjay5nID0gX3BnMiA9IHBpeGVsc1t5aSArIDFdKSAqIHJicztcbiAgICAgIF9iU3VtMiArPSAoc3RhY2suYiA9IF9wYjIgPSBwaXhlbHNbeWkgKyAyXSkgKiByYnM7XG4gICAgICBfckluU3VtMiArPSBfcHIyO1xuICAgICAgX2dJblN1bTIgKz0gX3BnMjtcbiAgICAgIF9iSW5TdW0yICs9IF9wYjI7XG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG5cbiAgICAgIGlmIChfaTggPCBoZWlnaHRNaW51czEpIHtcbiAgICAgICAgeXAgKz0gd2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeWkgPSBfeDI7XG4gICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcblxuICAgIGZvciAodmFyIF95MiA9IDA7IF95MiA8IGhlaWdodDsgX3kyKyspIHtcbiAgICAgIHAgPSB5aSA8PCAyO1xuICAgICAgcGl4ZWxzW3BdID0gX3JTdW0yICogbXVsU3VtID4+IHNoZ1N1bTtcbiAgICAgIHBpeGVsc1twICsgMV0gPSBfZ1N1bTIgKiBtdWxTdW0gPj4gc2hnU3VtO1xuICAgICAgcGl4ZWxzW3AgKyAyXSA9IF9iU3VtMiAqIG11bFN1bSA+PiBzaGdTdW07XG4gICAgICBfclN1bTIgLT0gX3JPdXRTdW0yO1xuICAgICAgX2dTdW0yIC09IF9nT3V0U3VtMjtcbiAgICAgIF9iU3VtMiAtPSBfYk91dFN1bTI7XG4gICAgICBfck91dFN1bTIgLT0gc3RhY2tJbi5yO1xuICAgICAgX2dPdXRTdW0yIC09IHN0YWNrSW4uZztcbiAgICAgIF9iT3V0U3VtMiAtPSBzdGFja0luLmI7XG4gICAgICBwID0gX3gyICsgKChwID0gX3kyICsgcmFkaXVzUGx1czEpIDwgaGVpZ2h0TWludXMxID8gcCA6IGhlaWdodE1pbnVzMSkgKiB3aWR0aCA8PCAyO1xuICAgICAgX3JTdW0yICs9IF9ySW5TdW0yICs9IHN0YWNrSW4uciA9IHBpeGVsc1twXTtcbiAgICAgIF9nU3VtMiArPSBfZ0luU3VtMiArPSBzdGFja0luLmcgPSBwaXhlbHNbcCArIDFdO1xuICAgICAgX2JTdW0yICs9IF9iSW5TdW0yICs9IHN0YWNrSW4uYiA9IHBpeGVsc1twICsgMl07XG4gICAgICBzdGFja0luID0gc3RhY2tJbi5uZXh0O1xuICAgICAgX3JPdXRTdW0yICs9IF9wcjIgPSBzdGFja091dC5yO1xuICAgICAgX2dPdXRTdW0yICs9IF9wZzIgPSBzdGFja091dC5nO1xuICAgICAgX2JPdXRTdW0yICs9IF9wYjIgPSBzdGFja091dC5iO1xuICAgICAgX3JJblN1bTIgLT0gX3ByMjtcbiAgICAgIF9nSW5TdW0yIC09IF9wZzI7XG4gICAgICBfYkluU3VtMiAtPSBfcGIyO1xuICAgICAgc3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuICAgICAgeWkgKz0gd2lkdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGltYWdlRGF0YTtcbn1cbi8qKlxuICpcbiAqL1xuXG5cbnZhciBCbHVyU3RhY2sgPVxuLyoqXG4gKiBTZXQgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gQmx1clN0YWNrKCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmx1clN0YWNrKTtcblxuICB0aGlzLnIgPSAwO1xuICB0aGlzLmcgPSAwO1xuICB0aGlzLmIgPSAwO1xuICB0aGlzLmEgPSAwO1xuICB0aGlzLm5leHQgPSBudWxsO1xufTtcblxuZXhwb3J0IHsgQmx1clN0YWNrLCBwcm9jZXNzQ2FudmFzUkdCIGFzIGNhbnZhc1JHQiwgcHJvY2Vzc0NhbnZhc1JHQkEgYXMgY2FudmFzUkdCQSwgcHJvY2Vzc0ltYWdlIGFzIGltYWdlLCBwcm9jZXNzSW1hZ2VEYXRhUkdCIGFzIGltYWdlRGF0YVJHQiwgcHJvY2Vzc0ltYWdlRGF0YVJHQkEgYXMgaW1hZ2VEYXRhUkdCQSB9O1xuIiwiaW1wb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tICdyYWYnO1xuaW1wb3J0IFJHQkNvbG9yIGZyb20gJ3JnYmNvbG9yJztcbmltcG9ydCB7IFNWR1BhdGhEYXRhIH0gZnJvbSAnc3ZnLXBhdGhkYXRhJztcbmltcG9ydCB7IGNhbnZhc1JHQkEgfSBmcm9tICdzdGFja2JsdXItY2FudmFzJztcblxuLyoqXG4gKiBPcHRpb25zIHByZXNldCBmb3IgYE9mZnNjcmVlbkNhbnZhc2AuXG4gKiBAcGFyYW0gY29uZmlnIC0gUHJlc2V0IHJlcXVpcmVtZW50cy5cbiAqIEBwYXJhbSBjb25maWcuRE9NUGFyc2VyIC0gWE1ML0hUTUwgcGFyc2VyIGZyb20gc3RyaW5nIGludG8gRE9NIERvY3VtZW50LlxuICogQHJldHVybnMgUHJlc2V0IG9iamVjdC5cbiAqLyBmdW5jdGlvbiBvZmZzY3JlZW4oKSB7XG4gICAgbGV0IHsgRE9NUGFyc2VyOiBET01QYXJzZXJGYWxsYmFjayAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3QgcHJlc2V0ID0ge1xuICAgICAgICB3aW5kb3c6IG51bGwsXG4gICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgIERPTVBhcnNlcjogRE9NUGFyc2VyRmFsbGJhY2ssXG4gICAgICAgIGNyZWF0ZUNhbnZhcyAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGNyZWF0ZUltYWdlICh1cmwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgICAgICAgICAgIHJldHVybiBpbWc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5ET01QYXJzZXIgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBET01QYXJzZXJGYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShwcmVzZXQsICdET01QYXJzZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXNldDtcbn1cblxuLyoqXG4gKiBPcHRpb25zIHByZXNldCBmb3IgYG5vZGUtY2FudmFzYC5cbiAqIEBwYXJhbSBjb25maWcgLSBQcmVzZXQgcmVxdWlyZW1lbnRzLlxuICogQHBhcmFtIGNvbmZpZy5ET01QYXJzZXIgLSBYTUwvSFRNTCBwYXJzZXIgZnJvbSBzdHJpbmcgaW50byBET00gRG9jdW1lbnQuXG4gKiBAcGFyYW0gY29uZmlnLmNhbnZhcyAtIGBub2RlLWNhbnZhc2AgZXhwb3J0cy5cbiAqIEBwYXJhbSBjb25maWcuZmV0Y2ggLSBXSEFUV0ctY29tcGF0aWJsZSBgZmV0Y2hgIGZ1bmN0aW9uLlxuICogQHJldHVybnMgUHJlc2V0IG9iamVjdC5cbiAqLyBmdW5jdGlvbiBub2RlKHBhcmFtKSB7XG4gICAgbGV0IHsgRE9NUGFyc2VyICwgY2FudmFzICwgZmV0Y2ggIH0gPSBwYXJhbTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aW5kb3c6IG51bGwsXG4gICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgIERPTVBhcnNlcixcbiAgICAgICAgZmV0Y2gsXG4gICAgICAgIGNyZWF0ZUNhbnZhczogY2FudmFzLmNyZWF0ZUNhbnZhcyxcbiAgICAgICAgY3JlYXRlSW1hZ2U6IGNhbnZhcy5sb2FkSW1hZ2VcbiAgICB9O1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgb2Zmc2NyZWVuOiBvZmZzY3JlZW4sXG4gIG5vZGU6IG5vZGVcbn0pO1xuXG4vKipcbiAqIEhUTUwtc2FmZSBjb21wcmVzcyB3aGl0ZS1zcGFjZXMuXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIGNvbXByZXNzLlxuICogQHJldHVybnMgU3RyaW5nLlxuICovIGZ1bmN0aW9uIGNvbXByZXNzU3BhY2VzKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKD8hXFx1MzAwMClcXHMrL2dtLCAnICcpO1xufVxuLyoqXG4gKiBIVE1MLXNhZmUgbGVmdCB0cmltLlxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMgU3RyaW5nLlxuICovIGZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXltcXG4gXFx0XSsvLCAnJyk7XG59XG4vKipcbiAqIEhUTUwtc2FmZSByaWdodCB0cmltLlxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMgU3RyaW5nLlxuICovIGZ1bmN0aW9uIHRyaW1SaWdodChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXG4gXFx0XSskLywgJycpO1xufVxuLyoqXG4gKiBTdHJpbmcgdG8gbnVtYmVycyBhcnJheS5cbiAqIEBwYXJhbSBzdHIgLSBOdW1iZXJzIHN0cmluZy5cbiAqIEByZXR1cm5zIE51bWJlcnMgYXJyYXkuXG4gKi8gZnVuY3Rpb24gdG9OdW1iZXJzKHN0cikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2goLy0/KFxcZCsoPzpcXC5cXGQqKD86W2VFXVsrLV0/XFxkKyk/KT98XFwuXFxkKykoPz1cXER8JCkvZ20pO1xuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlcy5tYXAocGFyc2VGbG9hdCkgOiBbXTtcbn1cbi8qKlxuICogU3RyaW5nIHRvIG1hdHJpeCB2YWx1ZS5cbiAqIEBwYXJhbSBzdHIgLSBOdW1iZXJzIHN0cmluZy5cbiAqIEByZXR1cm5zIE1hdHJpeCB2YWx1ZS5cbiAqLyBmdW5jdGlvbiB0b01hdHJpeFZhbHVlKHN0cikge1xuICAgIGNvbnN0IG51bWJlcnMgPSB0b051bWJlcnMoc3RyKTtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAgIG51bWJlcnNbMF0gfHwgMCxcbiAgICAgICAgbnVtYmVyc1sxXSB8fCAwLFxuICAgICAgICBudW1iZXJzWzJdIHx8IDAsXG4gICAgICAgIG51bWJlcnNbM10gfHwgMCxcbiAgICAgICAgbnVtYmVyc1s0XSB8fCAwLFxuICAgICAgICBudW1iZXJzWzVdIHx8IDBcbiAgICBdO1xuICAgIHJldHVybiBtYXRyaXg7XG59XG4vLyBNaWNyb3NvZnQgRWRnZSBmaXhcbmNvbnN0IGFsbFVwcGVyY2FzZSA9IC9eW0EtWi1dKyQvO1xuLyoqXG4gKiBOb3JtYWxpemUgYXR0cmlidXRlIG5hbWUuXG4gKiBAcGFyYW0gbmFtZSAtIEF0dHJpYnV0ZSBuYW1lLlxuICogQHJldHVybnMgTm9ybWFsaXplZCBhdHRyaWJ1dGUgbmFtZS5cbiAqLyBmdW5jdGlvbiBub3JtYWxpemVBdHRyaWJ1dGVOYW1lKG5hbWUpIHtcbiAgICBpZiAoYWxsVXBwZXJjYXNlLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vKipcbiAqIFBhcnNlIGV4dGVybmFsIFVSTC5cbiAqIEBwYXJhbSB1cmwgLSBDU1MgdXJsIHN0cmluZy5cbiAqIEByZXR1cm5zIFBhcnNlZCBVUkwuXG4gKi8gZnVuY3Rpb24gcGFyc2VFeHRlcm5hbFVybCh1cmwpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICBzaW5nbGUgcXVvdGVzIFsyXVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICBkb3VibGUgcXVvdGVzIFszXVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgbm8gcXVvdGVzIFs0XVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgdlxuICAgIGNvbnN0IHVybE1hdGNoID0gL3VybFxcKCgnKFteJ10rKSd8XCIoW15cIl0rKVwifChbXidcIildKykpXFwpLy5leGVjKHVybCk7XG4gICAgaWYgKCF1cmxNYXRjaCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB1cmxNYXRjaFsyXSB8fCB1cmxNYXRjaFszXSB8fCB1cmxNYXRjaFs0XSB8fCAnJztcbn1cbi8qKlxuICogVHJhbnNmb3JtIGZsb2F0cyB0byBpbnRlZ2VycyBpbiByZ2IgY29sb3JzLlxuICogQHBhcmFtIGNvbG9yIC0gQ29sb3IgdG8gbm9ybWFsaXplLlxuICogQHJldHVybnMgTm9ybWFsaXplZCBjb2xvci5cbiAqLyBmdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICAgIGlmICghY29sb3Iuc3RhcnRzV2l0aCgncmdiJykpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBsZXQgcmdiUGFydHMgPSAzO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IGNvbG9yLnJlcGxhY2UoL1xcZCsoXFwuXFxkKyk/L2csIChudW0sIGlzRmxvYXQpPT4ocmdiUGFydHMtLSkgJiYgaXNGbG9hdCA/IFN0cmluZyhNYXRoLnJvdW5kKHBhcnNlRmxvYXQobnVtKSkpIDogbnVtXG4gICAgKTtcbiAgICByZXR1cm4gbm9ybWFsaXplZENvbG9yO1xufVxuXG4vLyBzbGlnaHRseSBtb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWVnYW5zdHJlZXQvc3BlY2lmaWNpdHkvYmxvYi9tYXN0ZXIvc3BlY2lmaWNpdHkuanNcbmNvbnN0IGF0dHJpYnV0ZVJlZ2V4ID0gLyhcXFtbXlxcXV0rXFxdKS9nO1xuY29uc3QgaWRSZWdleCA9IC8oI1teXFxzKz5+Lls6XSspL2c7XG5jb25zdCBjbGFzc1JlZ2V4ID0gLyhcXC5bXlxccys+fi5bOl0rKS9nO1xuY29uc3QgcHNldWRvRWxlbWVudFJlZ2V4ID0gLyg6OlteXFxzKz5+Lls6XSt8OmZpcnN0LWxpbmV8OmZpcnN0LWxldHRlcnw6YmVmb3JlfDphZnRlcikvZ2k7XG5jb25zdCBwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4ID0gLyg6W1xcdy1dK1xcKFteKV0qXFwpKS9naTtcbmNvbnN0IHBzZXVkb0NsYXNzUmVnZXggPSAvKDpbXlxccys+fi5bOl0rKS9nO1xuY29uc3QgZWxlbWVudFJlZ2V4ID0gLyhbXlxccys+fi5bOl0rKS9nO1xuZnVuY3Rpb24gZmluZFNlbGVjdG9yTWF0Y2goc2VsZWN0b3IsIHJlZ2V4KSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHJlZ2V4LmV4ZWMoc2VsZWN0b3IpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICAwXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdG9yLnJlcGxhY2UocmVnZXgsICcgJyksXG4gICAgICAgIG1hdGNoZXMubGVuZ3RoXG4gICAgXTtcbn1cbi8qKlxuICogTWVhc3VyZSBzZWxlY3RvciBzcGVjaWZpY2l0eS5cbiAqIEBwYXJhbSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIG1lYXN1cmUuXG4gKiBAcmV0dXJucyBTcGVjaWZpY2l0eS5cbiAqLyBmdW5jdGlvbiBnZXRTZWxlY3RvclNwZWNpZmljaXR5KHNlbGVjdG9yKSB7XG4gICAgY29uc3Qgc3BlY2lmaWNpdHkgPSBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICBdO1xuICAgIGxldCBjdXJyZW50U2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC86bm90XFwoKFteKV0qKVxcKS9nLCAnICAgICAkMSAnKS5yZXBsYWNlKC97W1xcc1xcU10qL2dtLCAnICcpO1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBhdHRyaWJ1dGVSZWdleCk7XG4gICAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gICAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBpZFJlZ2V4KTtcbiAgICBzcGVjaWZpY2l0eVswXSArPSBkZWx0YTtcbiAgICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGNsYXNzUmVnZXgpO1xuICAgIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICAgIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvRWxlbWVudFJlZ2V4KTtcbiAgICBzcGVjaWZpY2l0eVsyXSArPSBkZWx0YTtcbiAgICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIHBzZXVkb0NsYXNzV2l0aEJyYWNrZXRzUmVnZXgpO1xuICAgIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICAgIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvQ2xhc3NSZWdleCk7XG4gICAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gICAgY3VycmVudFNlbGVjdG9yID0gY3VycmVudFNlbGVjdG9yLnJlcGxhY2UoL1sqXFxzKz5+XS9nLCAnICcpLnJlcGxhY2UoL1sjLl0vZywgJyAnKTtcbiAgICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGVsZW1lbnRSZWdleCkgLy8gbGd0bSBbanMvdXNlbGVzcy1hc3NpZ25tZW50LXRvLWxvY2FsXVxuICAgIDtcbiAgICBzcGVjaWZpY2l0eVsyXSArPSBkZWx0YTtcbiAgICByZXR1cm4gc3BlY2lmaWNpdHkuam9pbignJyk7XG59XG5cbmNvbnN0IFBTRVVET19aRVJPID0gMC4wMDAwMDAwMTtcbi8qKlxuICogVmVjdG9yIG1hZ25pdHVkZS5cbiAqIEBwYXJhbSB2XG4gKiBAcmV0dXJucyBOdW1iZXIgcmVzdWx0LlxuICovIGZ1bmN0aW9uIHZlY3Rvck1hZ25pdHVkZSh2KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2WzBdLCAyKSArIE1hdGgucG93KHZbMV0sIDIpKTtcbn1cbi8qKlxuICogUmF0aW8gYmV0d2VlbiB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSB1XG4gKiBAcGFyYW0gdlxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cbiAqLyBmdW5jdGlvbiB2ZWN0b3JzUmF0aW8odSwgdikge1xuICAgIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodmVjdG9yTWFnbml0dWRlKHUpICogdmVjdG9yTWFnbml0dWRlKHYpKTtcbn1cbi8qKlxuICogQW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSB1XG4gKiBAcGFyYW0gdlxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cbiAqLyBmdW5jdGlvbiB2ZWN0b3JzQW5nbGUodSwgdikge1xuICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModmVjdG9yc1JhdGlvKHUsIHYpKTtcbn1cbmZ1bmN0aW9uIENCMSh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIENCMih0KSB7XG4gICAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBDQjModCkge1xuICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gQ0I0KHQpIHtcbiAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gUUIxKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG59XG5mdW5jdGlvbiBRQjIodCkge1xuICAgIHJldHVybiAyICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBRQjModCkge1xuICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcbn1cblxuY2xhc3MgUHJvcGVydHkge1xuICAgIHN0YXRpYyBlbXB0eShkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnRU1QVFknLCAnJyk7XG4gICAgfVxuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAnICc7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCBuYW1lICB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0U3RyaW5nKCkpLnRyaW0oKS5zcGxpdChzZXBhcmF0b3IpLm1hcCgodmFsdWUpPT5uZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBoYXNWYWx1ZSh6ZXJvSXNWYWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycgJiYgKHplcm9Jc1ZhbHVlIHx8IHZhbHVlICE9PSAwKSAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBpc1N0cmluZyhyZWdleHApIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGlmICghcmVzdWx0IHx8ICFyZWdleHApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZ2V4cC50ZXN0KHZhbHVlKTtcbiAgICB9XG4gICAgaXNVcmxEZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N0cmluZygvXnVybFxcKC8pO1xuICAgIH1cbiAgICBpc1BpeGVscygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7XG4gICAgICAgIHN3aXRjaCh0cnVlKXtcbiAgICAgICAgICAgIGNhc2UgYXNTdHJpbmcuZW5kc1dpdGgoJ3B4Jyk6XG4gICAgICAgICAgICBjYXNlIC9eWzAtOV0rJC8udGVzdChhc1N0cmluZyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRWYWx1ZShkZWYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gICAgZ2V0TnVtYmVyKGRlZikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhcnNlIHVua25vd24gdmFsdWUuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChkZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgIH0gPSB0aGlzO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhcnNlIHVua25vd24gdmFsdWUuXG4gICAgICAgIGxldCBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RyaW5nKC8lJC8pKSB7XG4gICAgICAgICAgICBuIC89IDEwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZ2V0U3RyaW5nKGRlZikge1xuICAgICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMudmFsdWUgPT09ICd1bmRlZmluZWQnID8gJycgOiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZyhkZWYpO1xuICAgIH1cbiAgICBnZXRDb2xvcihkZWYpIHtcbiAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5nZXRTdHJpbmcoZGVmKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOb3JtYWxpemVkQ29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTm9ybWFsaXplZENvbG9yID0gdHJ1ZTtcbiAgICAgICAgY29sb3IgPSBub3JtYWxpemVDb2xvcihjb2xvcik7XG4gICAgICAgIHRoaXMudmFsdWUgPSBjb2xvcjtcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBnZXREcGkoKSB7XG4gICAgICAgIHJldHVybiA5NiAvLyBUT0RPOiBjb21wdXRlP1xuICAgICAgICA7XG4gICAgfVxuICAgIGdldFJlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQucm9vdEVtU2l6ZTtcbiAgICB9XG4gICAgZ2V0RW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmVtU2l6ZTtcbiAgICB9XG4gICAgZ2V0VW5pdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0cmluZygpLnJlcGxhY2UoL1swLTkuLV0vZywgJycpO1xuICAgIH1cbiAgICBnZXRQaXhlbHMoYXhpc09ySXNGb250U2l6ZSkge1xuICAgICAgICBsZXQgcHJvY2Vzc1BlcmNlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2F4aXMsIGlzRm9udFNpemVdID0gdHlwZW9mIGF4aXNPcklzRm9udFNpemUgPT09ICdib29sZWFuJyA/IFtcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNPcklzRm9udFNpemVcbiAgICAgICAgXSA6IFtcbiAgICAgICAgICAgIGF4aXNPcklzRm9udFNpemVcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgeyB2aWV3UG9ydCAgfSA9IHRoaXMuZG9jdW1lbnQuc2NyZWVuO1xuICAgICAgICBzd2l0Y2godHJ1ZSl7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZtaW4kLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAgKiBNYXRoLm1pbih2aWV3UG9ydC5jb21wdXRlU2l6ZSgneCcpLCB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneScpKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdm1heCQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMCAqIE1hdGgubWF4KHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4JyksIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd5JykpO1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92dyQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMCAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4Jyk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZoJC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwICogdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcmVtJC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRSZW0oKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZW0kLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldEVtKCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2V4JC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRFbSgpIC8gMjtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcHgkLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3B0JC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKSAqICgxIC8gNzIpO1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9wYyQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIDE1O1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9jbSQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyLjU0O1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9tbSQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyNS40O1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9pbiQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoLyUkLykgJiYgaXNGb250U2l6ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RW0oKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvJSQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKGF4aXMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmdldE51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc1BlcmNlbnQgJiYgbiA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuICogdmlld1BvcnQuY29tcHV0ZVNpemUoYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1pbGxpc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU3RyaW5nKC9tcyQvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAxMDAwO1xuICAgIH1cbiAgICBnZXRSYWRpYW5zKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHRydWUpe1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9kZWckLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2dyYWQkLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDIwMCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3JhZCQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgICAgY29uc3QgYXNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuICAgICAgICBjb25zdCBtYXRjaCA9IC8jKFteKSdcIl0rKS8uZXhlYyhhc1N0cmluZyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoWzFdKSB8fCBhc1N0cmluZztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZGVmaW5pdGlvbnNbbmFtZV07XG4gICAgfVxuICAgIGdldEZpbGxTdHlsZURlZmluaXRpb24oZWxlbWVudCwgb3BhY2l0eSkge1xuICAgICAgICBsZXQgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBncmFkaWVudFxuICAgICAgICBpZiAodHlwZW9mIGRlZi5jcmVhdGVHcmFkaWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiAnZ2V0Qm91bmRpbmdCb3gnIGluIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWYuY3JlYXRlR3JhZGllbnQodGhpcy5kb2N1bWVudC5jdHgsIGVsZW1lbnQsIG9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhdHRlcm5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWYuY3JlYXRlUGF0dGVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5UcmFuc2Zvcm0gPSBkZWYuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgZGVmID0gZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlZiAmJiBwYXR0ZXJuVHJhbnNmb3JtLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmLmdldEF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScsIHRydWUpLnNldFZhbHVlKHBhdHRlcm5UcmFuc2Zvcm0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLmNyZWF0ZVBhdHRlcm4odGhpcy5kb2N1bWVudC5jdHgsIGVsZW1lbnQsIG9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRUZXh0QmFzZWxpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldFN0cmluZygpO1xuICAgICAgICByZXR1cm4gUHJvcGVydHkudGV4dEJhc2VsaW5lTWFwcGluZ1trZXldIHx8IG51bGw7XG4gICAgfVxuICAgIGFkZE9wYWNpdHkob3BhY2l0eSkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGNvbW1hcyA9IDA7XG4gICAgICAgIC8vIFNpbXVsYXRlIG9sZCBSR0JDb2xvciB2ZXJzaW9uLCB3aGljaCBjYW4ndCBwYXJzZSByZ2JhLlxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgaWYgKHZhbHVlW2ldID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBjb21tYXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21tYXMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3BhY2l0eS5oYXNWYWx1ZSgpICYmIHRoaXMuaXNTdHJpbmcoKSAmJiBjb21tYXMgIT09IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gbmV3IFJHQkNvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb2xvci5vaykge1xuICAgICAgICAgICAgICAgIGNvbG9yLmFscGhhID0gb3BhY2l0eS5nZXROdW1iZXIoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbG9yLnRvUkdCQSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgdGhpcy5uYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBuYW1lLCB2YWx1ZSl7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlzTm9ybWFsaXplZENvbG9yID0gZmFsc2U7XG4gICAgfVxufVxuUHJvcGVydHkudGV4dEJhc2VsaW5lTWFwcGluZyA9IHtcbiAgICAnYmFzZWxpbmUnOiAnYWxwaGFiZXRpYycsXG4gICAgJ2JlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICAgJ3RleHQtYmVmb3JlLWVkZ2UnOiAndG9wJyxcbiAgICAnbWlkZGxlJzogJ21pZGRsZScsXG4gICAgJ2NlbnRyYWwnOiAnbWlkZGxlJyxcbiAgICAnYWZ0ZXItZWRnZSc6ICdib3R0b20nLFxuICAgICd0ZXh0LWFmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgICAnaWRlb2dyYXBoaWMnOiAnaWRlb2dyYXBoaWMnLFxuICAgICdhbHBoYWJldGljJzogJ2FscGhhYmV0aWMnLFxuICAgICdoYW5naW5nJzogJ2hhbmdpbmcnLFxuICAgICdtYXRoZW1hdGljYWwnOiAnYWxwaGFiZXRpYydcbn07XG5cbmNsYXNzIFZpZXdQb3J0IHtcbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy52aWV3UG9ydHMgPSBbXTtcbiAgICB9XG4gICAgc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMudmlld1BvcnRzLnB1c2goe1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUN1cnJlbnQoKSB7XG4gICAgICAgIHRoaXMudmlld1BvcnRzLnBvcCgpO1xuICAgIH1cbiAgICBnZXRSb290KCkge1xuICAgICAgICBjb25zdCBbcm9vdF0gPSB0aGlzLnZpZXdQb3J0cztcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICBnZXRDdXJyZW50KCkge1xuICAgICAgICBjb25zdCB7IHZpZXdQb3J0cyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB2aWV3UG9ydHNbdmlld1BvcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudCgpLndpZHRoO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50KCkuaGVpZ2h0O1xuICAgIH1cbiAgICBjb21wdXRlU2l6ZShkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkID09PSAneCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkID09PSAneScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMud2lkdGgsIDIpICsgTWF0aC5wb3codGhpcy5oZWlnaHQsIDIpKSAvIE1hdGguc3FydCgyKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy52aWV3UG9ydHMgPSBbXTtcbiAgICB9XG59XG5WaWV3UG9ydC5ERUZBVUxUX1ZJRVdQT1JUX1dJRFRIID0gODAwO1xuVmlld1BvcnQuREVGQVVMVF9WSUVXUE9SVF9IRUlHSFQgPSA2MDA7XG5mdW5jdGlvbiBnZXREZWZhdWx0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBWaWV3UG9ydC5ERUZBVUxUX1ZJRVdQT1JUX1dJRFRILFxuICAgICAgICBoZWlnaHQ6IFZpZXdQb3J0LkRFRkFVTFRfVklFV1BPUlRfSEVJR0hUXG4gICAgfTtcbn1cblxuY2xhc3MgUG9pbnQge1xuICAgIHN0YXRpYyBwYXJzZShwb2ludCkge1xuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICBjb25zdCBbeCA9IGRlZmF1bHRWYWx1ZSwgeSA9IGRlZmF1bHRWYWx1ZV0gPSB0b051bWJlcnMocG9pbnQpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VTY2FsZShzY2FsZSkge1xuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgICBjb25zdCBbeCA9IGRlZmF1bHRWYWx1ZSwgeSA9IHhdID0gdG9OdW1iZXJzKHNjYWxlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlUGF0aChwYXRoKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRvTnVtYmVycyhwYXRoKTtcbiAgICAgICAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGF0aFBvaW50cyA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpe1xuICAgICAgICAgICAgcGF0aFBvaW50cy5wdXNoKG5ldyBQb2ludChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aFBvaW50cztcbiAgICB9XG4gICAgYW5nbGVUbyhwb2ludCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihwb2ludC55IC0gdGhpcy55LCBwb2ludC54IC0gdGhpcy54KTtcbiAgICB9XG4gICAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB4cCA9IHggKiB0cmFuc2Zvcm1bMF0gKyB5ICogdHJhbnNmb3JtWzJdICsgdHJhbnNmb3JtWzRdO1xuICAgICAgICBjb25zdCB5cCA9IHggKiB0cmFuc2Zvcm1bMV0gKyB5ICogdHJhbnNmb3JtWzNdICsgdHJhbnNmb3JtWzVdO1xuICAgICAgICB0aGlzLnggPSB4cDtcbiAgICAgICAgdGhpcy55ID0geXA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHgsIHkpe1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbn1cblxuY2xhc3MgTW91c2Uge1xuICAgIGlzV29ya2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2luZztcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNjcmVlbiAsIG9uQ2xpY2sgLCBvbk1vdXNlTW92ZSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHNjcmVlbi5jdHguY2FudmFzO1xuICAgICAgICBjYW52YXMub25jbGljayA9IG9uQ2xpY2s7XG4gICAgICAgIGNhbnZhcy5vbm1vdXNlbW92ZSA9IG9uTW91c2VNb3ZlO1xuICAgICAgICB0aGlzLndvcmtpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMud29ya2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuc2NyZWVuLmN0eC5jYW52YXM7XG4gICAgICAgIHRoaXMud29ya2luZyA9IGZhbHNlO1xuICAgICAgICBjYW52YXMub25jbGljayA9IG51bGw7XG4gICAgICAgIGNhbnZhcy5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgfVxuICAgIGhhc0V2ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2luZyAmJiB0aGlzLmV2ZW50cy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBydW5FdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy53b3JraW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzY3JlZW46IGRvY3VtZW50ICwgZXZlbnRzICwgZXZlbnRFbGVtZW50cyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3R5bGUgIH0gPSBkb2N1bWVudC5jdHguY2FudmFzO1xuICAgICAgICBsZXQgZWxlbWVudDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBldmVudHMuZm9yRWFjaCgocGFyYW0sIGkpPT57XG4gICAgICAgICAgICBsZXQgeyBydW4gIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBldmVudEVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgd2hpbGUoZWxlbWVudCl7XG4gICAgICAgICAgICAgICAgcnVuKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRvbmUgcnVubmluZywgY2xlYXJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG4gICAgfVxuICAgIGNoZWNrUGF0aChlbGVtZW50LCBjdHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLndvcmtpbmcgfHwgIWN0eCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZXZlbnRzICwgZXZlbnRFbGVtZW50cyAgfSA9IHRoaXM7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKChwYXJhbSwgaSk9PntcbiAgICAgICAgICAgIGxldCB7IHggLCB5ICB9ID0gcGFyYW07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKCFldmVudEVsZW1lbnRzW2ldICYmIGN0eC5pc1BvaW50SW5QYXRoICYmIGN0eC5pc1BvaW50SW5QYXRoKHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVja0JvdW5kaW5nQm94KGVsZW1lbnQsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIGlmICghdGhpcy53b3JraW5nIHx8ICFib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZXZlbnRzICwgZXZlbnRFbGVtZW50cyAgfSA9IHRoaXM7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKChwYXJhbSwgaSk9PntcbiAgICAgICAgICAgIGxldCB7IHggLCB5ICB9ID0gcGFyYW07XG4gICAgICAgICAgICBpZiAoIWV2ZW50RWxlbWVudHNbaV0gJiYgYm91bmRpbmdCb3guaXNQb2ludEluQm94KHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXBYWSh4LCB5KSB7XG4gICAgICAgIGNvbnN0IHsgd2luZG93ICwgY3R4ICB9ID0gdGhpcy5zY3JlZW47XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICBsZXQgZWxlbWVudCA9IGN0eC5jYW52YXM7XG4gICAgICAgIHdoaWxlKGVsZW1lbnQpe1xuICAgICAgICAgICAgcG9pbnQueCAtPSBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICBwb2ludC55IC09IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuc2Nyb2xsWCkge1xuICAgICAgICAgICAgcG9pbnQueCArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LnNjcm9sbFkpIHtcbiAgICAgICAgICAgIHBvaW50LnkgKz0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSB0aGlzLm1hcFhZKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdvbmNsaWNrJyxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgcnVuIChldmVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRhcmdldC5vbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0Lm9uQ2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcy5tYXBYWShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnb25tb3VzZW1vdmUnLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICBydW4gKGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VGFyZ2V0Lm9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0Lm9uTW91c2VNb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2NyZWVuKXtcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XG4gICAgICAgIHRoaXMud29ya2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsO1xuY29uc3QgZGVmYXVsdEZldGNoJDEgPSB0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnID8gZmV0Y2guYmluZCh1bmRlZmluZWQpIC8vIGBmZXRjaGAgZGVwZW5kcyBvbiBjb250ZXh0OiBgc29tZU9iamVjdC5mZXRjaCguLi4pYCB3aWxsIHRocm93IGVycm9yLlxuIDogdW5kZWZpbmVkO1xuY2xhc3MgU2NyZWVuIHtcbiAgICB3YWl0KGNoZWNrZXIpIHtcbiAgICAgICAgdGhpcy53YWl0cy5wdXNoKGNoZWNrZXIpO1xuICAgIH1cbiAgICByZWFkeSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgICAgIGlmICghdGhpcy5yZWFkeVByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeVByb21pc2U7XG4gICAgfVxuICAgIGlzUmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVhZHlMb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1JlYWR5TG9jayA9IHRoaXMud2FpdHMuZXZlcnkoKF8pPT5fKClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGlzUmVhZHlMb2NrKSB7XG4gICAgICAgICAgICB0aGlzLndhaXRzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlUmVhZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVSZWFkeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZWFkeUxvY2sgPSBpc1JlYWR5TG9jaztcbiAgICAgICAgcmV0dXJuIGlzUmVhZHlMb2NrO1xuICAgIH1cbiAgICBzZXREZWZhdWx0cyhjdHgpIHtcbiAgICAgICAgLy8gaW5pdGlhbCB2YWx1ZXMgYW5kIGRlZmF1bHRzXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gNDtcbiAgICB9XG4gICAgc2V0Vmlld0JveChwYXJhbSkge1xuICAgICAgICBsZXQgeyBkb2N1bWVudCAsIGN0eCAsIGFzcGVjdFJhdGlvICwgd2lkdGggLCBkZXNpcmVkV2lkdGggLCBoZWlnaHQgLCBkZXNpcmVkSGVpZ2h0ICwgbWluWCA9MCAsIG1pblkgPTAgLCByZWZYICwgcmVmWSAsIGNsaXAgPWZhbHNlICwgY2xpcFggPTAgLCBjbGlwWSA9MCAgfSA9IHBhcmFtO1xuICAgICAgICAvLyBhc3BlY3QgcmF0aW8gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZVxuICAgICAgICBjb25zdCBjbGVhbkFzcGVjdFJhdGlvID0gY29tcHJlc3NTcGFjZXMoYXNwZWN0UmF0aW8pLnJlcGxhY2UoL15kZWZlclxccy8sICcnKSAvLyBpZ25vcmUgZGVmZXJcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBbYXNwZWN0UmF0aW9BbGlnbiwgYXNwZWN0UmF0aW9NZWV0T3JTbGljZV0gPSBjbGVhbkFzcGVjdFJhdGlvLnNwbGl0KCcgJyk7XG4gICAgICAgIGNvbnN0IGFsaWduID0gYXNwZWN0UmF0aW9BbGlnbiB8fCAneE1pZFlNaWQnO1xuICAgICAgICBjb25zdCBtZWV0T3JTbGljZSA9IGFzcGVjdFJhdGlvTWVldE9yU2xpY2UgfHwgJ21lZXQnO1xuICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGVcbiAgICAgICAgY29uc3Qgc2NhbGVYID0gd2lkdGggLyBkZXNpcmVkV2lkdGg7XG4gICAgICAgIGNvbnN0IHNjYWxlWSA9IGhlaWdodCAvIGRlc2lyZWRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHNjYWxlTWluID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICBjb25zdCBzY2FsZU1heCA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgbGV0IGZpbmFsRGVzaXJlZFdpZHRoID0gZGVzaXJlZFdpZHRoO1xuICAgICAgICBsZXQgZmluYWxEZXNpcmVkSGVpZ2h0ID0gZGVzaXJlZEhlaWdodDtcbiAgICAgICAgaWYgKG1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgICAgIGZpbmFsRGVzaXJlZFdpZHRoICo9IHNjYWxlTWluO1xuICAgICAgICAgICAgZmluYWxEZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICAgICAgZmluYWxEZXNpcmVkV2lkdGggKj0gc2NhbGVNYXg7XG4gICAgICAgICAgICBmaW5hbERlc2lyZWRIZWlnaHQgKj0gc2NhbGVNYXg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmWFByb3AgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdyZWZYJywgcmVmWCk7XG4gICAgICAgIGNvbnN0IHJlZllQcm9wID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAncmVmWScsIHJlZlkpO1xuICAgICAgICBjb25zdCBoYXNSZWZzID0gcmVmWFByb3AuaGFzVmFsdWUoKSAmJiByZWZZUHJvcC5oYXNWYWx1ZSgpO1xuICAgICAgICBpZiAoaGFzUmVmcykge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtc2NhbGVNaW4gKiByZWZYUHJvcC5nZXRQaXhlbHMoJ3gnKSwgLXNjYWxlTWluICogcmVmWVByb3AuZ2V0UGl4ZWxzKCd5JykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRDbGlwWCA9IHNjYWxlTWluICogY2xpcFg7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRDbGlwWSA9IHNjYWxlTWluICogY2xpcFk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHNjYWxlZENsaXBYLCBzY2FsZWRDbGlwWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHdpZHRoLCBzY2FsZWRDbGlwWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhzY2FsZWRDbGlwWCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNSZWZzKSB7XG4gICAgICAgICAgICBjb25zdCBpc01lZXRNaW5ZID0gbWVldE9yU2xpY2UgPT09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PT0gc2NhbGVZO1xuICAgICAgICAgICAgY29uc3QgaXNTbGljZU1heFkgPSBtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PT0gc2NhbGVZO1xuICAgICAgICAgICAgY29uc3QgaXNNZWV0TWluWCA9IG1lZXRPclNsaWNlID09PSAnbWVldCcgJiYgc2NhbGVNaW4gPT09IHNjYWxlWDtcbiAgICAgICAgICAgIGNvbnN0IGlzU2xpY2VNYXhYID0gbWVldE9yU2xpY2UgPT09ICdzbGljZScgJiYgc2NhbGVNYXggPT09IHNjYWxlWDtcbiAgICAgICAgICAgIGlmIChhbGlnbi5zdGFydHNXaXRoKCd4TWlkJykgJiYgKGlzTWVldE1pblkgfHwgaXNTbGljZU1heFkpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCAvIDIgLSBmaW5hbERlc2lyZWRXaWR0aCAvIDIsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsaWduLmVuZHNXaXRoKCdZTWlkJykgJiYgKGlzTWVldE1pblggfHwgaXNTbGljZU1heFgpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLyAyIC0gZmluYWxEZXNpcmVkSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxpZ24uc3RhcnRzV2l0aCgneE1heCcpICYmIChpc01lZXRNaW5ZIHx8IGlzU2xpY2VNYXhZKSkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGggLSBmaW5hbERlc2lyZWRXaWR0aCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxpZ24uZW5kc1dpdGgoJ1lNYXgnKSAmJiAoaXNNZWV0TWluWCB8fCBpc1NsaWNlTWF4WCkpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGhlaWdodCAtIGZpbmFsRGVzaXJlZEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2NhbGVcbiAgICAgICAgc3dpdGNoKHRydWUpe1xuICAgICAgICAgICAgY2FzZSBhbGlnbiA9PT0gJ25vbmUnOlxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lZXRPclNsaWNlID09PSAnbWVldCc6XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlTWluLCBzY2FsZU1pbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lZXRPclNsaWNlID09PSAnc2xpY2UnOlxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZU1heCwgc2NhbGVNYXgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYW5zbGF0ZVxuICAgICAgICBjdHgudHJhbnNsYXRlKC1taW5YLCAtbWluWSk7XG4gICAgfVxuICAgIHN0YXJ0KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHsgZW5hYmxlUmVkcmF3ID1mYWxzZSAsIGlnbm9yZU1vdXNlID1mYWxzZSAsIGlnbm9yZUFuaW1hdGlvbiA9ZmFsc2UgLCBpZ25vcmVEaW1lbnNpb25zID1mYWxzZSAsIGlnbm9yZUNsZWFyID1mYWxzZSAsIGZvcmNlUmVkcmF3ICwgc2NhbGVXaWR0aCAsIHNjYWxlSGVpZ2h0ICwgb2Zmc2V0WCAsIG9mZnNldFkgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICBjb25zdCB7IG1vdXNlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyBTY3JlZW4uRlJBTUVSQVRFO1xuICAgICAgICB0aGlzLmZyYW1lRHVyYXRpb24gPSBmcmFtZUR1cmF0aW9uO1xuICAgICAgICB0aGlzLnJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlUmVhZHkgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5hYmxlUmVkcmF3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCB0aGVuID0gbm93O1xuICAgICAgICBsZXQgZGVsdGEgPSAwO1xuICAgICAgICBjb25zdCB0aWNrID0gKCk9PntcbiAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBkZWx0YSA9IG5vdyAtIHRoZW47XG4gICAgICAgICAgICBpZiAoZGVsdGEgPj0gZnJhbWVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoZW4gPSBub3cgLSBkZWx0YSAlIGZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXBkYXRlKGlnbm9yZUFuaW1hdGlvbiwgZm9yY2VSZWRyYXcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlLnJ1bkV2ZW50cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpZ25vcmVNb3VzZSkge1xuICAgICAgICAgICAgbW91c2Uuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVydmFsSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZS5jYW5jZWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZS5zdG9wKCk7XG4gICAgfVxuICAgIHNob3VsZFVwZGF0ZShpZ25vcmVBbmltYXRpb24sIGZvcmNlUmVkcmF3KSB7XG4gICAgICAgIC8vIG5lZWQgdXBkYXRlIGZyb20gYW5pbWF0aW9ucz9cbiAgICAgICAgaWYgKCFpZ25vcmVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnJhbWVEdXJhdGlvbiAgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRVcGRhdGUxID0gdGhpcy5hbmltYXRpb25zLnJlZHVjZSgoc2hvdWxkVXBkYXRlLCBhbmltYXRpb24pPT5hbmltYXRpb24udXBkYXRlKGZyYW1lRHVyYXRpb24pIHx8IHNob3VsZFVwZGF0ZVxuICAgICAgICAgICAgLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG5lZWQgdXBkYXRlIGZyb20gcmVkcmF3P1xuICAgICAgICBpZiAodHlwZW9mIGZvcmNlUmVkcmF3ID09PSAnZnVuY3Rpb24nICYmIGZvcmNlUmVkcmF3KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1JlYWR5TG9jayAmJiB0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVlZCB1cGRhdGUgZnJvbSBtb3VzZSBldmVudHM/XG4gICAgICAgIGlmICh0aGlzLm1vdXNlLmhhc0V2ZW50cygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICAgICAgY29uc3QgeyB2aWV3UG9ydCAsIGN0eCAsIGlzRmlyc3RSZW5kZXIgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgICAgICB2aWV3UG9ydC5jbGVhcigpO1xuICAgICAgICBpZiAoY2FudmFzLndpZHRoICYmIGNhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aWR0aFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnd2lkdGgnKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdoZWlnaHQnKTtcbiAgICAgICAgaWYgKCFpZ25vcmVEaW1lbnNpb25zICYmIChpc0ZpcnN0UmVuZGVyIHx8IHR5cGVvZiBzY2FsZVdpZHRoICE9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2NhbGVIZWlnaHQgIT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgLy8gc2V0IGNhbnZhcyBzaXplXG4gICAgICAgICAgICBpZiAod2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgICAgIGlmIChjYW52YXMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoY2FudmFzLndpZHRoLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodFN0eWxlLmdldFBpeGVscygneScpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcy5zdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoY2FudmFzLmhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNXaWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aCB8fCBjYW52YXMud2lkdGg7XG4gICAgICAgIGxldCBjSGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCB8fCBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBpZiAoaWdub3JlRGltZW5zaW9ucyAmJiB3aWR0aFN0eWxlLmhhc1ZhbHVlKCkgJiYgaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY1dpZHRoID0gd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgIGNIZWlnaHQgPSBoZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3UG9ydC5zZXRDdXJyZW50KGNXaWR0aCwgY0hlaWdodCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0WCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4JywgdHJ1ZSkuc2V0VmFsdWUob2Zmc2V0WCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXRZID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3knLCB0cnVlKS5zZXRWYWx1ZShvZmZzZXRZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNjYWxlV2lkdGggPT09ICdudW1iZXInIHx8IHR5cGVvZiBzY2FsZUhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdCb3ggPSB0b051bWJlcnMoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgICBsZXQgeFJhdGlvID0gMDtcbiAgICAgICAgICAgIGxldCB5UmF0aW8gPSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2FsZVdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd3aWR0aCcpO1xuICAgICAgICAgICAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeFJhdGlvID0gd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKSAvIHNjYWxlV2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aWV3Qm94WzJdICYmICFpc05hTih2aWV3Qm94WzJdKSkge1xuICAgICAgICAgICAgICAgICAgICB4UmF0aW8gPSB2aWV3Qm94WzJdIC8gc2NhbGVXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjYWxlSGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeVJhdGlvID0gaGVpZ2h0U3R5bGUuZ2V0UGl4ZWxzKCd5JykgLyBzY2FsZUhlaWdodDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpZXdCb3hbM10gJiYgIWlzTmFOKHZpZXdCb3hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHlSYXRpbyA9IHZpZXdCb3hbM10gLyBzY2FsZUhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXhSYXRpbykge1xuICAgICAgICAgICAgICAgIHhSYXRpbyA9IHlSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgheVJhdGlvKSB7XG4gICAgICAgICAgICAgICAgeVJhdGlvID0geFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSkuc2V0VmFsdWUoc2NhbGVXaWR0aCk7XG4gICAgICAgICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSkuc2V0VmFsdWUoc2NhbGVIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0nLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybVN0eWxlLnNldFZhbHVlKFwiXCIuY29uY2F0KHRyYW5zZm9ybVN0eWxlLmdldFN0cmluZygpLCBcIiBzY2FsZShcIikuY29uY2F0KDEgLyB4UmF0aW8sIFwiLCBcIikuY29uY2F0KDEgLyB5UmF0aW8sIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgYW5kIHJlbmRlclxuICAgICAgICBpZiAoIWlnbm9yZUNsZWFyKSB7XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNXaWR0aCwgY0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5yZW5kZXIoY3R4KTtcbiAgICAgICAgaWYgKGlzRmlyc3RSZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGaXJzdFJlbmRlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGN0eCwgeyBmZXRjaCA9ZGVmYXVsdEZldGNoJDEgLCB3aW5kb3cgPWRlZmF1bHRXaW5kb3cgIH0gPSB7fSl7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICB0aGlzLnZpZXdQb3J0ID0gbmV3IFZpZXdQb3J0KCk7XG4gICAgICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcyk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLndhaXRzID0gW107XG4gICAgICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuaXNSZWFkeUxvY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0ZpcnN0UmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gbnVsbDtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIGlmICghZmV0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgJ2ZldGNoJyBpbiAnZ2xvYmFsVGhpcycsIHBsZWFzZSBwcm92aWRlIGl0IHZpYSBvcHRpb25zXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG59XG5TY3JlZW4uZGVmYXVsdFdpbmRvdyA9IGRlZmF1bHRXaW5kb3c7XG5TY3JlZW4uZGVmYXVsdEZldGNoID0gZGVmYXVsdEZldGNoJDE7XG5TY3JlZW4uRlJBTUVSQVRFID0gMzA7XG5TY3JlZW4uTUFYX1ZJUlRVQUxfUElYRUxTID0gMzAwMDA7XG5cbmNvbnN0IHsgZGVmYXVsdEZldGNoICB9ID0gU2NyZWVuO1xuY29uc3QgRGVmYXVsdERPTVBhcnNlciA9IHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnID8gRE9NUGFyc2VyIDogdW5kZWZpbmVkO1xuY2xhc3MgUGFyc2VyIHtcbiAgICBhc3luYyBwYXJzZShyZXNvdXJjZSkge1xuICAgICAgICBpZiAocmVzb3VyY2Uuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZyb21TdHJpbmcocmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWQocmVzb3VyY2UpO1xuICAgIH1cbiAgICBwYXJzZUZyb21TdHJpbmcoeG1sKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyB0aGlzLkRPTVBhcnNlcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tEb2N1bWVudChwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ2ltYWdlL3N2Zyt4bWwnKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tEb2N1bWVudChwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKVswXTtcbiAgICAgICAgaWYgKHBhcnNlckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VyRXJyb3IudGV4dENvbnRlbnQgfHwgJ1Vua25vd24gcGFyc2UgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICAgIGFzeW5jIGxvYWQodXJsKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh1cmwpO1xuICAgICAgICBjb25zdCB4bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnJvbVN0cmluZyh4bWwpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGZldGNoID1kZWZhdWx0RmV0Y2ggLCBET01QYXJzZXIgPURlZmF1bHRET01QYXJzZXIgIH0gPSB7fSl7XG4gICAgICAgIGlmICghZmV0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgJ2ZldGNoJyBpbiAnZ2xvYmFsVGhpcycsIHBsZWFzZSBwcm92aWRlIGl0IHZpYSBvcHRpb25zXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRE9NUGFyc2VyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kICdET01QYXJzZXInIGluICdnbG9iYWxUaGlzJywgcGxlYXNlIHByb3ZpZGUgaXQgdmlhIG9wdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgICAgICB0aGlzLkRPTVBhcnNlciA9IERPTVBhcnNlcjtcbiAgICB9XG59XG5cbmNsYXNzIFRyYW5zbGF0ZSB7XG4gICAgYXBwbHkoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSB0aGlzLnBvaW50O1xuICAgICAgICBjdHgudHJhbnNsYXRlKHggfHwgMCwgeSB8fCAwKTtcbiAgICB9XG4gICAgdW5hcHBseShjdHgpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMucG9pbnQ7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLTEgKiB4IHx8IDAsIC0xICogeSB8fCAwKTtcbiAgICB9XG4gICAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSB0aGlzLnBvaW50O1xuICAgICAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgeCB8fCAwLFxuICAgICAgICAgICAgeSB8fCAwXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfLCBwb2ludCl7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0cmFuc2xhdGUnO1xuICAgICAgICB0aGlzLnBvaW50ID0gUG9pbnQucGFyc2UocG9pbnQpO1xuICAgIH1cbn1cblxuY2xhc3MgUm90YXRlIHtcbiAgICBhcHBseShjdHgpIHtcbiAgICAgICAgY29uc3QgeyBjeCAsIGN5ICwgb3JpZ2luWCAsIG9yaWdpblkgLCBhbmdsZSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHR4ID0gY3ggKyBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCB0eSA9IGN5ICsgb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICBjdHgucm90YXRlKGFuZ2xlLmdldFJhZGlhbnMoKSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICAgIH1cbiAgICB1bmFwcGx5KGN0eCkge1xuICAgICAgICBjb25zdCB7IGN4ICwgY3kgLCBvcmlnaW5YICwgb3JpZ2luWSAsIGFuZ2xlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdHggPSBjeCArIG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHR5ID0gY3kgKyBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIGN0eC5yb3RhdGUoLTEgKiBhbmdsZS5nZXRSYWRpYW5zKCkpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgICB9XG4gICAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHsgY3ggLCBjeSAsIGFuZ2xlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcmFkID0gYW5nbGUuZ2V0UmFkaWFucygpO1xuICAgICAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgY3ggfHwgMCxcbiAgICAgICAgICAgIGN5IHx8IDAgLy8gdGhpcy5wLnlcbiAgICAgICAgXSk7XG4gICAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFtcbiAgICAgICAgICAgIE1hdGguY29zKHJhZCksXG4gICAgICAgICAgICBNYXRoLnNpbihyYWQpLFxuICAgICAgICAgICAgLU1hdGguc2luKHJhZCksXG4gICAgICAgICAgICBNYXRoLmNvcyhyYWQpLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXSk7XG4gICAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAtY3ggfHwgMCxcbiAgICAgICAgICAgIC1jeSB8fCAwIC8vIC10aGlzLnAueVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHJvdGF0ZSwgdHJhbnNmb3JtT3JpZ2luKXtcbiAgICAgICAgdGhpcy50eXBlID0gJ3JvdGF0ZSc7XG4gICAgICAgIGNvbnN0IG51bWJlcnMgPSB0b051bWJlcnMocm90YXRlKTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2FuZ2xlJywgbnVtYmVyc1swXSk7XG4gICAgICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICAgICAgICB0aGlzLmN4ID0gbnVtYmVyc1sxXSB8fCAwO1xuICAgICAgICB0aGlzLmN5ID0gbnVtYmVyc1syXSB8fCAwO1xuICAgIH1cbn1cblxuY2xhc3MgU2NhbGUge1xuICAgIGFwcGx5KGN0eCkge1xuICAgICAgICBjb25zdCB7IHNjYWxlOiB7IHggLCB5ICB9ICwgb3JpZ2luWCAsIG9yaWdpblkgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICBjdHguc2NhbGUoeCwgeSB8fCB4KTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICAgIHVuYXBwbHkoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgc2NhbGU6IHsgeCAsIHkgIH0gLCBvcmlnaW5YICwgb3JpZ2luWSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIGN0eC5zY2FsZSgxIC8geCwgMSAvIHkgfHwgeCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICAgIH1cbiAgICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFtcbiAgICAgICAgICAgIHggfHwgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgeSB8fCAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF8sIHNjYWxlLCB0cmFuc2Zvcm1PcmlnaW4pe1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2NhbGUnO1xuICAgICAgICBjb25zdCBzY2FsZVNpemUgPSBQb2ludC5wYXJzZVNjYWxlKHNjYWxlKTtcbiAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3Igbm9kZS1jYW52YXNcbiAgICAgICAgaWYgKHNjYWxlU2l6ZS54ID09PSAwIHx8IHNjYWxlU2l6ZS55ID09PSAwKSB7XG4gICAgICAgICAgICBzY2FsZVNpemUueCA9IFBTRVVET19aRVJPO1xuICAgICAgICAgICAgc2NhbGVTaXplLnkgPSBQU0VVRE9fWkVSTztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGVTaXplO1xuICAgICAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgICB9XG59XG5cbmNsYXNzIE1hdHJpeCB7XG4gICAgYXBwbHkoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luWCAsIG9yaWdpblkgLCBtYXRyaXggIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKG1hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0pO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgICB9XG4gICAgdW5hcHBseShjdHgpIHtcbiAgICAgICAgY29uc3QgeyBvcmlnaW5YICwgb3JpZ2luWSAsIG1hdHJpeCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGEgPSBtYXRyaXhbMF07XG4gICAgICAgIGNvbnN0IGIgPSBtYXRyaXhbMl07XG4gICAgICAgIGNvbnN0IGMgPSBtYXRyaXhbNF07XG4gICAgICAgIGNvbnN0IGQgPSBtYXRyaXhbMV07XG4gICAgICAgIGNvbnN0IGUgPSBtYXRyaXhbM107XG4gICAgICAgIGNvbnN0IGYgPSBtYXRyaXhbNV07XG4gICAgICAgIGNvbnN0IGcgPSAwO1xuICAgICAgICBjb25zdCBoID0gMDtcbiAgICAgICAgY29uc3QgaSA9IDE7XG4gICAgICAgIGNvbnN0IGRldCA9IDEgLyAoYSAqIChlICogaSAtIGYgKiBoKSAtIGIgKiAoZCAqIGkgLSBmICogZykgKyBjICogKGQgKiBoIC0gZSAqIGcpKTtcbiAgICAgICAgY29uc3QgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybShkZXQgKiAoZSAqIGkgLSBmICogaCksIGRldCAqIChmICogZyAtIGQgKiBpKSwgZGV0ICogKGMgKiBoIC0gYiAqIGkpLCBkZXQgKiAoYSAqIGkgLSBjICogZyksIGRldCAqIChiICogZiAtIGMgKiBlKSwgZGV0ICogKGMgKiBkIC0gYSAqIGYpKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICAgIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgICAgICBwb2ludC5hcHBseVRyYW5zZm9ybSh0aGlzLm1hdHJpeCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF8sIG1hdHJpeCwgdHJhbnNmb3JtT3JpZ2luKXtcbiAgICAgICAgdGhpcy50eXBlID0gJ21hdHJpeCc7XG4gICAgICAgIHRoaXMubWF0cml4ID0gdG9NYXRyaXhWYWx1ZShtYXRyaXgpO1xuICAgICAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgICB9XG59XG5cbmNsYXNzIFNrZXcgZXh0ZW5kcyBNYXRyaXgge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3NrZXcnO1xuICAgICAgICB0aGlzLmFuZ2xlID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnYW5nbGUnLCBza2V3KTtcbiAgICB9XG59XG5cbmNsYXNzIFNrZXdYIGV4dGVuZHMgU2tldyB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbil7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2tld1gnO1xuICAgICAgICB0aGlzLm1hdHJpeCA9IFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgTWF0aC50YW4odGhpcy5hbmdsZS5nZXRSYWRpYW5zKCkpLFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5jbGFzcyBTa2V3WSBleHRlbmRzIFNrZXcge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3NrZXdZJztcbiAgICAgICAgdGhpcy5tYXRyaXggPSBbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgTWF0aC50YW4odGhpcy5hbmdsZS5nZXRSYWRpYW5zKCkpLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMFxuICAgICAgICBdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1zKHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBjb21wcmVzc1NwYWNlcyh0cmFuc2Zvcm0pLnRyaW0oKS5yZXBsYWNlKC9cXCkoW2EtekEtWl0pL2csICcpICQxJykucmVwbGFjZSgvXFwpKFxccz8sXFxzPykvZywgJykgJykuc3BsaXQoL1xccyg/PVthLXpdKS8pO1xufVxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgY29uc3QgW3R5cGUgPSAnJywgdmFsdWUgPSAnJ10gPSB0cmFuc2Zvcm0uc3BsaXQoJygnKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB0eXBlLnRyaW0oKSxcbiAgICAgICAgdmFsdWUudHJpbSgpLnJlcGxhY2UoJyknLCAnJylcbiAgICBdO1xufVxuY2xhc3MgVHJhbnNmb3JtIHtcbiAgICBzdGF0aWMgZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0nLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1TdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBbdHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5LCB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHkgPSB0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHldID0gZWxlbWVudC5nZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIGZhbHNlLCB0cnVlKS5zcGxpdCgpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eSAmJiB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1PcmlnaW4gPSBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luWVByb3BlcnR5XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShkb2N1bWVudCwgdHJhbnNmb3JtU3R5bGUuZ2V0U3RyaW5nKCksIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFwcGx5KGN0eCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMuZm9yRWFjaCgodHJhbnNmb3JtKT0+dHJhbnNmb3JtLmFwcGx5KGN0eClcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdW5hcHBseShjdHgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zLmZvckVhY2goKHRyYW5zZm9ybSk9PnRyYW5zZm9ybS51bmFwcGx5KGN0eClcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gVE9ETzogYXBwbHlUb1BvaW50IHVudXNlZCAuLi4gcmVtb3ZlP1xuICAgIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMuZm9yRWFjaCgodHJhbnNmb3JtKT0+dHJhbnNmb3JtLmFwcGx5VG9Qb2ludChwb2ludClcbiAgICAgICAgKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHRyYW5zZm9ybTEsIHRyYW5zZm9ybU9yaWdpbil7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwYXJzZVRyYW5zZm9ybXModHJhbnNmb3JtMSk7XG4gICAgICAgIGRhdGEuZm9yRWFjaCgodHJhbnNmb3JtKT0+e1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICBjb25zdCBUcmFuc2Zvcm1UeXBlID0gVHJhbnNmb3JtLnRyYW5zZm9ybVR5cGVzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKFRyYW5zZm9ybVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXMucHVzaChuZXcgVHJhbnNmb3JtVHlwZSh0aGlzLmRvY3VtZW50LCB2YWx1ZSwgdHJhbnNmb3JtT3JpZ2luKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblRyYW5zZm9ybS50cmFuc2Zvcm1UeXBlcyA9IHtcbiAgICB0cmFuc2xhdGU6IFRyYW5zbGF0ZSxcbiAgICByb3RhdGU6IFJvdGF0ZSxcbiAgICBzY2FsZTogU2NhbGUsXG4gICAgbWF0cml4OiBNYXRyaXgsXG4gICAgc2tld1g6IFNrZXdYLFxuICAgIHNrZXdZOiBTa2V3WVxufTtcblxuY2xhc3MgRWxlbWVudCB7XG4gICAgZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgbGV0IGNyZWF0ZUlmTm90RXhpc3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgICAgY29uc3QgYXR0ciA9IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFhdHRyICYmIGNyZWF0ZUlmTm90RXhpc3RzKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIG5hbWUsICcnKTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0ciB8fCBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gICAgZ2V0SHJlZkF0dHJpYnV0ZSgpIHtcbiAgICAgICAgbGV0IGhyZWY7XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKXtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdocmVmJyB8fCBrZXkuZW5kc1dpdGgoJzpocmVmJykpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gdGhpcy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhyZWYgfHwgUHJvcGVydHkuZW1wdHkodGhpcy5kb2N1bWVudCk7XG4gICAgfVxuICAgIGdldFN0eWxlKG5hbWUpIHtcbiAgICAgICAgbGV0IGNyZWF0ZUlmTm90RXhpc3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBmYWxzZSwgc2tpcEFuY2VzdG9ycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5zdHlsZXNbbmFtZV07XG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgaWYgKGF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBhdHRyIC8vIG1vdmUgdXAgdG8gbWUgdG8gY2FjaGVcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcEFuY2VzdG9ycykge1xuICAgICAgICAgICAgY29uc3QgeyBwYXJlbnQgIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFN0eWxlID0gcGFyZW50LmdldFN0eWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRTdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNyZWF0ZUlmTm90RXhpc3RzKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCBuYW1lLCAnJyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IHN0eWxlO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICAvLyBkb24ndCByZW5kZXIgZGlzcGxheT1ub25lXG4gICAgICAgIC8vIGRvbid0IHJlbmRlciB2aXNpYmlsaXR5PWhpZGRlblxuICAgICAgICBpZiAodGhpcy5nZXRTdHlsZSgnZGlzcGxheScpLmdldFN0cmluZygpID09PSAnbm9uZScgfHwgdGhpcy5nZXRTdHlsZSgndmlzaWJpbGl0eScpLmdldFN0cmluZygpID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmICh0aGlzLmdldFN0eWxlKCdtYXNrJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IHRoaXMuZ2V0U3R5bGUoJ21hc2snKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7XG4gICAgICAgICAgICAgICAgbWFzay5hcHBseShjdHgsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0U3R5bGUoJ2ZpbHRlcicpLmdldFZhbHVlKCdub25lJykgIT09ICdub25lJykge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5nZXRTdHlsZSgnZmlsdGVyJykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbnRleHQoY3R4KTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oY3R4KTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgc2V0Q29udGV4dChfKSB7XG4gICAgLy8gTk8gUkVOREVSXG4gICAgfVxuICAgIGFwcGx5RWZmZWN0cyhjdHgpIHtcbiAgICAgICAgLy8gdHJhbnNmb3JtXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IFRyYW5zZm9ybS5mcm9tRWxlbWVudCh0aGlzLmRvY3VtZW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xpcFxuICAgICAgICBjb25zdCBjbGlwUGF0aFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2NsaXAtcGF0aCcsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgaWYgKGNsaXBQYXRoU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaXAgPSBjbGlwUGF0aFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgICAgIGNsaXAuYXBwbHkoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhckNvbnRleHQoXykge1xuICAgIC8vIE5PIFJFTkRFUlxuICAgIH1cbiAgICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCk9PntcbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjdHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkQ2hpbGQoY2hpbGROb2RlKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGROb2RlIGluc3RhbmNlb2YgRWxlbWVudCA/IGNoaWxkTm9kZSA6IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjaGlsZE5vZGUpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBpZiAoIUVsZW1lbnQuaWdub3JlQ2hpbGRUeXBlcy5pbmNsdWRlcyhjaGlsZC50eXBlKSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgY29uc3QgeyBub2RlICB9ID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlLm1hdGNoZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlQ2xhc3NlcyA9IChyZWYgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY2FsbChub2RlLCAnY2xhc3MnKTtcbiAgICAgICAgaWYgKCFzdHlsZUNsYXNzZXMgfHwgc3R5bGVDbGFzc2VzID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZUNsYXNzZXMuc3BsaXQoJyAnKS5zb21lKChzdHlsZUNsYXNzKT0+XCIuXCIuY29uY2F0KHN0eWxlQ2xhc3MpID09PSBzZWxlY3RvclxuICAgICAgICApO1xuICAgIH1cbiAgICBhZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHN0eWxlcyAsIHN0eWxlc1NwZWNpZmljaXR5ICB9ID0gdGhpcy5kb2N1bWVudDtcbiAgICAgICAgbGV0IHN0eWxlUHJvcDtcbiAgICAgICAgZm9yKGNvbnN0IHNlbGVjdG9yIGluIHN0eWxlcyl7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0AnKSAmJiB0aGlzLm1hdGNoZXNTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IHN0eWxlc1tzZWxlY3Rvcl07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlY2lmaWNpdHkgPSBzdHlsZXNTcGVjaWZpY2l0eVtzZWxlY3Rvcl07XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcihjb25zdCBuYW1lIGluIHN0eWxlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleGlzdGluZ1NwZWNpZmljaXR5ID0gdGhpcy5zdHlsZXNTcGVjaWZpY2l0eVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmdTcGVjaWZpY2l0eSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1NwZWNpZmljaXR5ID0gJzAwMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lmaWNpdHkgJiYgc3BlY2lmaWNpdHkgPj0gZXhpc3RpbmdTcGVjaWZpY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUHJvcCA9IHN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZVByb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzU3BlY2lmaWNpdHlbbmFtZV0gPSBzcGVjaWZpY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVTdHlsZXMoZWxlbWVudCwgaWdub3JlU3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHRvUmVzdG9yZTEgPSBpZ25vcmVTdHlsZXMucmVkdWNlKCh0b1Jlc3RvcmUsIG5hbWUpPT57XG4gICAgICAgICAgICBjb25zdCBzdHlsZVByb3AgPSBlbGVtZW50LmdldFN0eWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFzdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1Jlc3RvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgICAgICAgIHN0eWxlUHJvcC5zZXRWYWx1ZSgnJyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLnRvUmVzdG9yZSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gdG9SZXN0b3JlMTtcbiAgICB9XG4gICAgcmVzdG9yZVN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgICAgICAgc3R5bGVzLmZvckVhY2goKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IFtuYW1lLCB2YWx1ZV0gPSBwYXJhbTtcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0U3R5bGUobmFtZSwgdHJ1ZSkuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNGaXJzdENoaWxkKCkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4gKChyZWYgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY2hpbGRyZW4uaW5kZXhPZih0aGlzKSkgPT09IDA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzID0gZmFsc2Upe1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuY2FwdHVyZVRleHROb2RlcyA9IGNhcHR1cmVUZXh0Tm9kZXM7XG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IHt9O1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkZyb3plbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkZyb3plblZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBhdHRyaWJ1dGVzXG4gICAgICAgIEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKS5mb3JFYWNoKChhdHRyaWJ1dGUpPT57XG4gICAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlLm5vZGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1tub2RlTmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5vZGVOYW1lLCBhdHRyaWJ1dGUudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XG4gICAgICAgIC8vIGFkZCBpbmxpbmUgc3R5bGVzXG4gICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKS5nZXRTdHJpbmcoKS5zcGxpdCgnOycpLm1hcCgoXyk9Pl8udHJpbSgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc3R5bGVzLmZvckVhY2goKHN0eWxlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gc3R5bGUuc3BsaXQoJzonKS5tYXAoKF8pPT5fLnRyaW0oKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGRlZmluaXRpb25zICB9ID0gZG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgIC8vIGFkZCBpZFxuICAgICAgICBpZiAoaWQuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgaWYgKCFkZWZpbml0aW9uc1tpZC5nZXRTdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uc1tpZC5nZXRTdHJpbmcoKV0gPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKChjaGlsZE5vZGUpPT57XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZE5vZGUpIC8vIEVMRU1FTlRfTk9ERVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZVRleHROb2RlcyAmJiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAzIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gNCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHROb2RlLmdldFRleHQoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodGV4dE5vZGUpIC8vIFRFWFRfTk9ERVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5FbGVtZW50Lmlnbm9yZUNoaWxkVHlwZXMgPSBbXG4gICAgJ3RpdGxlJ1xuXTtcblxuY2xhc3MgVW5rbm93bkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBGb250RmFtaWx5KGZvbnRGYW1pbHkpIHtcbiAgICBjb25zdCB0cmltbWVkID0gZm9udEZhbWlseS50cmltKCk7XG4gICAgcmV0dXJuIC9eKCd8XCIpLy50ZXN0KHRyaW1tZWQpID8gdHJpbW1lZCA6IFwiXFxcIlwiLmNvbmNhdCh0cmltbWVkLCBcIlxcXCJcIik7XG59XG5mdW5jdGlvbiBwcmVwYXJlRm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyA/IGZvbnRGYW1pbHkgOiBmb250RmFtaWx5LnRyaW0oKS5zcGxpdCgnLCcpLm1hcCh3cmFwRm9udEZhbWlseSkuam9pbignLCcpO1xufVxuLyoqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC1zdHlsZVxuICogQHBhcmFtIGZvbnRTdHlsZVxuICogQHJldHVybnMgQ1NTIGZvbnQgc3R5bGUuXG4gKi8gZnVuY3Rpb24gcHJlcGFyZUZvbnRTdHlsZShmb250U3R5bGUpIHtcbiAgICBpZiAoIWZvbnRTdHlsZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZvbnRTdHlsZSA9IGZvbnRTdHlsZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2godGFyZ2V0Rm9udFN0eWxlKXtcbiAgICAgICAgY2FzZSAnbm9ybWFsJzpcbiAgICAgICAgY2FzZSAnaXRhbGljJzpcbiAgICAgICAgY2FzZSAnb2JsaXF1ZSc6XG4gICAgICAgIGNhc2UgJ2luaGVyaXQnOlxuICAgICAgICBjYXNlICdpbml0aWFsJzpcbiAgICAgICAgY2FzZSAndW5zZXQnOlxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldEZvbnRTdHlsZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICgvXm9ibGlxdWVcXHMrKC18KVxcZCtkZWckLy50ZXN0KHRhcmdldEZvbnRTdHlsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbi8qKlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnQtd2VpZ2h0XG4gKiBAcGFyYW0gZm9udFdlaWdodFxuICogQHJldHVybnMgQ1NTIGZvbnQgd2VpZ2h0LlxuICovIGZ1bmN0aW9uIHByZXBhcmVGb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgICBpZiAoIWZvbnRXZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRGb250V2VpZ2h0ID0gZm9udFdlaWdodC50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2godGFyZ2V0Rm9udFdlaWdodCl7XG4gICAgICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgICAgIGNhc2UgJ2JvbGQnOlxuICAgICAgICBjYXNlICdsaWdodGVyJzpcbiAgICAgICAgY2FzZSAnYm9sZGVyJzpcbiAgICAgICAgY2FzZSAnaW5oZXJpdCc6XG4gICAgICAgIGNhc2UgJ2luaXRpYWwnOlxuICAgICAgICBjYXNlICd1bnNldCc6XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFdlaWdodDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICgvXltcXGQuXSskLy50ZXN0KHRhcmdldEZvbnRXZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldEZvbnRXZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuY2xhc3MgRm9udCB7XG4gICAgc3RhdGljIHBhcnNlKCkge1xuICAgICAgICBsZXQgZm9udCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogJycsIGluaGVyaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICAgICAgbGV0IGZvbnRTdHlsZSA9ICcnO1xuICAgICAgICBsZXQgZm9udFZhcmlhbnQgPSAnJztcbiAgICAgICAgbGV0IGZvbnRXZWlnaHQgPSAnJztcbiAgICAgICAgbGV0IGZvbnRTaXplID0gJyc7XG4gICAgICAgIGxldCBmb250RmFtaWx5ID0gJyc7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gY29tcHJlc3NTcGFjZXMoZm9udCkudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgIGNvbnN0IHNldCA9IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiBmYWxzZSxcbiAgICAgICAgICAgIGZvbnRTdHlsZTogZmFsc2UsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgIGZvbnRWYXJpYW50OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0KT0+e1xuICAgICAgICAgICAgc3dpdGNoKHRydWUpe1xuICAgICAgICAgICAgICAgIGNhc2UgIXNldC5mb250U3R5bGUgJiYgRm9udC5zdHlsZXMuaW5jbHVkZXMocGFydCk6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTdHlsZSA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgIXNldC5mb250VmFyaWFudCAmJiBGb250LnZhcmlhbnRzLmluY2x1ZGVzKHBhcnQpOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250VmFyaWFudCA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNldC5mb250VmFyaWFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgIXNldC5mb250V2VpZ2h0ICYmIEZvbnQud2VpZ2h0cy5pbmNsdWRlcyhwYXJ0KTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodCA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNldC5mb250VmFyaWFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNldC5mb250V2VpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAhc2V0LmZvbnRTaXplOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZSA9IHBhcnQuc3BsaXQoJy8nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRXZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFNpemUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5ICs9IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgRm9udChmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcHJlcGFyZUZvbnRTdHlsZSh0aGlzLmZvbnRTdHlsZSksXG4gICAgICAgICAgICB0aGlzLmZvbnRWYXJpYW50LFxuICAgICAgICAgICAgcHJlcGFyZUZvbnRXZWlnaHQodGhpcy5mb250V2VpZ2h0KSxcbiAgICAgICAgICAgIHRoaXMuZm9udFNpemUsXG4gICAgICAgICAgICAvLyBXcmFwIGZvbnRGYW1pbHkgb25seSBvbiBub2RlanMgYW5kIG9ubHkgZm9yIGNhbnZhcy5jdHhcbiAgICAgICAgICAgIHByZXBhcmVGb250RmFtaWx5KHRoaXMuZm9udEZhbWlseSlcbiAgICAgICAgXS5qb2luKCcgJykudHJpbSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCl7XG4gICAgICAgIGNvbnN0IGluaGVyaXRGb250ID0gaW5oZXJpdCA/IHR5cGVvZiBpbmhlcml0ID09PSAnc3RyaW5nJyA/IEZvbnQucGFyc2UoaW5oZXJpdCkgOiBpbmhlcml0IDoge307XG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9IGZvbnRGYW1pbHkgfHwgaW5oZXJpdEZvbnQuZm9udEZhbWlseTtcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IGZvbnRTaXplIHx8IGluaGVyaXRGb250LmZvbnRTaXplO1xuICAgICAgICB0aGlzLmZvbnRTdHlsZSA9IGZvbnRTdHlsZSB8fCBpbmhlcml0Rm9udC5mb250U3R5bGU7XG4gICAgICAgIHRoaXMuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQgfHwgaW5oZXJpdEZvbnQuZm9udFdlaWdodDtcbiAgICAgICAgdGhpcy5mb250VmFyaWFudCA9IGZvbnRWYXJpYW50IHx8IGluaGVyaXRGb250LmZvbnRWYXJpYW50O1xuICAgIH1cbn1cbkZvbnQuc3R5bGVzID0gJ25vcm1hbHxpdGFsaWN8b2JsaXF1ZXxpbmhlcml0JztcbkZvbnQudmFyaWFudHMgPSAnbm9ybWFsfHNtYWxsLWNhcHN8aW5oZXJpdCc7XG5Gb250LndlaWdodHMgPSAnbm9ybWFsfGJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8MTAwfDIwMHwzMDB8NDAwfDUwMHw2MDB8NzAwfDgwMHw5MDB8aW5oZXJpdCc7XG5cbmNsYXNzIEJvdW5kaW5nQm94IHtcbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueDE7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy55MTtcbiAgICB9XG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54MiAtIHRoaXMueDE7XG4gICAgfVxuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnkyIC0gdGhpcy55MTtcbiAgICB9XG4gICAgYWRkUG9pbnQoeCwgeSkge1xuICAgICAgICBpZiAodHlwZW9mIHggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy54MikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLngyID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4IDwgdGhpcy54MSkge1xuICAgICAgICAgICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPiB0aGlzLngyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54MiA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMueTEpIHx8IGlzTmFOKHRoaXMueTIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy55MSA9IHk7XG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA8IHRoaXMueTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ID4gdGhpcy55Mikge1xuICAgICAgICAgICAgICAgIHRoaXMueTIgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFgoeCkge1xuICAgICAgICB0aGlzLmFkZFBvaW50KHgsIDApO1xuICAgIH1cbiAgICBhZGRZKHkpIHtcbiAgICAgICAgdGhpcy5hZGRQb2ludCgwLCB5KTtcbiAgICB9XG4gICAgYWRkQm91bmRpbmdCb3goYm91bmRpbmdCb3gpIHtcbiAgICAgICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeDEgLCB5MSAsIHgyICwgeTIgIH0gPSBib3VuZGluZ0JveDtcbiAgICAgICAgdGhpcy5hZGRQb2ludCh4MSwgeTEpO1xuICAgICAgICB0aGlzLmFkZFBvaW50KHgyLCB5Mik7XG4gICAgfVxuICAgIHN1bUN1YmljKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygxIC0gdCwgMykgKiBwMCArIDMgKiBNYXRoLnBvdygxIC0gdCwgMikgKiB0ICogcDEgKyAzICogKDEgLSB0KSAqIE1hdGgucG93KHQsIDIpICogcDIgKyBNYXRoLnBvdyh0LCAzKSAqIHAzO1xuICAgIH1cbiAgICBiZXppZXJDdXJ2ZUFkZChmb3JYLCBwMCwgcDEsIHAyLCBwMykge1xuICAgICAgICBjb25zdCBiID0gNiAqIHAwIC0gMTIgKiBwMSArIDYgKiBwMjtcbiAgICAgICAgY29uc3QgYSA9IC0zICogcDAgKyA5ICogcDEgLSA5ICogcDIgKyAzICogcDM7XG4gICAgICAgIGNvbnN0IGMgPSAzICogcDEgLSAzICogcDA7XG4gICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSAtYyAvIGI7XG4gICAgICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yWCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFgodGhpcy5zdW1DdWJpYyh0LCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKHQsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGIyYWMgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBjICogYTtcbiAgICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdDEgPSAoLWIgKyBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModDEsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKHQxLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHQyID0gKC1iIC0gTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG4gICAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgICAgICBpZiAoZm9yWCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkWCh0aGlzLnN1bUN1YmljKHQyLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFkodGhpcy5zdW1DdWJpYyh0MiwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBmcm9tIGh0dHA6Ly9ibG9nLmhhY2tlcnMtY2FmZS5uZXQvMjAwOS8wNi9ob3ctdG8tY2FsY3VsYXRlLWJlemllci1jdXJ2ZXMtYm91bmRpbmcuaHRtbFxuICAgIGFkZEJlemllckN1cnZlKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgICAgIHRoaXMuYWRkUG9pbnQocDB4LCBwMHkpO1xuICAgICAgICB0aGlzLmFkZFBvaW50KHAzeCwgcDN5KTtcbiAgICAgICAgdGhpcy5iZXppZXJDdXJ2ZUFkZCh0cnVlLCBwMHgsIHAxeCwgcDJ4LCBwM3gpO1xuICAgICAgICB0aGlzLmJlemllckN1cnZlQWRkKGZhbHNlLCBwMHksIHAxeSwgcDJ5LCBwM3kpO1xuICAgIH1cbiAgICBhZGRRdWFkcmF0aWNDdXJ2ZShwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgICAgIGNvbnN0IGNwMXggPSBwMHggKyAyIC8gMyAqIChwMXggLSBwMHgpIC8vIENQMSA9IFFQMCArIDIvMyAqKFFQMS1RUDApXG4gICAgICAgIDtcbiAgICAgICAgY29uc3QgY3AxeSA9IHAweSArIDIgLyAzICogKHAxeSAtIHAweSkgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBjcDJ4ID0gY3AxeCArIDEgLyAzICogKHAyeCAtIHAweCkgLy8gQ1AyID0gQ1AxICsgMS8zICooUVAyLVFQMClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBjcDJ5ID0gY3AxeSArIDEgLyAzICogKHAyeSAtIHAweSkgLy8gQ1AyID0gQ1AxICsgMS8zICooUVAyLVFQMClcbiAgICAgICAgO1xuICAgICAgICB0aGlzLmFkZEJlemllckN1cnZlKHAweCwgcDB5LCBjcDF4LCBjcDJ4LCBjcDF5LCBjcDJ5LCBwMngsIHAyeSk7XG4gICAgfVxuICAgIGlzUG9pbnRJbkJveCh4LCB5KSB7XG4gICAgICAgIGNvbnN0IHsgeDEgLCB5MSAsIHgyICwgeTIgIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4geDEgPD0geCAmJiB4IDw9IHgyICYmIHkxIDw9IHkgJiYgeSA8PSB5MjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeDEgPSBOdW1iZXIuTmFOLCB5MSA9IE51bWJlci5OYU4sIHgyID0gTnVtYmVyLk5hTiwgeTIgPSBOdW1iZXIuTmFOKXtcbiAgICAgICAgdGhpcy54MSA9IHgxO1xuICAgICAgICB0aGlzLnkxID0geTE7XG4gICAgICAgIHRoaXMueDIgPSB4MjtcbiAgICAgICAgdGhpcy55MiA9IHkyO1xuICAgICAgICB0aGlzLmFkZFBvaW50KHgxLCB5MSk7XG4gICAgICAgIHRoaXMuYWRkUG9pbnQoeDIsIHkyKTtcbiAgICB9XG59XG5cbmNsYXNzIFJlbmRlcmVkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGNhbGN1bGF0ZU9wYWNpdHkoKSB7XG4gICAgICAgIGxldCBvcGFjaXR5ID0gMTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLCBjb25zaXN0ZW50LXRoaXNcbiAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZShlbGVtZW50KXtcbiAgICAgICAgICAgIGNvbnN0IG9wYWNpdHlTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ29wYWNpdHknLCBmYWxzZSwgdHJ1ZSkgLy8gbm8gYW5jZXN0b3JzIG9uIHN0eWxlIGNhbGxcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChvcGFjaXR5U3R5bGUuaGFzVmFsdWUodHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5ICo9IG9wYWNpdHlTdHlsZS5nZXROdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BhY2l0eTtcbiAgICB9XG4gICAgc2V0Q29udGV4dChjdHgpIHtcbiAgICAgICAgbGV0IGZyb21NZWFzdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgICAgaWYgKCFmcm9tTWVhc3VyZSkge1xuICAgICAgICAgICAgLy8gZmlsbFxuICAgICAgICAgICAgY29uc3QgZmlsbFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGxPcGFjaXR5U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbC1vcGFjaXR5Jyk7XG4gICAgICAgICAgICBjb25zdCBzdHJva2VTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UnKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZU9wYWNpdHlQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLW9wYWNpdHknKTtcbiAgICAgICAgICAgIGlmIChmaWxsU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbFN0eWxlID0gZmlsbFN0eWxlUHJvcC5nZXRGaWxsU3R5bGVEZWZpbml0aW9uKHRoaXMsIGZpbGxPcGFjaXR5U3R5bGVQcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsbFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsbFN0eWxlUHJvcC5nZXRTdHJpbmcoKSA9PT0gJ2N1cnJlbnRDb2xvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlUHJvcC5zZXRWYWx1ZSh0aGlzLmdldFN0eWxlKCdjb2xvcicpLmdldENvbG9yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSBmaWxsU3R5bGVQcm9wLmdldENvbG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGxTdHlsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGUgPT09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IGZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsbE9wYWNpdHlTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxTdHlsZSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnZmlsbCcsIGN0eC5maWxsU3R5bGUpLmFkZE9wYWNpdHkoZmlsbE9wYWNpdHlTdHlsZVByb3ApLmdldENvbG9yKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0cm9rZVxuICAgICAgICAgICAgaWYgKHN0cm9rZVN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGVQcm9wLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcywgc3Ryb2tlT3BhY2l0eVByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChzdHJva2VTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cm9rZVN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZVN0eWxlUHJvcC5nZXRTdHJpbmcoKSA9PT0gJ2N1cnJlbnRDb2xvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGVQcm9wLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuZ2V0Q29sb3IoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJva2VTdHlsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlID09PSAnbm9uZScgPyAncmdiYSgwLDAsMCwwKScgOiBzdHJva2VTdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3Ryb2tlT3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdzdHJva2UnLCBjdHguc3Ryb2tlU3R5bGUpLmFkZE9wYWNpdHkoc3Ryb2tlT3BhY2l0eVByb3ApLmdldFN0cmluZygpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGhTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2Utd2lkdGgnKTtcbiAgICAgICAgICAgIGlmIChzdHJva2VXaWR0aFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGluZVdpZHRoID0gc3Ryb2tlV2lkdGhTdHlsZVByb3AuZ2V0UGl4ZWxzKCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9ICFuZXdMaW5lV2lkdGggPyBQU0VVRE9fWkVSTyAvLyBicm93c2VycyBkb24ndCByZXNwZWN0IDAgKG9yIG5vZGUtY2FudmFzPyA6LSlcbiAgICAgICAgICAgICAgICAgOiBuZXdMaW5lV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJva2VMaW5lY2FwU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLWxpbmVjYXAnKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZUxpbmVqb2luU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLWxpbmVqb2luJyk7XG4gICAgICAgICAgICBjb25zdCBzdHJva2VNaXRlcmxpbWl0UHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1taXRlcmxpbWl0Jyk7XG4gICAgICAgICAgICAvLyBORUVEIFRFU1RcbiAgICAgICAgICAgIC8vIGNvbnN0IHBvaW50T3JkZXJTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdwYWludC1vcmRlcicpO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlRGFzaGFycmF5U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlRGFzaG9mZnNldFByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuICAgICAgICAgICAgaWYgKHN0cm9rZUxpbmVjYXBTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gc3Ryb2tlTGluZWNhcFN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJva2VMaW5lam9pblN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3Ryb2tlTWl0ZXJsaW1pdFByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGN0eC5taXRlckxpbWl0ID0gc3Ryb2tlTWl0ZXJsaW1pdFByb3AuZ2V0TnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBORUVEIFRFU1RcbiAgICAgICAgICAgIC8vIGlmIChwb2ludE9yZGVyU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIC8vICAgLy8gP1xuICAgICAgICAgICAgLy8gICBjdHgucGFpbnRPcmRlciA9IHBvaW50T3JkZXJTdHlsZVByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGlmIChzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuaGFzVmFsdWUoKSAmJiBzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuZ2V0U3RyaW5nKCkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhcHMgPSB0b051bWJlcnMoc3Ryb2tlRGFzaGFycmF5U3R5bGVQcm9wLmdldFN0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN0eC5zZXRMaW5lRGFzaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGdhcHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgICAgIGN0eC53ZWJraXRMaW5lRGFzaCA9IGdhcHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4Lm1vekRhc2ggIT09ICd1bmRlZmluZWQnICYmICEoZ2Fwcy5sZW5ndGggPT09IDEgJiYgZ2Fwc1swXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3pEYXNoID0gZ2FwcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3Ryb2tlRGFzaG9mZnNldFByb3AuZ2V0UGl4ZWxzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgubGluZURhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgud2Via2l0TGluZURhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICAgICAgICBjdHgud2Via2l0TGluZURhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4Lm1vekRhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICAgICAgICBjdHgubW96RGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9udFxuICAgICAgICB0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdHguZm9udCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250Jyk7XG4gICAgICAgICAgICBjb25zdCBmb250U3R5bGVTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LXN0eWxlJyk7XG4gICAgICAgICAgICBjb25zdCBmb250VmFyaWFudFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtdmFyaWFudCcpO1xuICAgICAgICAgICAgY29uc3QgZm9udFdlaWdodFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtd2VpZ2h0Jyk7XG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtc2l6ZScpO1xuICAgICAgICAgICAgY29uc3QgZm9udEZhbWlseVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5Jyk7XG4gICAgICAgICAgICBjb25zdCBmb250ID0gbmV3IEZvbnQoZm9udFN0eWxlU3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250VmFyaWFudFN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgZm9udFdlaWdodFN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgZm9udFNpemVTdHlsZVByb3AuaGFzVmFsdWUoKSA/IFwiXCIuY29uY2F0KGZvbnRTaXplU3R5bGVQcm9wLmdldFBpeGVscyh0cnVlKSwgXCJweFwiKSA6ICcnLCBmb250RmFtaWx5U3R5bGVQcm9wLmdldFN0cmluZygpLCBGb250LnBhcnNlKGZvbnRTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGN0eC5mb250KSk7XG4gICAgICAgICAgICBmb250U3R5bGVTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250U3R5bGUpO1xuICAgICAgICAgICAgZm9udFZhcmlhbnRTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250VmFyaWFudCk7XG4gICAgICAgICAgICBmb250V2VpZ2h0U3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFdlaWdodCk7XG4gICAgICAgICAgICBmb250U2l6ZVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRTaXplKTtcbiAgICAgICAgICAgIGZvbnRGYW1pbHlTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250RmFtaWx5KTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGZvbnRTaXplU3R5bGVQcm9wLmlzUGl4ZWxzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50LmVtU2l6ZSA9IGZvbnRTaXplU3R5bGVQcm9wLmdldFBpeGVscygpO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmcm9tTWVhc3VyZSkge1xuICAgICAgICAgICAgLy8gZWZmZWN0c1xuICAgICAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoY3R4KTtcbiAgICAgICAgICAgIC8vIG9wYWNpdHlcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY2FsY3VsYXRlT3BhY2l0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyQ29udGV4dChjdHgpIHtcbiAgICAgICAgc3VwZXIuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICAgIGlmICh0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQucG9wRW1TaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2sgPSBmYWxzZTtcbiAgICB9XG59XG5cbmNsYXNzIFRleHRFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgICBzZXRDb250ZXh0KGN0eCkge1xuICAgICAgICBsZXQgZnJvbU1lYXN1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICBzdXBlci5zZXRDb250ZXh0KGN0eCwgZnJvbU1lYXN1cmUpO1xuICAgICAgICBjb25zdCB0ZXh0QmFzZWxpbmUgPSB0aGlzLmdldFN0eWxlKCdkb21pbmFudC1iYXNlbGluZScpLmdldFRleHRCYXNlbGluZSgpIHx8IHRoaXMuZ2V0U3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScpLmdldFRleHRCYXNlbGluZSgpO1xuICAgICAgICBpZiAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxpemVDb29yZGluYXRlcygpIHtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy5sZWFmVGV4dHMgPSBbXTtcbiAgICAgICAgdGhpcy50ZXh0Q2h1bmtTdGFydCA9IDA7XG4gICAgICAgIHRoaXMubWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdGhpcy5tYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIH1cbiAgICBnZXRCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRURWxlbWVudEJvdW5kaW5nQm94KGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyc3QsIGNhbGN1bGF0ZSBjaGlsZCBwb3NpdGlvbnNcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ29vcmRpbmF0ZXMoKTtcbiAgICAgICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlKGN0eCk7XG4gICAgICAgIGxldCBib3VuZGluZ0JveCA9IG51bGw7XG4gICAgICAgIC8vIHRoZW4gY2FsY3VsYXRlIGJvdW5kaW5nIGJveFxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpPT57XG4gICAgICAgICAgICBjb25zdCBjaGlsZEJvdW5kaW5nQm94ID0gdGhpcy5nZXRDaGlsZEJvdW5kaW5nQm94KGN0eCwgdGhpcywgdGhpcywgaSk7XG4gICAgICAgICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICAgICAgYm91bmRpbmdCb3ggPSBjaGlsZEJvdW5kaW5nQm94O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZEJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gICAgZ2V0Rm9udFNpemUoKSB7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCBwYXJlbnQgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpbmhlcml0Rm9udFNpemUgPSBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KS5mb250U2l6ZTtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc2l6ZScpLmdldE51bWJlcihpbmhlcml0Rm9udFNpemUpO1xuICAgICAgICByZXR1cm4gZm9udFNpemU7XG4gICAgfVxuICAgIGdldFRFbGVtZW50Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55IC0gZm9udFNpemUsIHRoaXMueCArIHRoaXMubWVhc3VyZVRleHQoY3R4KSwgdGhpcy55KTtcbiAgICB9XG4gICAgZ2V0R2x5cGgoZm9udCwgdGV4dCwgaSkge1xuICAgICAgICBjb25zdCBjaGFyID0gdGV4dFtpXTtcbiAgICAgICAgbGV0IGdseXBoO1xuICAgICAgICBpZiAoZm9udC5pc0FyYWJpYykge1xuICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcHJldkNoYXIgPSB0ZXh0W2kgLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gdGV4dFtpICsgMV07XG4gICAgICAgICAgICBsZXQgYXJhYmljRm9ybSA9ICdpc29sYXRlZCc7XG4gICAgICAgICAgICBpZiAoKGkgPT09IDAgfHwgcHJldkNoYXIgPT09ICcgJykgJiYgaSA8IGxlbiAtIDEgJiYgbmV4dENoYXIgIT09ICcgJykge1xuICAgICAgICAgICAgICAgIGFyYWJpY0Zvcm0gPSAndGVybWluYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHByZXZDaGFyICE9PSAnICcgJiYgaSA8IGxlbiAtIDEgJiYgbmV4dENoYXIgIT09ICcgJykge1xuICAgICAgICAgICAgICAgIGFyYWJpY0Zvcm0gPSAnbWVkaWFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gMCAmJiBwcmV2Q2hhciAhPT0gJyAnICYmIChpID09PSBsZW4gLSAxIHx8IG5leHRDaGFyID09PSAnICcpKSB7XG4gICAgICAgICAgICAgICAgYXJhYmljRm9ybSA9ICdpbml0aWFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdseXBoID0gKChyZWYgPSBmb250LmFyYWJpY0dseXBoc1tjaGFyXSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWZbYXJhYmljRm9ybV0pIHx8IGZvbnQuZ2x5cGhzW2NoYXJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGggPSBmb250LmdseXBoc1tjaGFyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgICAgICBnbHlwaCA9IGZvbnQubWlzc2luZ0dseXBoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9XG4gICAgZ2V0VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXRUZXh0RnJvbU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IG5vZGUgfHwgdGhpcy5ub2RlO1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbSh0ZXh0Tm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGNoaWxkTm9kZXMuaW5kZXhPZih0ZXh0Tm9kZSk7XG4gICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IHRleHQgPSBjb21wcmVzc1NwYWNlcygvLyB0ZXh0Tm9kZS52YWx1ZVxuICAgICAgICAvLyB8fCB0ZXh0Tm9kZS50ZXh0XG4gICAgICAgIHRleHROb2RlLnRleHRDb250ZW50IHx8ICcnKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdHJpbUxlZnQodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHRleHQgPSB0cmltUmlnaHQodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVEVsZW1lbnRDaGlsZHJlbihjdHgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0LCBjYWxjdWxhdGUgY2hpbGQgcG9zaXRpb25zXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvb3JkaW5hdGVzKCk7XG4gICAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShjdHgpO1xuICAgICAgICAvLyB0aGVuIHJlbmRlclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpPT57XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkKGN0eCwgdGhpcywgdGhpcywgaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IG1vdXNlICB9ID0gdGhpcy5kb2N1bWVudC5zY3JlZW47XG4gICAgICAgIC8vIERvIG5vdCBjYWxjIGJvdW5kaW5nIGJveCBpZiBtb3VzZSBpcyBub3Qgd29ya2luZy5cbiAgICAgICAgaWYgKG1vdXNlLmlzV29ya2luZygpKSB7XG4gICAgICAgICAgICBtb3VzZS5jaGVja0JvdW5kaW5nQm94KHRoaXMsIHRoaXMuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyVEVsZW1lbnRDaGlsZHJlbihjdHgpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIHBhcmVudCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlbmRlclRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICAgICAgY29uc3QgY3VzdG9tRm9udCA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIGlmIChjdXN0b21Gb250KSB7XG4gICAgICAgICAgICBjb25zdCB7IHVuaXRzUGVyRW0gIH0gPSBjdXN0b21Gb250LmZvbnRGYWNlO1xuICAgICAgICAgICAgY29uc3QgY3R4Rm9udCA9IEZvbnQucGFyc2UoZG9jdW1lbnQuY3R4LmZvbnQpO1xuICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc2l6ZScpLmdldE51bWJlcihjdHhGb250LmZvbnRTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTdHlsZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zdHlsZScpLmdldFN0cmluZyhjdHhGb250LmZvbnRTdHlsZSk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjdXN0b21Gb250LmlzUlRMID8gcmVuZGVyVGV4dC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogcmVuZGVyVGV4dDtcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gdG9OdW1iZXJzKHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGUsIC1zY2FsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbHcgPSBjdHgubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBjdHgubGluZVdpZHRoICogdW5pdHNQZXJFbSAvIGZvbnRTaXplO1xuICAgICAgICAgICAgICAgIGlmIChmb250U3R5bGUgPT09ICdpdGFsaWMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMC40LCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2x5cGgucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGZvbnRTdHlsZSA9PT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAtMC40LCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGUsIC0xIC8gc2NhbGUpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXRoaXMueCwgLXRoaXMueSk7XG4gICAgICAgICAgICAgICAgdGhpcy54ICs9IGZvbnRTaXplICogKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgLyB1bml0c1BlckVtO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZHhbaV0gIT09ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ICs9IGR4W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcztcbiAgICAgICAgLy8gTkVFRCBURVNUXG4gICAgICAgIC8vIGlmIChjdHgucGFpbnRPcmRlciA9PT0gJ3N0cm9rZScpIHtcbiAgICAgICAgLy8gICBpZiAoY3R4LnN0cm9rZVN0eWxlKSB7XG4gICAgICAgIC8vICAgICBjdHguc3Ryb2tlVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vICAgaWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgICAgLy8gICAgIGN0eC5maWxsVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdHguZmlsbFN0eWxlKSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAvLyB9XG4gICAgfVxuICAgIGFwcGx5QW5jaG9yaW5nKCkge1xuICAgICAgICBpZiAodGhpcy50ZXh0Q2h1bmtTdGFydCA+PSB0aGlzLmxlYWZUZXh0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIGJhc2ljYWxseSB0aGUgXCJBcHBseSBhbmNob3JpbmdcIiBwYXJ0IG9mIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcyL3RleHQuaHRtbCNUZXh0TGF5b3V0QWxnb3JpdGhtLlxuICAgICAgICAvLyBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IHdlIGFwcGx5IHRoZSBhbmNob3JpbmcgYXMgc29vbiBhcyBhIGNodW5rIGlzIGZpbmlzaGVkLiBUaGlzIHNhdmVzIHNvbWUgZXh0cmEgbG9vcGluZy5cbiAgICAgICAgLy8gVmVydGljYWwgdGV4dCBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSB0aGlzLmxlYWZUZXh0c1t0aGlzLnRleHRDaHVua1N0YXJ0XTtcbiAgICAgICAgY29uc3QgdGV4dEFuY2hvciA9IGZpcnN0RWxlbWVudC5nZXRTdHlsZSgndGV4dC1hbmNob3InKS5nZXRTdHJpbmcoJ3N0YXJ0Jyk7XG4gICAgICAgIGNvbnN0IGlzUlRMID0gZmFsc2UgLy8gd2UgdHJlYXQgUlRMIGxpa2UgTFRSXG4gICAgICAgIDtcbiAgICAgICAgbGV0IHNoaWZ0ID0gMDtcbiAgICAgICAgaWYgKHRleHRBbmNob3IgPT09ICdzdGFydCcgJiYgIWlzUlRMIHx8IHRleHRBbmNob3IgPT09ICdlbmQnICYmIGlzUlRMKSB7XG4gICAgICAgICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gdGhpcy5taW5YO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHRBbmNob3IgPT09ICdlbmQnICYmICFpc1JUTCB8fCB0ZXh0QW5jaG9yID09PSAnc3RhcnQnICYmIGlzUlRMKSB7XG4gICAgICAgICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gdGhpcy5tYXhYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hpZnQgPSBmaXJzdEVsZW1lbnQueCAtICh0aGlzLm1pblggKyB0aGlzLm1heFgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSB0aGlzLnRleHRDaHVua1N0YXJ0OyBpIDwgdGhpcy5sZWFmVGV4dHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5sZWFmVGV4dHNbaV0ueCArPSBzaGlmdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydCBuZXcgY2h1bmtcbiAgICAgICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLm1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMudGV4dENodW5rU3RhcnQgPSB0aGlzLmxlYWZUZXh0cy5sZW5ndGg7XG4gICAgfVxuICAgIGFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSk9PntcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUoY3R4LCB0aGlzLCB0aGlzLCBpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwbHlBbmNob3JpbmcoKTtcbiAgICB9XG4gICAgYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkxKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2kxXTtcbiAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpPT57XG4gICAgICAgICAgICAgICAgdGV4dFBhcmVudC5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb25seSBsZWFmcyBhcmUgcmVsZXZhbnRcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlcyhjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkanVzdENoaWxkQ29vcmRpbmF0ZXMoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQubWVhc3VyZVRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjaGlsZC5zZXRDb250ZXh0KGN0eCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHhBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgICAgIGNvbnN0IHlBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgICAgIGNvbnN0IGR4QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnZHgnKTtcbiAgICAgICAgY29uc3QgZHlBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdkeScpO1xuICAgICAgICBjb25zdCBjdXN0b21Gb250ID0gY2hpbGQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5JykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICBjb25zdCBpc1JUTCA9IEJvb2xlYW4oY3VzdG9tRm9udCA9PT0gbnVsbCB8fCBjdXN0b21Gb250ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21Gb250LmlzUlRMKTtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNoaWxkcmVuIGluaGVyaXQgYXR0cmlidXRlcyBmcm9tIHBhcmVudChzKS4gUG9zaXRpb25hbCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBhcmUgb25seSBpbmhlcml0ZWQgZnJvbSBhIHBhcmVudCB0byBpdCdzIGZpcnN0IGNoaWxkLlxuICAgICAgICAgICAgaWYgKCF4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgeEF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCd4JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgeUF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCd5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGR4QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ2R4JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGR5QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ2R5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpZHRoID0gY2hpbGQubWVhc3VyZVRleHQoY3R4KTtcbiAgICAgICAgaWYgKGlzUlRMKSB7XG4gICAgICAgICAgICB0ZXh0UGFyZW50LnggLT0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIC8vIGFuIFwieFwiIGF0dHJpYnV0ZSBtYXJrcyB0aGUgc3RhcnQgb2YgYSBuZXcgY2h1bmtcbiAgICAgICAgICAgIHRleHRQYXJlbnQuYXBwbHlBbmNob3JpbmcoKTtcbiAgICAgICAgICAgIGNoaWxkLnggPSB4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgIGlmIChkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnggKz0gZHhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGV4dFBhcmVudC54ICs9IGR4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLnggPSB0ZXh0UGFyZW50Lng7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dFBhcmVudC54ID0gY2hpbGQueDtcbiAgICAgICAgaWYgKCFpc1JUTCkge1xuICAgICAgICAgICAgdGV4dFBhcmVudC54ICs9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjaGlsZC55ID0geUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICBpZiAoZHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC55ICs9IGR5QXR0ci5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHRleHRQYXJlbnQueSArPSBkeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC55ID0gdGV4dFBhcmVudC55O1xuICAgICAgICB9XG4gICAgICAgIHRleHRQYXJlbnQueSA9IGNoaWxkLnk7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBjaHVuayBhbmQgaXQncyBib3VuZHNcbiAgICAgICAgdGV4dFBhcmVudC5sZWFmVGV4dHMucHVzaChjaGlsZCk7XG4gICAgICAgIHRleHRQYXJlbnQubWluWCA9IE1hdGgubWluKHRleHRQYXJlbnQubWluWCwgY2hpbGQueCwgY2hpbGQueCArIHdpZHRoKTtcbiAgICAgICAgdGV4dFBhcmVudC5tYXhYID0gTWF0aC5tYXgodGV4dFBhcmVudC5tYXhYLCBjaGlsZC54LCBjaGlsZC54ICsgd2lkdGgpO1xuICAgICAgICBjaGlsZC5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBnZXRDaGlsZEJvdW5kaW5nQm94KGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpMikge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpMl07XG4gICAgICAgIC8vIG5vdCBhIHRleHQgbm9kZT9cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC5nZXRCb3VuZGluZ0JveCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpO1xuICAgICAgICBpZiAoYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRCb3VuZGluZ0JveCA9IHRleHRQYXJlbnQuZ2V0Q2hpbGRCb3VuZGluZ0JveChjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZEJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gICAgcmVuZGVyQ2hpbGQoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkzKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2kzXTtcbiAgICAgICAgY2hpbGQucmVuZGVyKGN0eCk7XG4gICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpPT57XG4gICAgICAgICAgICB0ZXh0UGFyZW50LnJlbmRlckNoaWxkKGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWVhc3VyZVRleHQoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgbWVhc3VyZUNhY2hlICB9ID0gdGhpcztcbiAgICAgICAgaWYgKH5tZWFzdXJlQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtZWFzdXJlQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zdCBtZWFzdXJlID0gdGhpcy5tZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHJlbmRlclRleHQpO1xuICAgICAgICB0aGlzLm1lYXN1cmVDYWNoZSA9IG1lYXN1cmU7XG4gICAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgIH1cbiAgICBtZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHRhcmdldFRleHQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXRUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwYXJlbnQgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjdXN0b21Gb250ID0gcGFyZW50LmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgaWYgKGN1c3RvbUZvbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGN1c3RvbUZvbnQuaXNSVEwgPyB0YXJnZXRUZXh0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiB0YXJnZXRUZXh0O1xuICAgICAgICAgICAgY29uc3QgZHggPSB0b051bWJlcnMocGFyZW50LmdldEF0dHJpYnV0ZSgnZHgnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBtZWFzdXJlID0gMDtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xuICAgICAgICAgICAgICAgIG1lYXN1cmUgKz0gKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgKiBmb250U2l6ZSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGR4W2ldICE9PSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmUgKz0gZHhbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgaWYgKCFjdHgubWVhc3VyZVRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRUZXh0Lmxlbmd0aCAqIDEwO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dChjdHgsIHRydWUpO1xuICAgICAgICBjb25zdCB7IHdpZHRoOiBtZWFzdXJlICB9ID0gY3R4Lm1lYXN1cmVUZXh0KHRhcmdldFRleHQpO1xuICAgICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEluaGVyaXRzIHBvc2l0aW9uYWwgYXR0cmlidXRlcyBmcm9tIHtAbGluayBUZXh0RWxlbWVudH0gcGFyZW50KHMpLiBBdHRyaWJ1dGVzXG4gICAqIGFyZSBvbmx5IGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IHRvIGl0cyBmaXJzdCBjaGlsZC5cbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgYXR0cmlidXRlIG5hbWUuXG4gICAqIEByZXR1cm5zIFRoZSBhdHRyaWJ1dGUgdmFsdWUgb3IgbnVsbC5cbiAgICovIGdldEluaGVyaXRlZEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcyxjb25zaXN0ZW50LXRoaXNcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZShjdXJyZW50IGluc3RhbmNlb2YgVGV4dEVsZW1lbnQgJiYgY3VycmVudC5pc0ZpcnN0Q2hpbGQoKSAmJiBjdXJyZW50LnBhcmVudCl7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRBdHRyID0gY3VycmVudC5wYXJlbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHBhcmVudEF0dHIuaGFzVmFsdWUodHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50QXR0ci5nZXRTdHJpbmcoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgbmV3LnRhcmdldCA9PT0gVGV4dEVsZW1lbnQgPyB0cnVlIDogY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy5sZWFmVGV4dHMgPSBbXTtcbiAgICAgICAgdGhpcy50ZXh0Q2h1bmtTdGFydCA9IDA7XG4gICAgICAgIHRoaXMubWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdGhpcy5tYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLm1lYXN1cmVDYWNoZSA9IC0xO1xuICAgIH1cbn1cblxuY2xhc3MgVFNwYW5FbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICAgIGdldFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIG5ldy50YXJnZXQgPT09IFRTcGFuRWxlbWVudCA/IHRydWUgOiBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3RzcGFuJztcbiAgICAgICAgLy8gaWYgdGhpcyBub2RlIGhhcyBjaGlsZHJlbiwgdGhlbiB0aGV5IG93biB0aGUgdGV4dFxuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgPyAnJyA6IHRoaXMuZ2V0VGV4dEZyb21Ob2RlKCk7XG4gICAgfVxufVxuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRTcGFuRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAndGV4dE5vZGUnO1xuICAgIH1cbn1cblxuY2xhc3MgUGF0aFBhcnNlciBleHRlbmRzIFNWR1BhdGhEYXRhIHtcbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pID0gLTE7XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldmlvdXNDb21tYW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgICAgdGhpcy5jb250cm9sID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuYW5nbGVzID0gW107XG4gICAgfVxuICAgIGlzRW5kKCkge1xuICAgICAgICBjb25zdCB7IGkgLCBjb21tYW5kcyAgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBpID49IGNvbW1hbmRzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzWysrdGhpcy5pXTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgIHJldHVybiBjb21tYW5kO1xuICAgIH1cbiAgICBnZXRQb2ludCgpIHtcbiAgICAgICAgbGV0IHhQcm9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAneCcsIHlQcm9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAneSc7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHRoaXMuY29tbWFuZFt4UHJvcF0sIHRoaXMuY29tbWFuZFt5UHJvcF0pO1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlQWJzb2x1dGUocG9pbnQpO1xuICAgIH1cbiAgICBnZXRBc0NvbnRyb2xQb2ludCh4UHJvcCwgeVByb3ApIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFBvaW50KHhQcm9wLCB5UHJvcCk7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHBvaW50O1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIGdldEFzQ3VycmVudFBvaW50KHhQcm9wLCB5UHJvcCkge1xuICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UG9pbnQoeFByb3AsIHlQcm9wKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gcG9pbnQ7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c0NvbW1hbmQgPSB0aGlzLnByZXZpb3VzQ29tbWFuZC50eXBlO1xuICAgICAgICBpZiAocHJldmlvdXNDb21tYW5kICE9PSBTVkdQYXRoRGF0YS5DVVJWRV9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLlNNT09USF9DVVJWRV9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLlFVQURfVE8gJiYgcHJldmlvdXNDb21tYW5kICE9PSBTVkdQYXRoRGF0YS5TTU9PVEhfUVVBRF9UTykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWZsZWN0IHBvaW50XG4gICAgICAgIGNvbnN0IHsgY3VycmVudDogeyB4OiBjeCAsIHk6IGN5ICB9ICwgY29udHJvbDogeyB4OiBveCAsIHk6IG95ICB9ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoMiAqIGN4IC0gb3gsIDIgKiBjeSAtIG95KTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBtYWtlQWJzb2x1dGUocG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tbWFuZC5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIHBvaW50LnggKz0geDtcbiAgICAgICAgICAgIHBvaW50LnkgKz0geTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIGFkZE1hcmtlcihwb2ludCwgZnJvbSwgcHJpb3JUbykge1xuICAgICAgICBjb25zdCB7IHBvaW50cyAsIGFuZ2xlcyAgfSA9IHRoaXM7XG4gICAgICAgIC8vIGlmIHRoZSBsYXN0IGFuZ2xlIGlzbid0IGZpbGxlZCBpbiBiZWNhdXNlIHdlIGRpZG4ndCBoYXZlIHRoaXMgcG9pbnQgeWV0IC4uLlxuICAgICAgICBpZiAocHJpb3JUbyAmJiBhbmdsZXMubGVuZ3RoID4gMCAmJiAhYW5nbGVzW2FuZ2xlcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgYW5nbGVzW2FuZ2xlcy5sZW5ndGggLSAxXSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0uYW5nbGVUbyhwcmlvclRvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZE1hcmtlckFuZ2xlKHBvaW50LCBmcm9tID8gZnJvbS5hbmdsZVRvKHBvaW50KSA6IG51bGwpO1xuICAgIH1cbiAgICBhZGRNYXJrZXJBbmdsZShwb2ludCwgYW5nbGUpIHtcbiAgICAgICAgdGhpcy5wb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgIHRoaXMuYW5nbGVzLnB1c2goYW5nbGUpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJQb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50cztcbiAgICB9XG4gICAgZ2V0TWFya2VyQW5nbGVzKCkge1xuICAgICAgICBjb25zdCB7IGFuZ2xlcyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGFuZ2xlcy5sZW5ndGg7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICBpZiAoIWFuZ2xlc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGVzW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZXNbaV0gPSBhbmdsZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5nbGVzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXRoKXtcbiAgICAgICAgc3VwZXIocGF0aC8vIEZpeCBzcGFjZXMgYWZ0ZXIgc2lnbnMuXG4gICAgICAgIC5yZXBsYWNlKC8oWytcXC0uXSlcXHMrL2dtLCAnJDEnKS8vIFJlbW92ZSBpbnZhbGlkIHBhcnQuXG4gICAgICAgIC5yZXBsYWNlKC9bXk1tWnpMbEhoVnZDY1NzUXFUdEFhZVxcZFxccy4sKy1dLiovZywgJycpKTtcbiAgICAgICAgdGhpcy5jb250cm9sID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuICAgICAgICB0aGlzLmkgPSAtMTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLmFuZ2xlcyA9IFtdO1xuICAgIH1cbn1cblxuY2xhc3MgUGF0aEVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICAgIHBhdGgoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICAgIHBhdGhQYXJzZXIucmVzZXQoKTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKCFwYXRoUGFyc2VyLmlzRW5kKCkpe1xuICAgICAgICAgICAgc3dpdGNoKHBhdGhQYXJzZXIubmV4dCgpLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5NT1ZFX1RPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhNKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoTChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkhPUklaX0xJTkVfVE86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aEgoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5WRVJUX0xJTkVfVE86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFYoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQyhjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9DVVJWRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoUyhjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFEoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfUVVBRF9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoVChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQShjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNMT1NFX1BBVEg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFooY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gICAgZ2V0Qm91bmRpbmdCb3goX2N0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoKCk7XG4gICAgfVxuICAgIGdldE1hcmtlcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHBhdGhQYXJzZXIuZ2V0TWFya2VyUG9pbnRzKCk7XG4gICAgICAgIGNvbnN0IGFuZ2xlcyA9IHBhdGhQYXJzZXIuZ2V0TWFya2VyQW5nbGVzKCk7XG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSBwb2ludHMubWFwKChwb2ludCwgaSk9PltcbiAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgICBhbmdsZXNbaV1cbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfVxuICAgIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgICB0aGlzLnBhdGgoY3R4KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5zY3JlZW4ubW91c2UuY2hlY2tQYXRoKHRoaXMsIGN0eCk7XG4gICAgICAgIGNvbnN0IGZpbGxSdWxlU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbC1ydWxlJyk7XG4gICAgICAgIGlmIChjdHguZmlsbFN0eWxlICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKGZpbGxSdWxlU3R5bGVQcm9wLmdldFN0cmluZygnaW5oZXJpdCcpICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbChmaWxsUnVsZVN0eWxlUHJvcC5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgndmVjdG9yLWVmZmVjdCcpLmdldFN0cmluZygpID09PSAnbm9uLXNjYWxpbmctc3Ryb2tlJykge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMoKTtcbiAgICAgICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlcnNMYXN0SW5kZXggPSBtYXJrZXJzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXJTdGFydFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ21hcmtlci1zdGFydCcpO1xuICAgICAgICAgICAgY29uc3QgbWFya2VyTWlkU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLW1pZCcpO1xuICAgICAgICAgICAgY29uc3QgbWFya2VyRW5kU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLWVuZCcpO1xuICAgICAgICAgICAgaWYgKG1hcmtlclN0YXJ0U3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya2VyID0gbWFya2VyU3RhcnRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwb2ludCwgYW5nbGVdID0gbWFya2Vyc1swXTtcbiAgICAgICAgICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgcG9pbnQsIGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrZXJNaWRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJNaWRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBtYXJrZXJzTGFzdEluZGV4OyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbcG9pbnQsIGFuZ2xlXSA9IG1hcmtlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5yZW5kZXIoY3R4LCBwb2ludCwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrZXJFbmRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJFbmRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwb2ludCwgYW5nbGVdID0gbWFya2Vyc1ttYXJrZXJzTGFzdEluZGV4XTtcbiAgICAgICAgICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgcG9pbnQsIGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aE0ocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgcGF0aFBhcnNlci5zdGFydCA9IHBhdGhQYXJzZXIuY3VycmVudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhNKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBwb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhNKHBhdGhQYXJzZXIpO1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gcG9pbnQ7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50KTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhdGhMKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICB9ID0gcGF0aFBhcnNlcjtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgcG9pbnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGF0aEwoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgICBjb25zdCB7IHBhdGhQYXJzZXIgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgLCBwb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhMKHBhdGhQYXJzZXIpO1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gcG9pbnQ7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhdGhIKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgY29tbWFuZCAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KChjb21tYW5kLnJlbGF0aXZlID8gY3VycmVudC54IDogMCkgKyBjb21tYW5kLngsIGN1cnJlbnQueSk7XG4gICAgICAgIHBhdGhQYXJzZXIuY3VycmVudCA9IHBvaW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhIKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgcG9pbnQgIH0gPSBQYXRoRWxlbWVudC5wYXRoSChwYXRoUGFyc2VyKTtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHBvaW50O1xuICAgICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXRoVihwYXRoUGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAsIGNvbW1hbmQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludChjdXJyZW50LngsIChjb21tYW5kLnJlbGF0aXZlID8gY3VycmVudC55IDogMCkgKyBjb21tYW5kLnkpO1xuICAgICAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwb2ludDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBwb2ludFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXRoVihjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAsIHBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFYocGF0aFBhcnNlcik7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBwb2ludDtcbiAgICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIocG9pbnQsIGN1cnJlbnQpO1xuICAgICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aEMocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICBjb25zdCBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0UG9pbnQoJ3gxJywgJ3kxJyk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gyJywgJ3kyJyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXRoQyhjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAsIHBvaW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aEMocGF0aFBhcnNlcik7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBwb2ludCk7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZEJlemllckN1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aFMocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICBjb25zdCBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gyJywgJ3kyJyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXRoUyhjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAsIHBvaW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFMocGF0aFBhcnNlcik7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBwb2ludCk7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZEJlemllckN1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aFEocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICBjb25zdCBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ29udHJvbFBvaW50KCd4MScsICd5MScpO1xuICAgICAgICBjb25zdCBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY29udHJvbFBvaW50LFxuICAgICAgICAgICAgY3VycmVudFBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhRKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFEocGF0aFBhcnNlcik7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBjb250cm9sUG9pbnQpO1xuICAgICAgICBib3VuZGluZ0JveC5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhdGhUKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICB9ID0gcGF0aFBhcnNlcjtcbiAgICAgICAgY29uc3QgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKTtcbiAgICAgICAgcGF0aFBhcnNlci5jb250cm9sID0gY29udHJvbFBvaW50O1xuICAgICAgICBjb25zdCBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY29udHJvbFBvaW50LFxuICAgICAgICAgICAgY3VycmVudFBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhUKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFQocGF0aFBhcnNlcik7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBjb250cm9sUG9pbnQpO1xuICAgICAgICBib3VuZGluZ0JveC5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhdGhBKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgY29tbWFuZCAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICAgIGxldCB7IHJYICwgclkgLCB4Um90ICwgbEFyY0ZsYWcgLCBzd2VlcEZsYWcgIH0gPSBjb21tYW5kO1xuICAgICAgICBjb25zdCB4QXhpc1JvdGF0aW9uID0geFJvdCAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgY29uc3QgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAvLyBDb252ZXJzaW9uIGZyb20gZW5kcG9pbnQgdG8gY2VudGVyIHBhcmFtZXRlcml6YXRpb25cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgIC8vIHgxJywgeTEnXG4gICAgICAgIGNvbnN0IGN1cnJwID0gbmV3IFBvaW50KE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueCAtIGN1cnJlbnRQb2ludC54KSAvIDIgKyBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnkgLSBjdXJyZW50UG9pbnQueSkgLyAyLCAtTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC54IC0gY3VycmVudFBvaW50LngpIC8gMiArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueSAtIGN1cnJlbnRQb2ludC55KSAvIDIpO1xuICAgICAgICAvLyBhZGp1c3QgcmFkaWlcbiAgICAgICAgY29uc3QgbCA9IE1hdGgucG93KGN1cnJwLngsIDIpIC8gTWF0aC5wb3coclgsIDIpICsgTWF0aC5wb3coY3VycnAueSwgMikgLyBNYXRoLnBvdyhyWSwgMik7XG4gICAgICAgIGlmIChsID4gMSkge1xuICAgICAgICAgICAgclggKj0gTWF0aC5zcXJ0KGwpO1xuICAgICAgICAgICAgclkgKj0gTWF0aC5zcXJ0KGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN4JywgY3knXG4gICAgICAgIGxldCBzID0gKGxBcmNGbGFnID09PSBzd2VlcEZsYWcgPyAtMSA6IDEpICogTWF0aC5zcXJ0KChNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhyWSwgMikgLSBNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhjdXJycC55LCAyKSAtIE1hdGgucG93KHJZLCAyKSAqIE1hdGgucG93KGN1cnJwLngsIDIpKSAvIChNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhjdXJycC55LCAyKSArIE1hdGgucG93KHJZLCAyKSAqIE1hdGgucG93KGN1cnJwLngsIDIpKSk7XG4gICAgICAgIGlmIChpc05hTihzKSkge1xuICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3BwID0gbmV3IFBvaW50KHMgKiByWCAqIGN1cnJwLnkgLyByWSwgcyAqIC1yWSAqIGN1cnJwLnggLyByWCk7XG4gICAgICAgIC8vIGN4LCBjeVxuICAgICAgICBjb25zdCBjZW50cCA9IG5ldyBQb2ludCgoY3VycmVudC54ICsgY3VycmVudFBvaW50LngpIC8gMiArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogY3BwLnggLSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIGNwcC55LCAoY3VycmVudC55ICsgY3VycmVudFBvaW50LnkpIC8gMiArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnggKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC55KTtcbiAgICAgICAgLy8gaW5pdGlhbCBhbmdsZVxuICAgICAgICBjb25zdCBhMSA9IHZlY3RvcnNBbmdsZShbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMFxuICAgICAgICBdLCBbXG4gICAgICAgICAgICAoY3VycnAueCAtIGNwcC54KSAvIHJYLFxuICAgICAgICAgICAgKGN1cnJwLnkgLSBjcHAueSkgLyByWVxuICAgICAgICBdKSAvLyDOuDFcbiAgICAgICAgO1xuICAgICAgICAvLyBhbmdsZSBkZWx0YVxuICAgICAgICBjb25zdCB1ID0gW1xuICAgICAgICAgICAgKGN1cnJwLnggLSBjcHAueCkgLyByWCxcbiAgICAgICAgICAgIChjdXJycC55IC0gY3BwLnkpIC8gcllcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgdiA9IFtcbiAgICAgICAgICAgICgtY3VycnAueCAtIGNwcC54KSAvIHJYLFxuICAgICAgICAgICAgKC1jdXJycC55IC0gY3BwLnkpIC8gcllcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGFkID0gdmVjdG9yc0FuZ2xlKHUsIHYpIC8vIM6UzrhcbiAgICAgICAgO1xuICAgICAgICBpZiAodmVjdG9yc1JhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICAgICAgICBhZCA9IE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlY3RvcnNSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICAgICAgICBhZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludCxcbiAgICAgICAgICAgIHJYLFxuICAgICAgICAgICAgclksXG4gICAgICAgICAgICBzd2VlcEZsYWcsXG4gICAgICAgICAgICB4QXhpc1JvdGF0aW9uLFxuICAgICAgICAgICAgY2VudHAsXG4gICAgICAgICAgICBhMSxcbiAgICAgICAgICAgIGFkXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhBKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50UG9pbnQgLCByWCAsIHJZICwgc3dlZXBGbGFnICwgeEF4aXNSb3RhdGlvbiAsIGNlbnRwICwgYTEgLCBhZCAgfSA9IFBhdGhFbGVtZW50LnBhdGhBKHBhdGhQYXJzZXIpO1xuICAgICAgICAvLyBmb3IgbWFya2Vyc1xuICAgICAgICBjb25zdCBkaXIgPSAxIC0gc3dlZXBGbGFnID8gMSA6IC0xO1xuICAgICAgICBjb25zdCBhaCA9IGExICsgZGlyICogKGFkIC8gMik7XG4gICAgICAgIGNvbnN0IGhhbGZXYXkgPSBuZXcgUG9pbnQoY2VudHAueCArIHJYICogTWF0aC5jb3MoYWgpLCBjZW50cC55ICsgclkgKiBNYXRoLnNpbihhaCkpO1xuICAgICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlckFuZ2xlKGhhbGZXYXksIGFoIC0gZGlyICogTWF0aC5QSSAvIDIpO1xuICAgICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlckFuZ2xlKGN1cnJlbnRQb2ludCwgYWggLSBkaXIgKiBNYXRoLlBJKTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KSAvLyBUT0RPOiB0aGlzIGlzIHRvbyBuYWl2ZSwgbWFrZSBpdCBiZXR0ZXJcbiAgICAgICAgO1xuICAgICAgICBpZiAoY3R4ICYmICFpc05hTihhMSkgJiYgIWlzTmFOKGFkKSkge1xuICAgICAgICAgICAgY29uc3QgciA9IHJYID4gclkgPyByWCA6IHJZO1xuICAgICAgICAgICAgY29uc3Qgc3ggPSByWCA+IHJZID8gMSA6IHJYIC8gclk7XG4gICAgICAgICAgICBjb25zdCBzeSA9IHJYID4gclkgPyByWSAvIHJYIDogMTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2VudHAueCwgY2VudHAueSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHhBeGlzUm90YXRpb24pO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHN4LCBzeSk7XG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIGExLCBhMSArIGFkLCBCb29sZWFuKDEgLSBzd2VlcEZsYWcpKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc3gsIDEgLyBzeSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKC14QXhpc1JvdGF0aW9uKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWNlbnRwLngsIC1jZW50cC55KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aFoocGF0aFBhcnNlcikge1xuICAgICAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwYXRoUGFyc2VyLnN0YXJ0O1xuICAgIH1cbiAgICBwYXRoWihjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIFBhdGhFbGVtZW50LnBhdGhaKHRoaXMucGF0aFBhcnNlcik7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgY2xvc2UgcGF0aCBpZiBpdCBpcyBub3QgYSBzdHJhaWdodCBsaW5lXG4gICAgICAgICAgICBpZiAoYm91bmRpbmdCb3gueDEgIT09IGJvdW5kaW5nQm94LngyICYmIGJvdW5kaW5nQm94LnkxICE9PSBib3VuZGluZ0JveC55Mikge1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BhdGgnO1xuICAgICAgICB0aGlzLnBhdGhQYXJzZXIgPSBuZXcgUGF0aFBhcnNlcih0aGlzLmdldEF0dHJpYnV0ZSgnZCcpLmdldFN0cmluZygpKTtcbiAgICB9XG59XG5cbmNsYXNzIFNWR0VsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICAgIHNldENvbnRleHQoY3R4KSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHNjcmVlbiAsIHdpbmRvdyAgfSA9IGRvY3VtZW50O1xuICAgICAgICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgICAgICBzY3JlZW4uc2V0RGVmYXVsdHMoY3R4KTtcbiAgICAgICAgaWYgKCdzdHlsZScgaW4gY2FudmFzICYmIHR5cGVvZiBjdHguZm9udCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGN0eC5mb250ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2FudmFzKS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250Jyk7XG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZVByb3AgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdmb250U2l6ZScsIEZvbnQucGFyc2UoY3R4LmZvbnQpLmZvbnRTaXplKTtcbiAgICAgICAgICAgIGlmIChmb250U2l6ZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJvb3RFbVNpemUgPSBmb250U2l6ZVByb3AuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZW1TaXplID0gZG9jdW1lbnQucm9vdEVtU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgbmV3IHZpZXcgcG9ydFxuICAgICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCd5JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3knLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyB3aWR0aCAsIGhlaWdodCAgfSA9IHNjcmVlbi52aWV3UG9ydDtcbiAgICAgICAgaWYgKCF0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgdHJ1ZSkuc2V0VmFsdWUoJzEwMCUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcsIHRydWUpLnNldFZhbHVlKCcxMDAlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmdldFN0eWxlKCdjb2xvcicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJywgdHJ1ZSkuc2V0VmFsdWUoJ2JsYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmWEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWCcpO1xuICAgICAgICBjb25zdCByZWZZQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZZJyk7XG4gICAgICAgIGNvbnN0IHZpZXdCb3hBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKTtcbiAgICAgICAgY29uc3Qgdmlld0JveCA9IHZpZXdCb3hBdHRyLmhhc1ZhbHVlKCkgPyB0b051bWJlcnModmlld0JveEF0dHIuZ2V0U3RyaW5nKCkpIDogbnVsbDtcbiAgICAgICAgY29uc3QgY2xpcCA9ICF0aGlzLnJvb3QgJiYgdGhpcy5nZXRTdHlsZSgnb3ZlcmZsb3cnKS5nZXRWYWx1ZSgnaGlkZGVuJykgIT09ICd2aXNpYmxlJztcbiAgICAgICAgbGV0IG1pblggPSAwO1xuICAgICAgICBsZXQgbWluWSA9IDA7XG4gICAgICAgIGxldCBjbGlwWCA9IDA7XG4gICAgICAgIGxldCBjbGlwWSA9IDA7XG4gICAgICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICAgICAgICBtaW5YID0gdmlld0JveFswXTtcbiAgICAgICAgICAgIG1pblkgPSB2aWV3Qm94WzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXJrZXInKSB7XG4gICAgICAgICAgICAgICAgY2xpcFggPSBtaW5YO1xuICAgICAgICAgICAgICAgIGNsaXBZID0gbWluWTtcbiAgICAgICAgICAgICAgICBtaW5YID0gMDtcbiAgICAgICAgICAgICAgICBtaW5ZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY3JlZW4udmlld1BvcnQuc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBvZiB0cmFuc2Zvcm0tb3JpZ2luIGlzIGNlbnRlciBvbmx5IGZvciByb290IFNWRyBlbGVtZW50c1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3RyYW5zZm9ybS1vcmlnaW5cbiAgICAgICAgaWYgKHRoaXMubm9kZSAvLyBpcyBub3QgdGVtcG9yYXJ5IFNWR0VsZW1lbnRcbiAgICAgICAgICYmICghdGhpcy5wYXJlbnQgfHwgKChyZWYgPSB0aGlzLm5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYubm9kZU5hbWUpID09PSAnZm9yZWlnbk9iamVjdCcpICYmIHRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCB0cnVlLCB0cnVlKS5zZXRWYWx1ZSgnNTAlIDUwJScpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnNldENvbnRleHQoY3R4KTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpKTtcbiAgICAgICAgaWYgKHZpZXdCb3gpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdmlld0JveFsyXTtcbiAgICAgICAgICAgIGhlaWdodCA9IHZpZXdCb3hbM107XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuc2V0Vmlld0JveCh7XG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICBhc3BlY3RSYXRpbzogdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIHdpZHRoOiBzY3JlZW4udmlld1BvcnQud2lkdGgsXG4gICAgICAgICAgICBkZXNpcmVkV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBzY3JlZW4udmlld1BvcnQuaGVpZ2h0LFxuICAgICAgICAgICAgZGVzaXJlZEhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgbWluWCxcbiAgICAgICAgICAgIG1pblksXG4gICAgICAgICAgICByZWZYOiByZWZYQXR0ci5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgcmVmWTogcmVmWUF0dHIuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgIGNsaXAsXG4gICAgICAgICAgICBjbGlwWCxcbiAgICAgICAgICAgIGNsaXBZXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmlld0JveCkge1xuICAgICAgICAgICAgc2NyZWVuLnZpZXdQb3J0LnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgIHNjcmVlbi52aWV3UG9ydC5zZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyQ29udGV4dChjdHgpIHtcbiAgICAgICAgc3VwZXIuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQuc2NyZWVuLnZpZXdQb3J0LnJlbW92ZUN1cnJlbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJlc2l6ZSBTVkcgdG8gZml0IGluIGdpdmVuIHNpemUuXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gaGVpZ2h0XG4gICAqIEBwYXJhbSBwcmVzZXJ2ZUFzcGVjdFJhdGlvXG4gICAqLyByZXNpemUod2lkdGgpIHtcbiAgICAgICAgbGV0IGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogd2lkdGgsIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgICBjb25zdCB3aWR0aEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgdmlld0JveEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgICAgICBjb25zdCBzdHlsZUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luV2lkdGggPSB3aWR0aEF0dHIuZ2V0TnVtYmVyKDApO1xuICAgICAgICBjb25zdCBvcmlnaW5IZWlnaHQgPSBoZWlnaHRBdHRyLmdldE51bWJlcigwKTtcbiAgICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlc2VydmVBc3BlY3RSYXRpbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsIHRydWUpLnNldFZhbHVlKHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpb0F0dHIuc2V0VmFsdWUocHJlc2VydmVBc3BlY3RSYXRpb0F0dHIuZ2V0U3RyaW5nKCkucmVwbGFjZSgvXlxccyooXFxTLipcXFMpXFxzKiQvLCAnJDEnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdpZHRoQXR0ci5zZXRWYWx1ZSh3aWR0aCk7XG4gICAgICAgIGhlaWdodEF0dHIuc2V0VmFsdWUoaGVpZ2h0KTtcbiAgICAgICAgaWYgKCF2aWV3Qm94QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB2aWV3Qm94QXR0ci5zZXRWYWx1ZShcIjAgMCBcIi5jb25jYXQob3JpZ2luV2lkdGggfHwgd2lkdGgsIFwiIFwiKS5jb25jYXQob3JpZ2luSGVpZ2h0IHx8IGhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGhTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJyk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpO1xuICAgICAgICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHdpZHRoU3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHRTdHlsZS5zZXRWYWx1ZShcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3N2Zyc7XG4gICAgICAgIHRoaXMucm9vdCA9IGZhbHNlO1xuICAgIH1cbn1cblxuY2xhc3MgUmVjdEVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gICAgcGF0aChjdHgpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgZmFsc2UsIHRydWUpLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCBmYWxzZSwgdHJ1ZSkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGNvbnN0IHJ4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeCcpO1xuICAgICAgICBjb25zdCByeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncnknKTtcbiAgICAgICAgbGV0IHJ4ID0gcnhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgICBsZXQgcnkgPSByeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGlmIChyeEF0dHIuaGFzVmFsdWUoKSAmJiAhcnlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJ5ID0gcng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ5QXR0ci5oYXNWYWx1ZSgpICYmICFyeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcnggPSByeTtcbiAgICAgICAgfVxuICAgICAgICByeCA9IE1hdGgubWluKHJ4LCB3aWR0aCAvIDIpO1xuICAgICAgICByeSA9IE1hdGgubWluKHJ5LCBoZWlnaHQgLyAyKTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY29uc3QgS0FQUEEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpIC8vIGFsd2F5cyBzdGFydCB0aGUgcGF0aCBzbyB3ZSBkb24ndCBmaWxsIHByaW9yIHBhdGhzXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ID4gMCAmJiB3aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyByeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHdpZHRoIC0gcnggKyBLQVBQQSAqIHJ4LCB5LCB4ICsgd2lkdGgsIHkgKyByeSAtIEtBUFBBICogcnksIHggKyB3aWR0aCwgeSArIHJ5KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJ5KTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByeSArIEtBUFBBICogcnksIHggKyB3aWR0aCAtIHJ4ICsgS0FQUEEgKiByeCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcngsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgcnggLSBLQVBQQSAqIHJ4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcnkgKyBLQVBQQSAqIHJ5LCB4LCB5ICsgaGVpZ2h0IC0gcnkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJ5KTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5ICsgcnkgLSBLQVBQQSAqIHJ5LCB4ICsgcnggLSBLQVBQQSAqIHJ4LCB5LCB4ICsgcngsIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgfVxuICAgIGdldE1hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdyZWN0JztcbiAgICB9XG59XG5cbmNsYXNzIENpcmNsZUVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gICAgcGF0aChjdHgpIHtcbiAgICAgICAgY29uc3QgY3ggPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgY3kgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0UGl4ZWxzKCk7XG4gICAgICAgIGlmIChjdHggJiYgciA+IDApIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmMoY3gsIGN5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goY3ggLSByLCBjeSAtIHIsIGN4ICsgciwgY3kgKyByKTtcbiAgICB9XG4gICAgZ2V0TWFya2VycygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NpcmNsZSc7XG4gICAgfVxufVxuXG5jbGFzcyBFbGxpcHNlRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgICBwYXRoKGN0eCkge1xuICAgICAgICBjb25zdCBLQVBQQSA9IDQgKiAoKE1hdGguc3FydCgyKSAtIDEpIC8gMyk7XG4gICAgICAgIGNvbnN0IHJ4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHJ5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGNvbnN0IGN4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IGN5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGlmIChjdHggJiYgcnggPiAwICYmIHJ5ID4gMCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjeCArIHJ4LCBjeSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCArIHJ4LCBjeSArIEtBUFBBICogcnksIGN4ICsgS0FQUEEgKiByeCwgY3kgKyByeSwgY3gsIGN5ICsgcnkpO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggLSBLQVBQQSAqIHJ4LCBjeSArIHJ5LCBjeCAtIHJ4LCBjeSArIEtBUFBBICogcnksIGN4IC0gcngsIGN5KTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gcngsIGN5IC0gS0FQUEEgKiByeSwgY3ggLSBLQVBQQSAqIHJ4LCBjeSAtIHJ5LCBjeCwgY3kgLSByeSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCArIEtBUFBBICogcngsIGN5IC0gcnksIGN4ICsgcngsIGN5IC0gS0FQUEEgKiByeSwgY3ggKyByeCwgY3kpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goY3ggLSByeCwgY3kgLSByeSwgY3ggKyByeCwgY3kgKyByeSk7XG4gICAgfVxuICAgIGdldE1hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdlbGxpcHNlJztcbiAgICB9XG59XG5cbmNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICAgIGdldFBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQb2ludCh0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5nZXRQaXhlbHMoJ3gnKSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0UGl4ZWxzKCd5JykpLFxuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXRQaXhlbHMoJ3knKSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcGF0aChjdHgpIHtcbiAgICAgICAgY29uc3QgW3sgeDogeDAgLCB5OiB5MCAgfSwgeyB4OiB4MSAsIHk6IHkxICB9XSA9IHRoaXMuZ2V0UG9pbnRzKCk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDEsIHkxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxKTtcbiAgICB9XG4gICAgZ2V0TWFya2VycygpIHtcbiAgICAgICAgY29uc3QgW3AwLCBwMV0gPSB0aGlzLmdldFBvaW50cygpO1xuICAgICAgICBjb25zdCBhID0gcDAuYW5nbGVUbyhwMSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgcDAsXG4gICAgICAgICAgICAgICAgYVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBwMSxcbiAgICAgICAgICAgICAgICBhXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2xpbmUnO1xuICAgIH1cbn1cblxuY2xhc3MgUG9seWxpbmVFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICAgIHBhdGgoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgcG9pbnRzICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgW3sgeDogeDAgLCB5OiB5MCAgfV0gPSBwb2ludHM7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KHgwLCB5MCk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgfVxuICAgICAgICBwb2ludHMuZm9yRWFjaCgocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyB4ICwgeSAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gICAgZ2V0TWFya2VycygpIHtcbiAgICAgICAgY29uc3QgeyBwb2ludHMgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbWFya2VycyA9IFtdO1xuICAgICAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQsIGkpPT57XG4gICAgICAgICAgICBpZiAoaSA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya2Vycy5wdXNoKFtcbiAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgICBwb2ludC5hbmdsZVRvKHBvaW50c1tpICsgMV0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXJrZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1hcmtlcnMucHVzaChbXG4gICAgICAgICAgICAgICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV1bMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BvbHlsaW5lJztcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBQb2ludC5wYXJzZVBhdGgodGhpcy5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpLmdldFN0cmluZygpKTtcbiAgICB9XG59XG5cbmNsYXNzIFBvbHlnb25FbGVtZW50IGV4dGVuZHMgUG9seWxpbmVFbGVtZW50IHtcbiAgICBwYXRoKGN0eCkge1xuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IHN1cGVyLnBhdGgoY3R4KTtcbiAgICAgICAgY29uc3QgW3sgeCAsIHkgIH1dID0gdGhpcy5wb2ludHM7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdwb2x5Z29uJztcbiAgICB9XG59XG5cbmNsYXNzIFBhdHRlcm5FbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgY3JlYXRlUGF0dGVybihjdHgsIF8sIHBhcmVudE9wYWNpdHlQcm9wKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5JywgdHJ1ZSk7XG4gICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuICAgICAgICBjb25zdCBwYXR0ZXJuU3ZnID0gbmV3IFNWR0VsZW1lbnQodGhpcy5kb2N1bWVudCwgbnVsbCk7XG4gICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy52aWV3Qm94ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd2aWV3Qm94JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd3aWR0aCcsIFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnaGVpZ2h0JywgXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnRyYW5zZm9ybSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAndHJhbnNmb3JtJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nKS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgcGF0dGVyblN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IHBhdHRlcm5DYW52YXMgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29uc3QgeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgICAgICBjb25zdCB5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgICAgIGlmICh4QXR0ci5oYXNWYWx1ZSgpICYmIHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHBhdHRlcm5DdHgudHJhbnNsYXRlKHhBdHRyLmdldFBpeGVscygneCcsIHRydWUpLCB5QXR0ci5nZXRQaXhlbHMoJ3knLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudE9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzWydmaWxsLW9wYWNpdHknXSA9IHBhcmVudE9wYWNpdHlQcm9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0aGlzLnN0eWxlcywgJ2ZpbGwtb3BhY2l0eScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbmRlciAzeDMgZ3JpZCBzbyB3aGVuIHdlIHRyYW5zZm9ybSB0aGVyZSdzIG5vIHdoaXRlIHNwYWNlIG9uIGVkZ2VzXG4gICAgICAgIGZvcihsZXQgeCA9IC0xOyB4IDw9IDE7IHgrKyl7XG4gICAgICAgICAgICBmb3IobGV0IHkgPSAtMTsgeSA8PSAxOyB5Kyspe1xuICAgICAgICAgICAgICAgIHBhdHRlcm5DdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy54ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd4JywgeCAqIHBhdHRlcm5DYW52YXMud2lkdGgpO1xuICAgICAgICAgICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd5JywgeSAqIHBhdHRlcm5DYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuU3ZnLnJlbmRlcihwYXR0ZXJuQ3R4KTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4ocGF0dGVybkNhbnZhcywgJ3JlcGVhdCcpO1xuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncGF0dGVybic7XG4gICAgfVxufVxuXG5jbGFzcyBNYXJrZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgcmVuZGVyKGN0eCwgcG9pbnQsIGFuZ2xlKSB7XG4gICAgICAgIGlmICghcG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IG9yaWVudCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdvcmllbnQnKS5nZXRTdHJpbmcoJ2F1dG8nKTtcbiAgICAgICAgY29uc3QgbWFya2VyVW5pdHMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VyVW5pdHMnKS5nZXRTdHJpbmcoJ3N0cm9rZVdpZHRoJyk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgIGlmIChvcmllbnQgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlclVuaXRzID09PSAnc3Ryb2tlV2lkdGgnKSB7XG4gICAgICAgICAgICBjdHguc2NhbGUoY3R4LmxpbmVXaWR0aCwgY3R4LmxpbmVXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50XG4gICAgICAgIGNvbnN0IG1hcmtlclN2ZyA9IG5ldyBTVkdFbGVtZW50KHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICBtYXJrZXJTdmcudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMudmlld0JveCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAndmlld0JveCcsIHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0VmFsdWUoKSk7XG4gICAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnJlZlggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3JlZlgnLCB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWCcpLmdldFZhbHVlKCkpO1xuICAgICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5yZWZZID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdyZWZZJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlknKS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3dpZHRoJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlcldpZHRoJykuZ2V0VmFsdWUoKSk7XG4gICAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnaGVpZ2h0JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlckhlaWdodCcpLmdldFZhbHVlKCkpO1xuICAgICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5vdmVyZmxvdyA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnb3ZlcmZsb3cnLCB0aGlzLmdldEF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuZmlsbCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnZmlsbCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdmaWxsJykuZ2V0Q29sb3IoJ2JsYWNrJykpO1xuICAgICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5zdHJva2UgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3N0cm9rZScsIHRoaXMuZ2V0QXR0cmlidXRlKCdzdHJva2UnKS5nZXRWYWx1ZSgnbm9uZScpKTtcbiAgICAgICAgbWFya2VyU3ZnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgbWFya2VyU3ZnLnJlbmRlcihjdHgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBpZiAobWFya2VyVW5pdHMgPT09ICdzdHJva2VXaWR0aCcpIHtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gY3R4LmxpbmVXaWR0aCwgMSAvIGN0eC5saW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmllbnQgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtYW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnbWFya2VyJztcbiAgICB9XG59XG5cbmNsYXNzIERlZnNFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgIC8vIE5PT1BcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZGVmcyc7XG4gICAgfVxufVxuXG5jbGFzcyBHRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gICAgZ2V0Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpPT57XG4gICAgICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZyc7XG4gICAgfVxufVxuXG5jbGFzcyBHcmFkaWVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBnZXRHcmFkaWVudFVuaXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnKS5nZXRTdHJpbmcoJ29iamVjdEJvdW5kaW5nQm94Jyk7XG4gICAgfVxuICAgIGNyZWF0ZUdyYWRpZW50KGN0eCwgZWxlbWVudCwgcGFyZW50T3BhY2l0eVByb3ApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLCBjb25zaXN0ZW50LXRoaXNcbiAgICAgICAgbGV0IHN0b3BzQ29udGFpbmVyID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHN0b3BzQ29udGFpbmVyID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0U3RvcENvbnRhaW5lcihzdG9wc0NvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdG9wcyAgfSA9IHN0b3BzQ29udGFpbmVyO1xuICAgICAgICBjb25zdCBncmFkaWVudCA9IHRoaXMuZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KTtcbiAgICAgICAgaWYgKCFncmFkaWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkUGFyZW50T3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCwgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV0uY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BzLmZvckVhY2goKHN0b3ApPT57XG4gICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5vZmZzZXQsIHRoaXMuYWRkUGFyZW50T3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCwgc3RvcC5jb2xvcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIC8vIHJlbmRlciBhcyB0cmFuc2Zvcm1lZCBwYXR0ZXJuIG9uIHRlbXBvcmFyeSBjYW52YXNcbiAgICAgICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBNQVhfVklSVFVBTF9QSVhFTFMgIH0gPSBTY3JlZW47XG4gICAgICAgICAgICBjb25zdCB7IHZpZXdQb3J0ICB9ID0gZG9jdW1lbnQuc2NyZWVuO1xuICAgICAgICAgICAgY29uc3Qgcm9vdFZpZXcgPSB2aWV3UG9ydC5nZXRSb290KCk7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gbmV3IFJlY3RFbGVtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlcy54ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneCcsIC1NQVhfVklSVFVBTF9QSVhFTFMgLyAzKTtcbiAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneScsIC1NQVhfVklSVFVBTF9QSVhFTFMgLyAzKTtcbiAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgTUFYX1ZJUlRVQUxfUElYRUxTKTtcbiAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdoZWlnaHQnLCBNQVhfVklSVFVBTF9QSVhFTFMpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBuZXcgR0VsZW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgZ3JvdXAuYXR0cmlidXRlcy50cmFuc2Zvcm0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd0cmFuc2Zvcm0nLCB0aGlzLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIGdyb3VwLmNoaWxkcmVuID0gW1xuICAgICAgICAgICAgICAgIHJlY3RcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuU3ZnID0gbmV3IFNWR0VsZW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd4JywgMCk7XG4gICAgICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3knLCAwKTtcbiAgICAgICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgcm9vdFZpZXcud2lkdGgpO1xuICAgICAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIHJvb3RWaWV3LmhlaWdodCk7XG4gICAgICAgICAgICBwYXR0ZXJuU3ZnLmNoaWxkcmVuID0gW1xuICAgICAgICAgICAgICAgIGdyb3VwXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybkNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyhyb290Vmlldy53aWR0aCwgcm9vdFZpZXcuaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5DdHggPSBwYXR0ZXJuQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgICAgICAgcGF0dGVyblN2Zy5yZW5kZXIocGF0dGVybkN0eCk7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybkN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm5DYW52YXMsICduby1yZXBlYXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICAgIGluaGVyaXRTdG9wQ29udGFpbmVyKHN0b3BzQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5mb3JFYWNoKChhdHRyaWJ1dGVUb0luaGVyaXQpPT57XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuaGFzVmFsdWUoKSAmJiBzdG9wc0NvbnRhaW5lci5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0LCB0cnVlKS5zZXRWYWx1ZShzdG9wc0NvbnRhaW5lci5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIGNvbG9yKSB7XG4gICAgICAgIGlmIChwYXJlbnRPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xvclByb3AgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2NvbG9yJywgY29sb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yUHJvcC5hZGRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wKS5nZXRDb2xvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdCA9IFtcbiAgICAgICAgICAgICdncmFkaWVudFVuaXRzJ1xuICAgICAgICBdO1xuICAgICAgICB0aGlzLnN0b3BzID0gW107XG4gICAgICAgIGNvbnN0IHsgc3RvcHMgLCBjaGlsZHJlbiAgfSA9IHRoaXM7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKT0+e1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdzdG9wJykge1xuICAgICAgICAgICAgICAgIHN0b3BzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIExpbmVhckdyYWRpZW50RWxlbWVudCBleHRlbmRzIEdyYWRpZW50RWxlbWVudCB7XG4gICAgZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGlzQm91bmRpbmdCb3hVbml0cyA9IHRoaXMuZ2V0R3JhZGllbnRVbml0cygpID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnO1xuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KSA6IG51bGw7XG4gICAgICAgIGlmIChpc0JvdW5kaW5nQm94VW5pdHMgJiYgIWJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd4MScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneDInLCB0cnVlKS5zZXRWYWx1ZSgxKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHgxID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgeTEgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY29uc3QgeDIgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCB5MiA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmdldFBpeGVscygneScpO1xuICAgICAgICBpZiAoeDEgPT09IHgyICYmIHkxID09PSB5Mikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Mik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnbGluZWFyR3JhZGllbnQnO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgneDEnLCAneTEnLCAneDInLCAneTInKTtcbiAgICB9XG59XG5cbmNsYXNzIFJhZGlhbEdyYWRpZW50RWxlbWVudCBleHRlbmRzIEdyYWRpZW50RWxlbWVudCB7XG4gICAgZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGlzQm91bmRpbmdCb3hVbml0cyA9IHRoaXMuZ2V0R3JhZGllbnRVbml0cygpID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnO1xuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcbiAgICAgICAgaWYgKGlzQm91bmRpbmdCb3hVbml0cyAmJiAhYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JywgdHJ1ZSkuc2V0VmFsdWUoJzUwJScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JywgdHJ1ZSkuc2V0VmFsdWUoJzUwJScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgncicsIHRydWUpLnNldFZhbHVlKCc1MCUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjeCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IGN5ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGxldCBmeCA9IGN4O1xuICAgICAgICBsZXQgZnkgPSBjeTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdmeCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGZ4ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnZngnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2Z5JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgZnkgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z5JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gaXNCb3VuZGluZ0JveFVuaXRzID8gKGJvdW5kaW5nQm94LndpZHRoICsgYm91bmRpbmdCb3guaGVpZ2h0KSAvIDIgKiB0aGlzLmdldEF0dHJpYnV0ZSgncicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5nZXRQaXhlbHMoKTtcbiAgICAgICAgY29uc3QgZnIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZnInKS5nZXRQaXhlbHMoKTtcbiAgICAgICAgcmV0dXJuIGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChmeCwgZnksIGZyLCBjeCwgY3ksIHIpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3JhZGlhbEdyYWRpZW50JztcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ2N4JywgJ2N5JywgJ3InLCAnZngnLCAnZnknLCAnZnInKTtcbiAgICB9XG59XG5cbmNsYXNzIFN0b3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdG9wJztcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpLmdldE51bWJlcigpKSk7XG4gICAgICAgIGNvbnN0IHN0b3BPcGFjaXR5ID0gdGhpcy5nZXRTdHlsZSgnc3RvcC1vcGFjaXR5Jyk7XG4gICAgICAgIGxldCBzdG9wQ29sb3IgPSB0aGlzLmdldFN0eWxlKCdzdG9wLWNvbG9yJywgdHJ1ZSk7XG4gICAgICAgIGlmIChzdG9wQ29sb3IuZ2V0U3RyaW5nKCkgPT09ICcnKSB7XG4gICAgICAgICAgICBzdG9wQ29sb3Iuc2V0VmFsdWUoJyMwMDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcE9wYWNpdHkuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgc3RvcENvbG9yID0gc3RvcENvbG9yLmFkZE9wYWNpdHkoc3RvcE9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmNvbG9yID0gc3RvcENvbG9yLmdldENvbG9yKCk7XG4gICAgfVxufVxuXG5jbGFzcyBBbmltYXRlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGdldFByb3BlcnR5KCkge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVUeXBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F0dHJpYnV0ZVR5cGUnKS5nZXRTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdHRyaWJ1dGVOYW1lJykuZ2V0U3RyaW5nKCk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVUeXBlID09PSAnQ1NTJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldFN0eWxlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNhbGNWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgeyBpbml0aWFsVW5pdHMgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHByb2dyZXNzICwgZnJvbSAsIHRvICB9ID0gdGhpcy5nZXRQcm9ncmVzcygpO1xuICAgICAgICAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuICAgICAgICBsZXQgbmV3VmFsdWUgPSBmcm9tLmdldE51bWJlcigpICsgKHRvLmdldE51bWJlcigpIC0gZnJvbS5nZXROdW1iZXIoKSkgKiBwcm9ncmVzcztcbiAgICAgICAgaWYgKGluaXRpYWxVbml0cyA9PT0gJyUnKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSAqPSAxMDAgLy8gbnVtVmFsdWUoKSByZXR1cm5zIDAtMSB3aGVyZWFzIHByb3BlcnRpZXMgYXJlIDAtMTAwXG4gICAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG5ld1ZhbHVlKS5jb25jYXQoaW5pdGlhbFVuaXRzKTtcbiAgICB9XG4gICAgdXBkYXRlKGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcHJvcCA9IHRoaXMuZ2V0UHJvcGVydHkoKTtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgdmFsdWVcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBwcm9wLmdldFN0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsVW5pdHMgPSBwcm9wLmdldFVuaXRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UncmUgcGFzdCB0aGUgZW5kIHRpbWVcbiAgICAgICAgaWYgKHRoaXMuZHVyYXRpb24gPiB0aGlzLm1heER1cmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKS5nZXRTdHJpbmcoJ3JlbW92ZScpO1xuICAgICAgICAgICAgLy8gbG9vcCBmb3IgaW5kZWZpbml0ZWx5IHJlcGVhdGluZyBhbmltYXRpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3JlcGVhdENvdW50JykuZ2V0U3RyaW5nKCkgPT09ICdpbmRlZmluaXRlJyB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncmVwZWF0RHVyJykuZ2V0U3RyaW5nKCkgPT09ICdpbmRlZmluaXRlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsID09PSAnZnJlZXplJyAmJiAhdGhpcy5mcm96ZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5hbmltYXRpb25Gcm96ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgPSBwcm9wLmdldFN0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ3JlbW92ZScgJiYgIXRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3Auc2V0VmFsdWUocGFyZW50LmFuaW1hdGlvbkZyb3plbiA/IHBhcmVudC5hbmltYXRpb25Gcm96ZW5WYWx1ZSA6IHRoaXMuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kdXJhdGlvbiArPSBkZWx0YTtcbiAgICAgICAgLy8gaWYgd2UncmUgcGFzdCB0aGUgYmVnaW4gdGltZVxuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5iZWdpbiA8IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IHRoaXMuY2FsY1ZhbHVlKCkgLy8gdHdlZW5cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGlmICh0eXBlQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRyYW5zZm9ybSwgZXRjLlxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlQXR0ci5nZXRTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IFwiXCIuY29uY2F0KHR5cGUsIFwiKFwiKS5jb25jYXQobmV3VmFsdWUsIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3Auc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGdldFByb2dyZXNzKCkge1xuICAgICAgICBjb25zdCB7IGRvY3VtZW50ICwgdmFsdWVzICB9ID0gdGhpcztcbiAgICAgICAgbGV0IHByb2dyZXNzID0gKHRoaXMuZHVyYXRpb24gLSB0aGlzLmJlZ2luKSAvICh0aGlzLm1heER1cmF0aW9uIC0gdGhpcy5iZWdpbik7XG4gICAgICAgIGxldCBmcm9tO1xuICAgICAgICBsZXQgdG87XG4gICAgICAgIGlmICh2YWx1ZXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHByb2dyZXNzICogKHZhbHVlcy5nZXRWYWx1ZSgpLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbGIgPSBNYXRoLmZsb29yKHApO1xuICAgICAgICAgICAgY29uc3QgdWIgPSBNYXRoLmNlaWwocCk7XG4gICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5nZXRWYWx1ZSgpW2xiXTtcbiAgICAgICAgICAgIGZyb20gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdmcm9tJywgdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IDApO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuZ2V0VmFsdWUoKVt1Yl07XG4gICAgICAgICAgICB0byA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3RvJywgdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IDApO1xuICAgICAgICAgICAgcHJvZ3Jlc3MgPSAocCAtIGxiKSAvICh1YiAtIGxiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSB0aGlzLmZyb207XG4gICAgICAgICAgICB0byA9IHRoaXMudG87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYW5pbWF0ZSc7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLmluaXRpYWxVbml0cyA9ICcnO1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnQuc2NyZWVuLmFuaW1hdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5iZWdpbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdiZWdpbicpLmdldE1pbGxpc2Vjb25kcygpO1xuICAgICAgICB0aGlzLm1heER1cmF0aW9uID0gdGhpcy5iZWdpbiArIHRoaXMuZ2V0QXR0cmlidXRlKCdkdXInKS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Zyb20nKTtcbiAgICAgICAgdGhpcy50byA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0bycpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3ZhbHVlcycsIG51bGwpO1xuICAgICAgICBjb25zdCB2YWx1ZXNBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlcycpO1xuICAgICAgICBpZiAodmFsdWVzQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zZXRWYWx1ZSh2YWx1ZXNBdHRyLmdldFN0cmluZygpLnNwbGl0KCc7JykpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBbmltYXRlQ29sb3JFbGVtZW50IGV4dGVuZHMgQW5pbWF0ZUVsZW1lbnQge1xuICAgIGNhbGNWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9ncmVzcyAsIGZyb20gLCB0byAgfSA9IHRoaXMuZ2V0UHJvZ3Jlc3MoKTtcbiAgICAgICAgY29uc3QgY29sb3JGcm9tID0gbmV3IFJHQkNvbG9yKGZyb20uZ2V0Q29sb3IoKSk7XG4gICAgICAgIGNvbnN0IGNvbG9yVG8gPSBuZXcgUkdCQ29sb3IodG8uZ2V0Q29sb3IoKSk7XG4gICAgICAgIGlmIChjb2xvckZyb20ub2sgJiYgY29sb3JUby5vaykge1xuICAgICAgICAgICAgLy8gdHdlZW4gY29sb3IgbGluZWFybHlcbiAgICAgICAgICAgIGNvbnN0IHIgPSBjb2xvckZyb20uciArIChjb2xvclRvLnIgLSBjb2xvckZyb20ucikgKiBwcm9ncmVzcztcbiAgICAgICAgICAgIGNvbnN0IGcgPSBjb2xvckZyb20uZyArIChjb2xvclRvLmcgLSBjb2xvckZyb20uZykgKiBwcm9ncmVzcztcbiAgICAgICAgICAgIGNvbnN0IGIgPSBjb2xvckZyb20uYiArIChjb2xvclRvLmIgLSBjb2xvckZyb20uYikgKiBwcm9ncmVzcztcbiAgICAgICAgICAgIC8vID8gYWxwaGFcbiAgICAgICAgICAgIHJldHVybiBcInJnYihcIi5jb25jYXQoTWF0aC5mbG9vcihyKSwgXCIsIFwiKS5jb25jYXQoTWF0aC5mbG9vcihnKSwgXCIsIFwiKS5jb25jYXQoTWF0aC5mbG9vcihiKSwgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZnJvbScpLmdldENvbG9yKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2FuaW1hdGVDb2xvcic7XG4gICAgfVxufVxuXG5jbGFzcyBBbmltYXRlVHJhbnNmb3JtRWxlbWVudCBleHRlbmRzIEFuaW1hdGVFbGVtZW50IHtcbiAgICBjYWxjVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvZ3Jlc3MgLCBmcm9tOiBmcm9tMSAsIHRvOiB0bzEgIH0gPSB0aGlzLmdldFByb2dyZXNzKCk7XG4gICAgICAgIC8vIHR3ZWVuIHZhbHVlIGxpbmVhcmx5XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybUZyb20gPSB0b051bWJlcnMoZnJvbTEuZ2V0U3RyaW5nKCkpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1UbyA9IHRvTnVtYmVycyh0bzEuZ2V0U3RyaW5nKCkpO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRyYW5zZm9ybUZyb20ubWFwKChmcm9tLCBpKT0+e1xuICAgICAgICAgICAgY29uc3QgdG8gPSB0cmFuc2Zvcm1Ub1tpXTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBwcm9ncmVzcztcbiAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2FuaW1hdGVUcmFuc2Zvcm0nO1xuICAgIH1cbn1cblxuY2xhc3MgRm9udEZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgICAgICB0aGlzLmFzY2VudCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhc2NlbnQnKS5nZXROdW1iZXIoKTtcbiAgICAgICAgdGhpcy5kZXNjZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Rlc2NlbnQnKS5nZXROdW1iZXIoKTtcbiAgICAgICAgdGhpcy51bml0c1BlckVtID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3VuaXRzLXBlci1lbScpLmdldE51bWJlcigpO1xuICAgIH1cbn1cblxuY2xhc3MgR2x5cGhFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZ2x5cGgnO1xuICAgICAgICB0aGlzLmhvcml6QWR2WCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdob3Jpei1hZHYteCcpLmdldE51bWJlcigpO1xuICAgICAgICB0aGlzLnVuaWNvZGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgndW5pY29kZScpLmdldFN0cmluZygpO1xuICAgICAgICB0aGlzLmFyYWJpY0Zvcm0gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXJhYmljLWZvcm0nKS5nZXRTdHJpbmcoKTtcbiAgICB9XG59XG5cbmNsYXNzIE1pc3NpbmdHbHlwaEVsZW1lbnQgZXh0ZW5kcyBHbHlwaEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ21pc3NpbmctZ2x5cGgnO1xuICAgICAgICB0aGlzLmhvcml6QWR2WCA9IDA7XG4gICAgfVxufVxuXG5jbGFzcyBGb250RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAvLyBOTyBSRU5ERVJcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmb250JztcbiAgICAgICAgdGhpcy5pc0FyYWJpYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdseXBocyA9IHt9O1xuICAgICAgICB0aGlzLmFyYWJpY0dseXBocyA9IHt9O1xuICAgICAgICB0aGlzLmlzUlRMID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaG9yaXpBZHZYID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hvcml6LWFkdi14JykuZ2V0TnVtYmVyKCk7XG4gICAgICAgIGNvbnN0IHsgZGVmaW5pdGlvbnMgIH0gPSBkb2N1bWVudDtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiAgfSA9IHRoaXM7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pe1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRm9udEZhY2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb250RmFjZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRGYW1pbHlTdHlsZSA9IGNoaWxkLmdldFN0eWxlKCdmb250LWZhbWlseScpO1xuICAgICAgICAgICAgICAgIGlmIChmb250RmFtaWx5U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uc1tmb250RmFtaWx5U3R5bGUuZ2V0U3RyaW5nKCldID0gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWlzc2luZ0dseXBoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWlzc2luZ0dseXBoID0gY2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgR2x5cGhFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmFyYWJpY0Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JUTCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBcmFiaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmFiaWNHbHlwaCA9IHRoaXMuYXJhYmljR2x5cGhzW2NoaWxkLnVuaWNvZGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyYWJpY0dseXBoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmFiaWNHbHlwaHNbY2hpbGQudW5pY29kZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NoaWxkLmFyYWJpY0Zvcm1dOiBjaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyYWJpY0dseXBoW2NoaWxkLmFyYWJpY0Zvcm1dID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdseXBoc1tjaGlsZC51bmljb2RlXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgVFJlZkVsZW1lbnQgZXh0ZW5kcyBUZXh0RWxlbWVudCB7XG4gICAgZ2V0VGV4dCgpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RDaGlsZC5nZXRUZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0cmVmJztcbiAgICB9XG59XG5cbmNsYXNzIEFFbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICAgIGdldFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuICAgIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5oYXNUZXh0KSB7XG4gICAgICAgICAgICAvLyByZW5kZXIgYXMgdGV4dCBlbGVtZW50XG4gICAgICAgICAgICBzdXBlci5yZW5kZXJDaGlsZHJlbihjdHgpO1xuICAgICAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIHggLCB5ICB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgbW91c2UgIH0gPSBkb2N1bWVudC5zY3JlZW47XG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2ZvbnRTaXplJywgRm9udC5wYXJzZShkb2N1bWVudC5jdHguZm9udCkuZm9udFNpemUpO1xuICAgICAgICAgICAgLy8gRG8gbm90IGNhbGMgYm91bmRpbmcgYm94IGlmIG1vdXNlIGlzIG5vdCB3b3JraW5nLlxuICAgICAgICAgICAgaWYgKG1vdXNlLmlzV29ya2luZygpKSB7XG4gICAgICAgICAgICAgICAgbW91c2UuY2hlY2tCb3VuZGluZ0JveCh0aGlzLCBuZXcgQm91bmRpbmdCb3goeCwgeSAtIGZvbnRTaXplLmdldFBpeGVscygneScpLCB4ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyByZW5kZXIgYXMgdGVtcG9yYXJ5IGdyb3VwXG4gICAgICAgICAgICBjb25zdCBnID0gbmV3IEdFbGVtZW50KHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICAgICAgZy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICBnLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICBnLnJlbmRlcihjdHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIGNvbnN0IHsgd2luZG93ICB9ID0gdGhpcy5kb2N1bWVudDtcbiAgICAgICAgaWYgKHdpbmRvdykge1xuICAgICAgICAgICAgd2luZG93Lm9wZW4odGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uTW91c2VNb3ZlKCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmRvY3VtZW50LmN0eDtcbiAgICAgICAgY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlMSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlMSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdhJztcbiAgICAgICAgY29uc3QgeyBjaGlsZE5vZGVzICB9ID0gbm9kZTE7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBjaGlsZE5vZGVzWzBdO1xuICAgICAgICBjb25zdCBoYXNUZXh0ID0gY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmIEFycmF5LmZyb20oY2hpbGROb2RlcykuZXZlcnkoKG5vZGUpPT5ub2RlLm5vZGVUeXBlID09PSAzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuaGFzVGV4dCA9IGhhc1RleHQ7XG4gICAgICAgIHRoaXMudGV4dCA9IGhhc1RleHQgPyB0aGlzLmdldFRleHRGcm9tTm9kZShmaXJzdENoaWxkKSA6ICcnO1xuICAgIH1cbn1cblxuY2xhc3MgVGV4dFBhdGhFbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICAgIGdldFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuICAgIHBhdGgoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YUFycmF5ICB9ID0gdGhpcztcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFBcnJheS5mb3JFYWNoKChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCB7IHR5cGUgLCBwb2ludHMgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzXSA9IHBvaW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IHJ4ID4gcnkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IHJ4ID4gcnkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIEJvb2xlYW4oMSAtIGZzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICAgICAgdGhpcy5zZXRUZXh0RGF0YShjdHgpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjb25zdCB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMucGFyZW50LmdldFN0eWxlKCd0ZXh0LWRlY29yYXRpb24nKS5nZXRTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICAgIGNvbnN0IHsgZ2x5cGhJbmZvICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZmlsbCA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBnbHlwaEluZm8uZm9yRWFjaCgoZ2x5cGgsIGkpPT57XG4gICAgICAgICAgICBjb25zdCB7IHAwICwgcDEgLCByb3RhdGlvbiAsIHRleHQ6IHBhcnRpYWxUZXh0ICB9ID0gZ2x5cGg7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwMC54LCBwMC55KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocm90YXRpb24pO1xuICAgICAgICAgICAgaWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQocGFydGlhbFRleHQsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwMC54LCBwMC55ICsgZm9udFNpemUgLyA4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwMS54LCBwMS55ICsgZm9udFNpemUgLyA1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gLy8gVG8gYXNzaXN0IHdpdGggZGVidWdnaW5nIHZpc3VhbGx5LCB1bmNvbW1lbnQgZm9sbG93aW5nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgLy8gaWYgKGkgJSAyKVxuICAgICAgICAvLyAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vICAgY3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICAgICAgLy8gY3R4Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgICAgLy8gY3R4LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgICAgLy8gY3R4LnN0cm9rZSgpO1xuICAgICAgICAvLyBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gZm9udFNpemUgLyAyMDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGZpbGw7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgZ2V0TGV0dGVyU3BhY2luZ0F0KCkge1xuICAgICAgICBsZXQgaWR4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGVbaWR4XSB8fCAwO1xuICAgIH1cbiAgICBmaW5kU2VnbWVudFRvRml0Q2hhcihjdHgsIGFuY2hvciwgdGV4dEZ1bGxXaWR0aCwgZnVsbFBhdGhXaWR0aCwgc3BhY2VzTnVtYmVyLCBpbnB1dE9mZnNldCwgZHksIGMsIGNoYXJJKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBpbnB1dE9mZnNldDtcbiAgICAgICAgbGV0IGdseXBoV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGN0eCwgYyk7XG4gICAgICAgIGlmIChjID09PSAnICcgJiYgYW5jaG9yID09PSAnanVzdGlmeScgJiYgdGV4dEZ1bGxXaWR0aCA8IGZ1bGxQYXRoV2lkdGgpIHtcbiAgICAgICAgICAgIGdseXBoV2lkdGggKz0gKGZ1bGxQYXRoV2lkdGggLSB0ZXh0RnVsbFdpZHRoKSAvIHNwYWNlc051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhckkgPiAtMSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuZ2V0TGV0dGVyU3BhY2luZ0F0KGNoYXJJKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGxpbmVTdGVwID0gdGhpcy50ZXh0SGVpZ2h0IC8gMjA7XG4gICAgICAgIGNvbnN0IHAwID0gdGhpcy5nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKG9mZnNldCwgc3BsaW5lU3RlcCwgMCk7XG4gICAgICAgIGNvbnN0IHAxID0gdGhpcy5nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKG9mZnNldCArIGdseXBoV2lkdGgsIHNwbGluZVN0ZXAsIDApO1xuICAgICAgICBjb25zdCBzZWdtZW50ID0ge1xuICAgICAgICAgICAgcDAsXG4gICAgICAgICAgICBwMVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IHAwICYmIHAxID8gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpIDogMDtcbiAgICAgICAgaWYgKGR5KSB7XG4gICAgICAgICAgICBjb25zdCBkeVggPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiArIHJvdGF0aW9uKSAqIGR5O1xuICAgICAgICAgICAgY29uc3QgZHlZID0gTWF0aC5jb3MoLXJvdGF0aW9uKSAqIGR5O1xuICAgICAgICAgICAgc2VnbWVudC5wMCA9IHtcbiAgICAgICAgICAgICAgICAuLi5wMCxcbiAgICAgICAgICAgICAgICB4OiBwMC54ICsgZHlYLFxuICAgICAgICAgICAgICAgIHk6IHAwLnkgKyBkeVlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWdtZW50LnAxID0ge1xuICAgICAgICAgICAgICAgIC4uLnAxLFxuICAgICAgICAgICAgICAgIHg6IHAxLnggKyBkeVgsXG4gICAgICAgICAgICAgICAgeTogcDEueSArIGR5WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gZ2x5cGhXaWR0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICByb3RhdGlvblxuICAgICAgICB9O1xuICAgIH1cbiAgICBtZWFzdXJlVGV4dChjdHgsIHRleHQpIHtcbiAgICAgICAgY29uc3QgeyBtZWFzdXJlc0NhY2hlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdGFyZ2V0VGV4dCA9IHRleHQgfHwgdGhpcy5nZXRUZXh0KCk7XG4gICAgICAgIGlmIChtZWFzdXJlc0NhY2hlLmhhcyh0YXJnZXRUZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmVzQ2FjaGUuZ2V0KHRhcmdldFRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lYXN1cmUgPSB0aGlzLm1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgdGFyZ2V0VGV4dCk7XG4gICAgICAgIG1lYXN1cmVzQ2FjaGUuc2V0KHRhcmdldFRleHQsIG1lYXN1cmUpO1xuICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICB9XG4gICAgLy8gVGhpcyBtZXRob2Qgc3VwcG9zZXMgd2hhdCBhbGwgY3VzdG9tIGZvbnRzIGFscmVhZHkgbG9hZGVkLlxuICAgIC8vIElmIHNvbWUgZm9udCB3aWxsIGJlIGxvYWRlZCBhZnRlciB0aGlzIG1ldGhvZCBjYWxsLCA8dGV4dFBhdGg+IHdpbGwgbm90IGJlIHJlbmRlcmVkIGNvcnJlY3RseS5cbiAgICAvLyBZb3UgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIG1hbnVhbGx5IHRvIHVwZGF0ZSBnbHlwaHMgY2FjaGUuXG4gICAgc2V0VGV4dERhdGEoY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmdseXBoSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlclRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICAgICAgY29uc3QgY2hhcnMgPSByZW5kZXJUZXh0LnNwbGl0KCcnKTtcbiAgICAgICAgY29uc3Qgc3BhY2VzTnVtYmVyID0gcmVuZGVyVGV4dC5zcGxpdCgnICcpLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGR4ID0gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLnNwbGl0KCkubWFwKChfKT0+Xy5nZXRQaXhlbHMoJ3gnKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBkeSA9IHRoaXMucGFyZW50LmdldEF0dHJpYnV0ZSgnZHknKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoJ3RleHQtYW5jaG9yJykuZ2V0U3RyaW5nKCdzdGFydCcpO1xuICAgICAgICBjb25zdCB0aGlzU3BhY2luZyA9IHRoaXMuZ2V0U3R5bGUoJ2xldHRlci1zcGFjaW5nJyk7XG4gICAgICAgIGNvbnN0IHBhcmVudFNwYWNpbmcgPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgnbGV0dGVyLXNwYWNpbmcnKTtcbiAgICAgICAgbGV0IGxldHRlclNwYWNpbmcgPSAwO1xuICAgICAgICBpZiAoIXRoaXNTcGFjaW5nLmhhc1ZhbHVlKCkgfHwgdGhpc1NwYWNpbmcuZ2V0VmFsdWUoKSA9PT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nID0gcGFyZW50U3BhY2luZy5nZXRQaXhlbHMoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzU3BhY2luZy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpc1NwYWNpbmcuZ2V0VmFsdWUoKSAhPT0gJ2luaXRpYWwnICYmIHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgIT09ICd1bnNldCcpIHtcbiAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nID0gdGhpc1NwYWNpbmcuZ2V0UGl4ZWxzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlsbCBsZXR0ZXItc3BhY2luZyBjYWNoZVxuICAgICAgICBjb25zdCBsZXR0ZXJTcGFjaW5nQ2FjaGUgPSBbXTtcbiAgICAgICAgY29uc3QgdGV4dExlbiA9IHJlbmRlclRleHQubGVuZ3RoO1xuICAgICAgICB0aGlzLmxldHRlclNwYWNpbmdDYWNoZSA9IGxldHRlclNwYWNpbmdDYWNoZTtcbiAgICAgICAgZm9yKGxldCBpMSA9IDA7IGkxIDwgdGV4dExlbjsgaTErKyl7XG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nQ2FjaGUucHVzaCh0eXBlb2YgZHhbaTFdICE9PSAndW5kZWZpbmVkJyA/IGR4W2kxXSA6IGxldHRlclNwYWNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR4U3VtID0gbGV0dGVyU3BhY2luZ0NhY2hlLnJlZHVjZSgoYWNjLCBjdXIsIGkpPT5pID09PSAwID8gMCA6IGFjYyArIGN1ciB8fCAwXG4gICAgICAgICwgMCk7XG4gICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQoY3R4KTtcbiAgICAgICAgY29uc3QgdGV4dEZ1bGxXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCArIGR4U3VtLCAwKTtcbiAgICAgICAgdGhpcy50ZXh0V2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICAgICAgdGhpcy5nbHlwaEluZm8gPSBbXTtcbiAgICAgICAgY29uc3QgZnVsbFBhdGhXaWR0aCA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMuZ2V0U3R5bGUoJ3N0YXJ0T2Zmc2V0JykuZ2V0TnVtYmVyKDApICogZnVsbFBhdGhXaWR0aDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGlmIChhbmNob3IgPT09ICdtaWRkbGUnIHx8IGFuY2hvciA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IC10ZXh0RnVsbFdpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yID09PSAnZW5kJyB8fCBhbmNob3IgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IC10ZXh0RnVsbFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBzdGFydE9mZnNldDtcbiAgICAgICAgY2hhcnMuZm9yRWFjaCgoY2hhciwgaSk9PntcbiAgICAgICAgICAgIC8vIEZpbmQgc3VjaCBzZWdtZW50IHdoYXQgZGlzdGFuY2UgYmV0d2VlbiBwMCBhbmQgcDEgaXMgYXBwcm94LiB3aWR0aCBvZiBnbHlwaFxuICAgICAgICAgICAgY29uc3QgeyBvZmZzZXQ6IG5leHRPZmZzZXQgLCBzZWdtZW50ICwgcm90YXRpb24gIH0gPSB0aGlzLmZpbmRTZWdtZW50VG9GaXRDaGFyKGN0eCwgYW5jaG9yLCB0ZXh0RnVsbFdpZHRoLCBmdWxsUGF0aFdpZHRoLCBzcGFjZXNOdW1iZXIsIG9mZnNldCwgZHksIGNoYXIsIGkpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbmV4dE9mZnNldDtcbiAgICAgICAgICAgIGlmICghc2VnbWVudC5wMCB8fCAhc2VnbWVudC5wMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRMaW5lTGVuZ3RoKFxuICAgICAgICAgICAgLy8gICBzZWdtZW50LnAwLngsXG4gICAgICAgICAgICAvLyAgIHNlZ21lbnQucDAueSxcbiAgICAgICAgICAgIC8vICAgc2VnbWVudC5wMS54LFxuICAgICAgICAgICAgLy8gICBzZWdtZW50LnAxLnlcbiAgICAgICAgICAgIC8vICk7XG4gICAgICAgICAgICAvLyBOb3RlOiBTaW5jZSBnbHlwaHMgYXJlIHJlbmRlcmVkIG9uZSBhdCBhIHRpbWUsIGFueSBrZXJuaW5nIHBhaXIgZGF0YSBidWlsdCBpbnRvIHRoZSBmb250IHdpbGwgbm90IGJlIHVzZWQuXG4gICAgICAgICAgICAvLyBDYW4gZm9yZXNlZSBoYXZpbmcgYSByb3VnaCBwYWlyIHRhYmxlIGJ1aWx0IGluIHRoYXQgdGhlIGRldmVsb3BlciBjYW4gb3ZlcnJpZGUgYXMgbmVlZGVkLlxuICAgICAgICAgICAgLy8gT3IgdXNlIFwiZHhcIiBhdHRyaWJ1dGUgb2YgdGhlIDx0ZXh0PiBub2RlIGFzIGEgbmFpdmUgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIC8vIGNvbnN0IGtlcm4gPSAwO1xuICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIgZm9yIGZ1dHVyZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgLy8gY29uc3QgbWlkcG9pbnQgPSB0aGlzLmdldFBvaW50T25MaW5lKFxuICAgICAgICAgICAgLy8gICBrZXJuICsgd2lkdGggLyAyLjAsXG4gICAgICAgICAgICAvLyAgIHNlZ21lbnQucDAueCwgc2VnbWVudC5wMC55LCBzZWdtZW50LnAxLngsIHNlZ21lbnQucDEueVxuICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhJbmZvLnB1c2goe1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zcG9zZVg6IG1pZHBvaW50LngsXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNwb3NlWTogbWlkcG9pbnQueSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjaGFyc1tpXSxcbiAgICAgICAgICAgICAgICBwMDogc2VnbWVudC5wMCxcbiAgICAgICAgICAgICAgICBwMTogc2VnbWVudC5wMSxcbiAgICAgICAgICAgICAgICByb3RhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZVBhdGhEYXRhKHBhdGgpIHtcbiAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gLTEgLy8gcmVzZXQgcGF0aCBsZW5ndGhcbiAgICAgICAgO1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoQ29tbWFuZHMgPSBbXTtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gcGF0aDtcbiAgICAgICAgcGF0aFBhcnNlci5yZXNldCgpO1xuICAgICAgICAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcbiAgICAgICAgd2hpbGUoIXBhdGhQYXJzZXIuaXNFbmQoKSl7XG4gICAgICAgICAgICBjb25zdCB7IGN1cnJlbnQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRYID0gY3VycmVudCA/IGN1cnJlbnQueCA6IDA7XG4gICAgICAgICAgICBjb25zdCBzdGFydFkgPSBjdXJyZW50ID8gY3VycmVudC55IDogMDtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSBwYXRoUGFyc2VyLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBuZXh0Q29tbWFuZFR5cGUgPSBjb21tYW5kLnR5cGU7XG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gW107XG4gICAgICAgICAgICBzd2l0Y2goY29tbWFuZC50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTU9WRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoTShwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoTChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuSE9SSVpfTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoSChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuVkVSVF9MSU5FX1RPOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhWKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQyhwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX0NVUlZFX1RPOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhTKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhRKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfUVVBRF9UTzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoVChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSB0aGlzLnBhdGhBKHBhdGhQYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ0xPU0VfUEFUSDpcbiAgICAgICAgICAgICAgICAgICAgUGF0aEVsZW1lbnQucGF0aFoocGF0aFBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbW1hbmQudHlwZSAhPT0gUGF0aFBhcnNlci5DTE9TRV9QQVRIKSB7XG4gICAgICAgICAgICAgICAgcGF0aENvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBuZXh0Q29tbWFuZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHN0YXJ0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHN0YXJ0WVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXRoTGVuZ3RoOiB0aGlzLmNhbGNMZW5ndGgoc3RhcnRYLCBzdGFydFksIG5leHRDb21tYW5kVHlwZSwgcG9pbnRzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRoQ29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFBhdGhQYXJzZXIuQ0xPU0VfUEFUSCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aExlbmd0aDogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoQ29tbWFuZHM7XG4gICAgfVxuICAgIHBhdGhNKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gUGF0aEVsZW1lbnQucGF0aE0ocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgIH1cbiAgICBwYXRoTChwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IFBhdGhFbGVtZW50LnBhdGhMKHBhdGhQYXJzZXIpLnBvaW50O1xuICAgICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICAgICAgcmV0dXJuIFBhdGhQYXJzZXIuTElORV9UTztcbiAgICB9XG4gICAgcGF0aEgocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBQYXRoRWxlbWVudC5wYXRoSChwYXRoUGFyc2VyKS5wb2ludDtcbiAgICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gICAgfVxuICAgIHBhdGhWKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gUGF0aEVsZW1lbnQucGF0aFYocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgICAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICAgIH1cbiAgICBwYXRoQyhwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgICAgY29uc3QgeyBwb2ludCAsIGNvbnRyb2xQb2ludCAsIGN1cnJlbnRQb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhDKHBhdGhQYXJzZXIpO1xuICAgICAgICBwb2ludHMucHVzaChwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgfVxuICAgIHBhdGhTKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IHBvaW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFMocGF0aFBhcnNlcik7XG4gICAgICAgIHBvaW50cy5wdXNoKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgcmV0dXJuIFBhdGhQYXJzZXIuQ1VSVkVfVE87XG4gICAgfVxuICAgIHBhdGhRKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xQb2ludCAsIGN1cnJlbnRQb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhRKHBhdGhQYXJzZXIpO1xuICAgICAgICBwb2ludHMucHVzaChjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgfVxuICAgIHBhdGhUKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xQb2ludCAsIGN1cnJlbnRQb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhUKHBhdGhQYXJzZXIpO1xuICAgICAgICBwb2ludHMucHVzaChjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIHJldHVybiBQYXRoUGFyc2VyLlFVQURfVE87XG4gICAgfVxuICAgIHBhdGhBKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgbGV0IHsgclggLCByWSAsIHN3ZWVwRmxhZyAsIHhBeGlzUm90YXRpb24gLCBjZW50cCAsIGExICwgYWQgIH0gPSBQYXRoRWxlbWVudC5wYXRoQShwYXRoUGFyc2VyKTtcbiAgICAgICAgaWYgKHN3ZWVwRmxhZyA9PT0gMCAmJiBhZCA+IDApIHtcbiAgICAgICAgICAgIGFkIC09IDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzd2VlcEZsYWcgPT09IDEgJiYgYWQgPCAwKSB7XG4gICAgICAgICAgICBhZCArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY2VudHAueCxcbiAgICAgICAgICAgIGNlbnRwLnksXG4gICAgICAgICAgICByWCxcbiAgICAgICAgICAgIHJZLFxuICAgICAgICAgICAgYTEsXG4gICAgICAgICAgICBhZCxcbiAgICAgICAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICAgICAgICBzd2VlcEZsYWdcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY2FsY0xlbmd0aCh4LCB5LCBjb21tYW5kVHlwZSwgcG9pbnRzKSB7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBsZXQgcDEgPSBudWxsO1xuICAgICAgICBsZXQgcDIgPSBudWxsO1xuICAgICAgICBsZXQgdCA9IDA7XG4gICAgICAgIHN3aXRjaChjb21tYW5kVHlwZSl7XG4gICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lTGVuZ3RoKHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25DdWJpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICBmb3IodCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKXtcbiAgICAgICAgICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25DdWJpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIDEwMCBsaW5lIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgICBwMSA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgICAgIGZvcih0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpe1xuICAgICAgICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBwb2ludHNbNF07XG4gICAgICAgICAgICAgICAgICAgIC8vIDQgPSB0aGV0YVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkVGhldGEgPSBwb2ludHNbNV07XG4gICAgICAgICAgICAgICAgICAgIC8vIDUgPSBkVGhldGFcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5jID0gTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICAgICAgICAgICAgLy8gMSBkZWdyZWUgcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3RhcnQgLSBlbmQpIDwgaW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmMgPSBNYXRoLmFicyhzdGFydCAtIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogZm9yIHB1cnBvc2Ugb2YgY2FsY3VsYXRpbmcgYXJjIGxlbmd0aCwgbm90IGdvaW5nIHRvIHdvcnJ5IGFib3V0IHJvdGF0aW5nIFgtYXhpcyBieSBhbmdsZSBwc2lcbiAgICAgICAgICAgICAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgc3RhcnQsIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZFRoZXRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHQgPSBzdGFydCAtIGluYzsgdCA+IGVuZDsgdCAtPSBpbmMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih0ID0gc3RhcnQgKyBpbmM7IHQgPCBlbmQ7IHQgKz0gaW5jKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCB0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgZW5kLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGdldFBvaW50T25MaW5lKGRpc3QsIHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAgICAgICBsZXQgZnJvbVggPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1s1XSA6IHAxeCwgZnJvbVkgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1s2XSA6IHAxeTtcbiAgICAgICAgY29uc3QgbSA9IChwMnkgLSBwMXkpIC8gKHAyeCAtIHAxeCArIFBTRVVET19aRVJPKTtcbiAgICAgICAgbGV0IHJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAvICgxICsgbSAqIG0pKTtcbiAgICAgICAgaWYgKHAyeCA8IHAxeCkge1xuICAgICAgICAgICAgcnVuICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGxldCByaXNlID0gbSAqIHJ1bjtcbiAgICAgICAgbGV0IHB0ID0gbnVsbDtcbiAgICAgICAgaWYgKHAyeCA9PT0gcDF4KSB7XG4gICAgICAgICAgICBwdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBmcm9tWCxcbiAgICAgICAgICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoKGZyb21ZIC0gcDF5KSAvIChmcm9tWCAtIHAxeCArIFBTRVVET19aRVJPKSA9PT0gbSkge1xuICAgICAgICAgICAgcHQgPSB7XG4gICAgICAgICAgICAgICAgeDogZnJvbVggKyBydW4sXG4gICAgICAgICAgICAgICAgeTogZnJvbVkgKyByaXNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGl4ID0gMDtcbiAgICAgICAgICAgIGxldCBpeSA9IDA7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmdldExpbmVMZW5ndGgocDF4LCBwMXksIHAyeCwgcDJ5KTtcbiAgICAgICAgICAgIGlmIChsZW4gPCBQU0VVRE9fWkVSTykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHUgPSAoZnJvbVggLSBwMXgpICogKHAyeCAtIHAxeCkgKyAoZnJvbVkgLSBwMXkpICogKHAyeSAtIHAxeSk7XG4gICAgICAgICAgICB1IC89IGxlbiAqIGxlbjtcbiAgICAgICAgICAgIGl4ID0gcDF4ICsgdSAqIChwMnggLSBwMXgpO1xuICAgICAgICAgICAgaXkgPSBwMXkgKyB1ICogKHAyeSAtIHAxeSk7XG4gICAgICAgICAgICBjb25zdCBwUmlzZSA9IHRoaXMuZ2V0TGluZUxlbmd0aChmcm9tWCwgZnJvbVksIGl4LCBpeSk7XG4gICAgICAgICAgICBjb25zdCBwUnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC0gcFJpc2UgKiBwUmlzZSk7XG4gICAgICAgICAgICBydW4gPSBNYXRoLnNxcnQocFJ1biAqIHBSdW4gLyAoMSArIG0gKiBtKSk7XG4gICAgICAgICAgICBpZiAocDJ4IDwgcDF4KSB7XG4gICAgICAgICAgICAgICAgcnVuICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmlzZSA9IG0gKiBydW47XG4gICAgICAgICAgICBwdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBpeCArIHJ1bixcbiAgICAgICAgICAgICAgICB5OiBpeSArIHJpc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB0O1xuICAgIH1cbiAgICBnZXRQb2ludE9uUGF0aChkaXN0YW5jZSkge1xuICAgICAgICBjb25zdCBmdWxsTGVuID0gdGhpcy5nZXRQYXRoTGVuZ3RoKCk7XG4gICAgICAgIGxldCBjdW11bGF0aXZlUGF0aExlbmd0aCA9IDA7XG4gICAgICAgIGxldCBwID0gbnVsbDtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgLTAuMDAwMDUgfHwgZGlzdGFuY2UgLSAwLjAwMDA1ID4gZnVsbExlbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkYXRhQXJyYXkgIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgZGF0YUFycmF5KXtcbiAgICAgICAgICAgIGlmIChjb21tYW5kICYmIChjb21tYW5kLnBhdGhMZW5ndGggPCAwLjAwMDA1IHx8IGN1bXVsYXRpdmVQYXRoTGVuZ3RoICsgY29tbWFuZC5wYXRoTGVuZ3RoICsgMC4wMDAwNSA8IGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICs9IGNvbW1hbmQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZGlzdGFuY2UgLSBjdW11bGF0aXZlUGF0aExlbmd0aDtcbiAgICAgICAgICAgIGxldCBjdXJyZW50VCA9IDA7XG4gICAgICAgICAgICBzd2l0Y2goY29tbWFuZC50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkxpbmUoZGVsdGEsIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55LCBjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBjb21tYW5kLnBvaW50c1s0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQgPSB0aGV0YVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZFRoZXRhID0gY29tbWFuZC5wb2ludHNbNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA1ID0gZFRoZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBjb21tYW5kLnBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gc3RhcnQgKyBkZWx0YSAvIGNvbW1hbmQucGF0aExlbmd0aCAqIGRUaGV0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkVGhldGEgPCAwICYmIGN1cnJlbnRUIDwgZW5kIHx8IGRUaGV0YSA+PSAwICYmIGN1cnJlbnRUID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQucG9pbnRzWzJdLCBjb21tYW5kLnBvaW50c1szXSwgY3VycmVudFQsIGNvbW1hbmQucG9pbnRzWzZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKGN1cnJlbnRULCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSwgY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnBvaW50c1syXSwgY29tbWFuZC5wb2ludHNbM10sIGNvbW1hbmQucG9pbnRzWzRdLCBjb21tYW5kLnBvaW50c1s1XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihjdXJyZW50VCwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldExpbmVMZW5ndGgoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICAgIH1cbiAgICBnZXRQYXRoTGVuZ3RoKCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoTGVuZ3RoID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gdGhpcy5kYXRhQXJyYXkucmVkdWNlKChsZW5ndGgsIGNvbW1hbmQpPT5jb21tYW5kLnBhdGhMZW5ndGggPiAwID8gbGVuZ3RoICsgY29tbWFuZC5wYXRoTGVuZ3RoIDogbGVuZ3RoXG4gICAgICAgICAgICAsIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGhMZW5ndGg7XG4gICAgfVxuICAgIGdldFBvaW50T25DdWJpY0JlemllcihwY3QsIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHA0eCwgcDR5KSB7XG4gICAgICAgIGNvbnN0IHggPSBwNHggKiBDQjEocGN0KSArIHAzeCAqIENCMihwY3QpICsgcDJ4ICogQ0IzKHBjdCkgKyBwMXggKiBDQjQocGN0KTtcbiAgICAgICAgY29uc3QgeSA9IHA0eSAqIENCMShwY3QpICsgcDN5ICogQ0IyKHBjdCkgKyBwMnkgKiBDQjMocGN0KSArIHAxeSAqIENCNChwY3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihwY3QsIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICAgICAgY29uc3QgeCA9IHAzeCAqIFFCMShwY3QpICsgcDJ4ICogUUIyKHBjdCkgKyBwMXggKiBRQjMocGN0KTtcbiAgICAgICAgY29uc3QgeSA9IHAzeSAqIFFCMShwY3QpICsgcDJ5ICogUUIyKHBjdCkgKyBwMXkgKiBRQjMocGN0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFBvaW50T25FbGxpcHRpY2FsQXJjKGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgcHNpKSB7XG4gICAgICAgIGNvbnN0IGNvc1BzaSA9IE1hdGguY29zKHBzaSk7XG4gICAgICAgIGNvbnN0IHNpblBzaSA9IE1hdGguc2luKHBzaSk7XG4gICAgICAgIGNvbnN0IHB0ID0ge1xuICAgICAgICAgICAgeDogcnggKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgICB5OiByeSAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY3ggKyAocHQueCAqIGNvc1BzaSAtIHB0LnkgKiBzaW5Qc2kpLFxuICAgICAgICAgICAgeTogY3kgKyAocHQueCAqIHNpblBzaSArIHB0LnkgKiBjb3NQc2kpXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFRPRE8gbmVlZCBzb21lIG9wdGltaXNhdGlvbnMuIHBvc3NpYmx5IGJ1aWxkIGNhY2hlIG9ubHkgZm9yIGN1cnZlZCBzZWdtZW50cz9cbiAgICBidWlsZEVxdWlkaXN0YW50Q2FjaGUoaW5wdXRTdGVwLCBpbnB1dFByZWNpc2lvbikge1xuICAgICAgICBjb25zdCBmdWxsTGVuID0gdGhpcy5nZXRQYXRoTGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IGlucHV0UHJlY2lzaW9uIHx8IDAuMjUgLy8gYWNjdXJhY3kgdnMgcGVyZm9ybWFuY2VcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBzdGVwID0gaW5wdXRTdGVwIHx8IGZ1bGxMZW4gLyAxMDA7XG4gICAgICAgIGlmICghdGhpcy5lcXVpZGlzdGFudENhY2hlIHx8IHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5zdGVwICE9PSBzdGVwIHx8IHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wcmVjaXNpb24gIT09IHByZWNpc2lvbikge1xuICAgICAgICAgICAgLy8gUHJlcGFyZSBjYWNoZVxuICAgICAgICAgICAgdGhpcy5lcXVpZGlzdGFudENhY2hlID0ge1xuICAgICAgICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgIHBvaW50czogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9pbnRzXG4gICAgICAgICAgICBsZXQgcyA9IDA7XG4gICAgICAgICAgICBmb3IobGV0IGwgPSAwOyBsIDw9IGZ1bGxMZW47IGwgKz0gcHJlY2lzaW9uKXtcbiAgICAgICAgICAgICAgICBjb25zdCBwMCA9IHRoaXMuZ2V0UG9pbnRPblBhdGgobCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcDEgPSB0aGlzLmdldFBvaW50T25QYXRoKGwgKyBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIGlmICghcDAgfHwgIXAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwMS54LCBwMS55KTtcbiAgICAgICAgICAgICAgICBpZiAocyA+PSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBwMC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcDAueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzIC09IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgodGFyZ2V0RGlzdGFuY2UsIHN0ZXAsIHByZWNpc2lvbikge1xuICAgICAgICB0aGlzLmJ1aWxkRXF1aWRpc3RhbnRDYWNoZShzdGVwLCBwcmVjaXNpb24pO1xuICAgICAgICBpZiAodGFyZ2V0RGlzdGFuY2UgPCAwIHx8IHRhcmdldERpc3RhbmNlIC0gdGhpcy5nZXRQYXRoTGVuZ3RoKCkgPiAwLjAwMDA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHggPSBNYXRoLnJvdW5kKHRhcmdldERpc3RhbmNlIC8gdGhpcy5nZXRQYXRoTGVuZ3RoKCkgKiAodGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50cy5sZW5ndGggLSAxKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzW2lkeF0gfHwgbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0ZXh0UGF0aCc7XG4gICAgICAgIHRoaXMudGV4dFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMuZ2x5cGhJbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5tZWFzdXJlc0NhY2hlID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgXVxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgcGF0aEVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMuZ2V0VGV4dEZyb21Ob2RlKCk7XG4gICAgICAgIHRoaXMuZGF0YUFycmF5ID0gdGhpcy5wYXJzZVBhdGhEYXRhKHBhdGhFbGVtZW50KTtcbiAgICB9XG59XG5cbi8vIGdyb3VwczogMTogbWltZS10eXBlICgrIGNoYXJzZXQpLCAyOiBtaW1lLXR5cGUgKHcvbyBjaGFyc2V0KSwgMzogY2hhcnNldCwgNDogYmFzZTY0PywgNTogYm9keVxuY29uc3QgZGF0YVVyaVJlZ2V4ID0gL15cXHMqZGF0YTooKFteLyw7XStcXC9bXi8sO10rKSg/OjsoW14sOz1dKz1bXiw7PV0rKSk/KT8oPzo7KGJhc2U2NCkpPywoLiopJC9pO1xuY2xhc3MgSW1hZ2VFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgICBhc3luYyBsb2FkSW1hZ2UoaHJlZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCB0aGlzLmRvY3VtZW50LmNyZWF0ZUltYWdlKGhyZWYpO1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGltYWdlIFxcXCJcIi5jb25jYXQoaHJlZiwgXCJcXFwiOlwiKSwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRTdmcoaHJlZikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGRhdGFVcmlSZWdleC5leGVjKGhyZWYpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtYXRjaFs1XTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzRdID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gYXRvYihkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmRvY3VtZW50LmZldGNoKGhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN2ZyA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gc3ZnO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIGxvYWRpbmcgaW1hZ2UgXFxcIlwiLmNvbmNhdChocmVmLCBcIlxcXCI6XCIpLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCBpbWFnZSAsIGxvYWRlZCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgaWYgKCFsb2FkZWQgfHwgIWltYWdlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YkRvY3VtZW50ID0gZG9jdW1lbnQuY2FudmcuZm9ya1N0cmluZyhjdHgsIGltYWdlLCB7XG4gICAgICAgICAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgICAgICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlnbm9yZURpbWVuc2lvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgaWdub3JlQ2xlYXI6IHRydWUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgICAgIHNjYWxlV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIHNjYWxlSGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkb2N1bWVudEVsZW1lbnQgIH0gPSBzdWJEb2N1bWVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZvaWQgc3ViRG9jdW1lbnQucmVuZGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5zZXRWaWV3Qm94KHtcbiAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgYXNwZWN0UmF0aW86IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgZGVzaXJlZFdpZHRoOiBpbWFnZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgZGVzaXJlZEhlaWdodDogaW1hZ2UuaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghKCdjb21wbGV0ZScgaW4gaW1hZ2UpIHx8IGltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaW1hZ2UnO1xuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBocmVmID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0U3RyaW5nKCk7XG4gICAgICAgIGlmICghaHJlZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU3ZnID0gaHJlZi5lbmRzV2l0aCgnLnN2ZycpIHx8IC9eXFxzKmRhdGE6aW1hZ2VcXC9zdmdcXCt4bWwvaS50ZXN0KGhyZWYpO1xuICAgICAgICBkb2N1bWVudC5pbWFnZXMucHVzaCh0aGlzKTtcbiAgICAgICAgaWYgKCFpc1N2Zykge1xuICAgICAgICAgICAgdm9pZCB0aGlzLmxvYWRJbWFnZShocmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5sb2FkU3ZnKGhyZWYpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTeW1ib2xFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgICByZW5kZXIoXykge1xuICAgIC8vIE5PIFJFTkRFUlxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzeW1ib2wnO1xuICAgIH1cbn1cblxuY2xhc3MgU1ZHRm9udExvYWRlciB7XG4gICAgYXN5bmMgbG9hZChmb250RmFtaWx5LCB1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3Qgc3ZnRG9jdW1lbnQgPSBhd2FpdCBkb2N1bWVudC5jYW52Zy5wYXJzZXIubG9hZCh1cmwpO1xuICAgICAgICAgICAgY29uc3QgZm9udHMgPSBzdmdEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9udCcpO1xuICAgICAgICAgICAgQXJyYXkuZnJvbShmb250cykuZm9yRWFjaCgoZm9udE5vZGUpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgZm9udCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZm9udE5vZGUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRlZmluaXRpb25zW2ZvbnRGYW1pbHldID0gZm9udDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGZvbnQgXFxcIlwiLmNvbmNhdCh1cmwsIFwiXFxcIjpcIiksIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCl7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnQuZm9udHMucHVzaCh0aGlzKTtcbiAgICB9XG59XG5cbmNsYXNzIFN0eWxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3R5bGUnO1xuICAgICAgICBjb25zdCBjc3MgPSBjb21wcmVzc1NwYWNlcyhBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykvLyBORUVEIFRFU1RcbiAgICAgICAgLm1hcCgoXyk9Pl8udGV4dENvbnRlbnRcbiAgICAgICAgKS5qb2luKCcnKS5yZXBsYWNlKC8oXFwvXFwqKFteKl18W1xcclxcbl18KFxcKisoW14qL118W1xcclxcbl0pKSkqXFwqK1xcLyl8KF5bXFxzXSpcXC9cXC8uKikvZ20sICcnKSAvLyByZW1vdmUgY29tbWVudHNcbiAgICAgICAgLnJlcGxhY2UoL0BpbXBvcnQuKjsvZywgJycpIC8vIHJlbW92ZSBpbXBvcnRzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNzc0RlZnMgPSBjc3Muc3BsaXQoJ30nKTtcbiAgICAgICAgY3NzRGVmcy5mb3JFYWNoKChfMSk9PntcbiAgICAgICAgICAgIGNvbnN0IGRlZiA9IF8xLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3NzUGFydHMgPSBkZWYuc3BsaXQoJ3snKTtcbiAgICAgICAgICAgIGNvbnN0IGNzc0NsYXNzZXMgPSBjc3NQYXJ0c1swXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgY29uc3QgY3NzUHJvcHMgPSBjc3NQYXJ0c1sxXS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKChfKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzc0NsYXNzID0gXy50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjc3NDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZG9jdW1lbnQuc3R5bGVzW2Nzc0NsYXNzXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBjc3NQcm9wcy5mb3JFYWNoKChjc3NQcm9wKT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gY3NzUHJvcC5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjc3NQcm9wLnN1YnN0cigwLCBwcm9wKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3NzUHJvcC5zdWJzdHIocHJvcCArIDEsIGNzc1Byb3AubGVuZ3RoIC0gcHJvcCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnN0eWxlc1tjc3NDbGFzc10gPSBwcm9wcztcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5zdHlsZXNTcGVjaWZpY2l0eVtjc3NDbGFzc10gPSBnZXRTZWxlY3RvclNwZWNpZmljaXR5KGNzc0NsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoY3NzQ2xhc3MgPT09ICdAZm9udC1mYWNlJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb250RmFtaWx5ID0gcHJvcHNbJ2ZvbnQtZmFtaWx5J10uZ2V0U3RyaW5nKCkucmVwbGFjZSgvXCJ8Jy9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyY3MgPSBwcm9wcy5zcmMuZ2V0U3RyaW5nKCkuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgc3Jjcy5mb3JFYWNoKChzcmMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3JjLmluZGV4T2YoJ2Zvcm1hdChcInN2Z1wiKScpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHBhcnNlRXh0ZXJuYWxVcmwoc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgbmV3IFNWR0ZvbnRMb2FkZXIoZG9jdW1lbnQpLmxvYWQoZm9udEZhbWlseSwgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5TdHlsZUVsZW1lbnQucGFyc2VFeHRlcm5hbFVybCA9IHBhcnNlRXh0ZXJuYWxVcmw7XG5cbmNsYXNzIFVzZUVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICAgIHNldENvbnRleHQoY3R4KSB7XG4gICAgICAgIHN1cGVyLnNldENvbnRleHQoY3R4KTtcbiAgICAgICAgY29uc3QgeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgICAgICBjb25zdCB5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgICAgIGlmICh4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHhBdHRyLmdldFBpeGVscygneCcpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB5QXR0ci5nZXRQaXhlbHMoJ3knKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGF0aChjdHgpIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50ICB9ID0gdGhpcztcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucGF0aChjdHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgICBjb25zdCB7IGRvY3VtZW50ICwgZWxlbWVudCAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgdGVtcFN2ZyA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudCBpbiBzeW1ib2wgY2FzZXMgKGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNVc2VFbGVtZW50KVxuICAgICAgICAgICAgICAgIHRlbXBTdmcgPSBuZXcgU1ZHRWxlbWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLnZpZXdCb3ggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd2aWV3Qm94JywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLnByZXNlcnZlQXNwZWN0UmF0aW8gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLm92ZXJmbG93ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnb3ZlcmZsb3cnLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBzdGlsbCB0aGUgcGFyZW50IG9mIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVzLm9wYWNpdHkgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdvcGFjaXR5JywgdGhpcy5jYWxjdWxhdGVPcGFjaXR5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlbXBTdmcudHlwZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0U3R5bGUgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgc3ltYm9sIG9yIHN2ZywgaW5oZXJpdCB3aWR0aC9oZWlnaHQgZnJvbSBtZVxuICAgICAgICAgICAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCB3aWR0aFN0eWxlLmdldFN0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIGhlaWdodFN0eWxlLmdldFN0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvbGRQYXJlbnQgPSB0ZW1wU3ZnLnBhcmVudDtcbiAgICAgICAgICAgIHRlbXBTdmcucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHRlbXBTdmcucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICB0ZW1wU3ZnLnBhcmVudCA9IG9sZFBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50ICB9ID0gdGhpcztcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsZW1lbnRUcmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCBlbGVtZW50ICB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHJhbnNmb3JtLmZyb21FbGVtZW50KGRvY3VtZW50LCBlbGVtZW50KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZEVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkRWxlbWVudDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAndXNlJztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGltR2V0KGltZywgeCwgeSwgd2lkdGgsIF9oZWlnaHQsIHJnYmEpIHtcbiAgICByZXR1cm4gaW1nW3kgKiB3aWR0aCAqIDQgKyB4ICogNCArIHJnYmFdO1xufVxuZnVuY3Rpb24gaW1TZXQoaW1nLCB4LCB5LCB3aWR0aCwgX2hlaWdodCwgcmdiYSwgdmFsKSB7XG4gICAgaW1nW3kgKiB3aWR0aCAqIDQgKyB4ICogNCArIHJnYmFdID0gdmFsO1xufVxuZnVuY3Rpb24gbShtYXRyaXgsIGksIHYpIHtcbiAgICBjb25zdCBtaSA9IG1hdHJpeFtpXTtcbiAgICByZXR1cm4gbWkgKiB2O1xufVxuZnVuY3Rpb24gYyhhLCBtMSwgbTIsIG0zKSB7XG4gICAgcmV0dXJuIG0xICsgTWF0aC5jb3MoYSkgKiBtMiArIE1hdGguc2luKGEpICogbTM7XG59XG5jbGFzcyBGZUNvbG9yTWF0cml4RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGFwcGx5KGN0eCwgX3gsIF95LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8vIGFzc3VtaW5nIHg9PTAgJiYgeT09MCBmb3Igbm93XG4gICAgICAgIGNvbnN0IHsgaW5jbHVkZU9wYWNpdHkgLCBtYXRyaXggIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzcmNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZm9yKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKXtcbiAgICAgICAgICAgIGZvcihsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKXtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzKTtcbiAgICAgICAgICAgICAgICBsZXQgbnIgPSBtKG1hdHJpeCwgMCwgcikgKyBtKG1hdHJpeCwgMSwgZykgKyBtKG1hdHJpeCwgMiwgYikgKyBtKG1hdHJpeCwgMywgYSkgKyBtKG1hdHJpeCwgNCwgMSk7XG4gICAgICAgICAgICAgICAgbGV0IG5nID0gbShtYXRyaXgsIDUsIHIpICsgbShtYXRyaXgsIDYsIGcpICsgbShtYXRyaXgsIDcsIGIpICsgbShtYXRyaXgsIDgsIGEpICsgbShtYXRyaXgsIDksIDEpO1xuICAgICAgICAgICAgICAgIGxldCBuYiA9IG0obWF0cml4LCAxMCwgcikgKyBtKG1hdHJpeCwgMTEsIGcpICsgbShtYXRyaXgsIDEyLCBiKSArIG0obWF0cml4LCAxMywgYSkgKyBtKG1hdHJpeCwgMTQsIDEpO1xuICAgICAgICAgICAgICAgIGxldCBuYSA9IG0obWF0cml4LCAxNSwgcikgKyBtKG1hdHJpeCwgMTYsIGcpICsgbShtYXRyaXgsIDE3LCBiKSArIG0obWF0cml4LCAxOCwgYSkgKyBtKG1hdHJpeCwgMTksIDEpO1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlT3BhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICBuciA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5nID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbmIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBuYSAqPSBhIC8gMjU1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDAsIG5yKTtcbiAgICAgICAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEsIG5nKTtcbiAgICAgICAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIsIG5iKTtcbiAgICAgICAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMsIG5hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKHNyY0RhdGEsIDAsIDApO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZlQ29sb3JNYXRyaXgnO1xuICAgICAgICBsZXQgbWF0cml4ID0gdG9OdW1iZXJzKHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZXMnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIHN3aXRjaCh0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpLmdldFN0cmluZygnbWF0cml4Jykpe1xuICAgICAgICAgICAgY2FzZSAnc2F0dXJhdGUnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IG1hdHJpeFswXTtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovIG1hdHJpeCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMjEzICsgMC43ODcgKiBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC43MTUgLSAwLjcxNSAqIHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjA3MiAtIDAuMDcyICogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4yMTMgLSAwLjIxMyAqIHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjcxNSArIDAuMjg1ICogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMDcyIC0gMC4wNzIgKiBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjIxMyAtIDAuMjEzICogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNzE1IC0gMC43MTUgKiBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4wNzIgKyAwLjkyOCAqIHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaHVlUm90YXRlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBtYXRyaXhbMF0gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi8gbWF0cml4ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYyhhLCAwLjIxMywgMC43ODcsIC0wLjIxMyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjKGEsIDAuNzE1LCAtMC43MTUsIC0wLjcxNSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjKGEsIDAuMDcyLCAtMC4wNzIsIDAuOTI4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyhhLCAwLjIxMywgLTAuMjEzLCAwLjE0MyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjKGEsIDAuNzE1LCAwLjI4NSwgMC4xNCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjKGEsIDAuMDcyLCAtMC4wNzIsIC0wLjI4MyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMoYSwgMC4yMTMsIC0wLjIxMywgLTAuNzg3KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMoYSwgMC43MTUsIC0wLjcxNSwgMC43MTUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyhhLCAwLjA3MiwgMC45MjgsIDAuMDcyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsdW1pbmFuY2VUb0FscGhhJzpcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi8gbWF0cml4ID0gW1xuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLjIxMjUsXG4gICAgICAgICAgICAgICAgICAgIDAuNzE1NCxcbiAgICAgICAgICAgICAgICAgICAgMC4wNzIxLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgdGhpcy5pbmNsdWRlT3BhY2l0eSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpbmNsdWRlT3BhY2l0eScpLmhhc1ZhbHVlKCk7XG4gICAgfVxufVxuXG5jbGFzcyBNYXNrRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGFwcGx5KGN0eCwgZWxlbWVudCkge1xuICAgICAgICBjb25zdCB7IGRvY3VtZW50ICB9ID0gdGhpcztcbiAgICAgICAgLy8gcmVuZGVyIGFzIHRlbXAgc3ZnXG4gICAgICAgIGxldCB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgbGV0IHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGlmICghd2lkdGggJiYgIWhlaWdodCkge1xuICAgICAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgYm91bmRpbmdCb3guYWRkQm91bmRpbmdCb3goY2hpbGQuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LngxKTtcbiAgICAgICAgICAgIHkgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LnkxKTtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC53aWR0aCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWdub3JlZFN0eWxlcyA9IHRoaXMucmVtb3ZlU3R5bGVzKGVsZW1lbnQsIE1hc2tFbGVtZW50Lmlnbm9yZVN0eWxlcyk7XG4gICAgICAgIGNvbnN0IG1hc2tDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXMoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgbWFza0N0eCA9IG1hc2tDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKG1hc2tDdHgpO1xuICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKG1hc2tDdHgpO1xuICAgICAgICAvLyBjb252ZXJ0IG1hc2sgdG8gYWxwaGEgd2l0aCBhIGZha2Ugbm9kZVxuICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBvdXQgYXBwbHkgZnJvbSBmZUNvbG9yTWF0cml4XG4gICAgICAgIG5ldyBGZUNvbG9yTWF0cml4RWxlbWVudChkb2N1bWVudCwge1xuICAgICAgICAgICAgbm9kZVR5cGU6IDEsXG4gICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiAndHlwZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnbHVtaW5hbmNlVG9BbHBoYSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6ICdpbmNsdWRlT3BhY2l0eScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pLmFwcGx5KG1hc2tDdHgsIDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IHRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKHRtcEN0eCk7XG4gICAgICAgIGVsZW1lbnQucmVuZGVyKHRtcEN0eCk7XG4gICAgICAgIHRtcEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xuICAgICAgICB0bXBDdHguZmlsbFN0eWxlID0gbWFza0N0eC5jcmVhdGVQYXR0ZXJuKG1hc2tDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICAgICAgdG1wQ3R4LmZpbGxSZWN0KDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0bXBDdHguY3JlYXRlUGF0dGVybih0bXBDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIC8vIHJlYXNzaWduIG1hc2tcbiAgICAgICAgdGhpcy5yZXN0b3JlU3R5bGVzKGVsZW1lbnQsIGlnbm9yZWRTdHlsZXMpO1xuICAgIH1cbiAgICByZW5kZXIoXykge1xuICAgIC8vIE5PIFJFTkRFUlxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdtYXNrJztcbiAgICB9XG59XG5NYXNrRWxlbWVudC5pZ25vcmVTdHlsZXMgPSBbXG4gICAgJ21hc2snLFxuICAgICd0cmFuc2Zvcm0nLFxuICAgICdjbGlwLXBhdGgnXG5dO1xuXG5jb25zdCBub29wID0gKCk9Pntcbi8vIE5PT1Bcbn07XG5jbGFzcyBDbGlwUGF0aEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBhcHBseShjdHgpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNvbnRleHRQcm90byA9IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoY3R4KTtcbiAgICAgICAgY29uc3QgeyBiZWdpblBhdGggLCBjbG9zZVBhdGggIH0gPSBjdHg7XG4gICAgICAgIGlmIChjb250ZXh0UHJvdG8pIHtcbiAgICAgICAgICAgIGNvbnRleHRQcm90by5iZWdpblBhdGggPSBub29wO1xuICAgICAgICAgICAgY29udGV4dFByb3RvLmNsb3NlUGF0aCA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdC5hcHBseShiZWdpblBhdGgsIGN0eCwgW10pO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKT0+e1xuICAgICAgICAgICAgaWYgKCEoJ3BhdGgnIGluIGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0cmFuc2Zvcm0gPSAnZWxlbWVudFRyYW5zZm9ybScgaW4gY2hpbGQgPyBjaGlsZC5lbGVtZW50VHJhbnNmb3JtKCkgOiBudWxsIC8vIGhhbmRsZSA8dXNlIC8+XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSA9IFRyYW5zZm9ybS5mcm9tRWxlbWVudChkb2N1bWVudCwgY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5hcHBseShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQucGF0aChjdHgpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHRQcm90bykge1xuICAgICAgICAgICAgICAgIGNvbnRleHRQcm90by5jbG9zZVBhdGggPSBjbG9zZVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnVuYXBwbHkoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFJlZmxlY3QuYXBwbHkoY2xvc2VQYXRoLCBjdHgsIFtdKTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgaWYgKGNvbnRleHRQcm90bykge1xuICAgICAgICAgICAgY29udGV4dFByb3RvLmJlZ2luUGF0aCA9IGJlZ2luUGF0aDtcbiAgICAgICAgICAgIGNvbnRleHRQcm90by5jbG9zZVBhdGggPSBjbG9zZVBhdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKF8pIHtcbiAgICAvLyBOTyBSRU5ERVJcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY2xpcFBhdGgnO1xuICAgIH1cbn1cblxuY2xhc3MgRmlsdGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGFwcGx5KGN0eCwgZWxlbWVudCkge1xuICAgICAgICAvLyByZW5kZXIgYXMgdGVtcCBzdmdcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIGNoaWxkcmVuICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSAnZ2V0Qm91bmRpbmdCb3gnIGluIGVsZW1lbnQgPyBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCkgOiBudWxsO1xuICAgICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB4ID0gMDtcbiAgICAgICAgbGV0IHB5ID0gMDtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpPT57XG4gICAgICAgICAgICBjb25zdCBlZmQgPSBjaGlsZC5leHRyYUZpbHRlckRpc3RhbmNlIHx8IDA7XG4gICAgICAgICAgICBweCA9IE1hdGgubWF4KHB4LCBlZmQpO1xuICAgICAgICAgICAgcHkgPSBNYXRoLm1heChweSwgZWZkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC53aWR0aCk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3guaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgdG1wQ2FudmFzV2lkdGggPSB3aWR0aCArIDIgKiBweDtcbiAgICAgICAgY29uc3QgdG1wQ2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICsgMiAqIHB5O1xuICAgICAgICBpZiAodG1wQ2FudmFzV2lkdGggPCAxIHx8IHRtcENhbnZhc0hlaWdodCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC54KTtcbiAgICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueSk7XG4gICAgICAgIGNvbnN0IGlnbm9yZWRTdHlsZXMgPSB0aGlzLnJlbW92ZVN0eWxlcyhlbGVtZW50LCBGaWx0ZXJFbGVtZW50Lmlnbm9yZVN0eWxlcyk7XG4gICAgICAgIGNvbnN0IHRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyh0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0KTtcbiAgICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGRvY3VtZW50LnNjcmVlbi5zZXREZWZhdWx0cyh0bXBDdHgpO1xuICAgICAgICB0bXBDdHgudHJhbnNsYXRlKC14ICsgcHgsIC15ICsgcHkpO1xuICAgICAgICBlbGVtZW50LnJlbmRlcih0bXBDdHgpO1xuICAgICAgICAvLyBhcHBseSBmaWx0ZXJzXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKT0+e1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC5hcHBseSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNoaWxkLmFwcGx5KHRtcEN0eCwgMCwgMCwgdG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZW5kZXIgb24gbWVcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0bXBDYW52YXMsIDAsIDAsIHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQsIHggLSBweCwgeSAtIHB5LCB0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5yZXN0b3JlU3R5bGVzKGVsZW1lbnQsIGlnbm9yZWRTdHlsZXMpO1xuICAgIH1cbiAgICByZW5kZXIoXykge1xuICAgIC8vIE5PIFJFTkRFUlxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmaWx0ZXInO1xuICAgIH1cbn1cbkZpbHRlckVsZW1lbnQuaWdub3JlU3R5bGVzID0gW1xuICAgICdmaWx0ZXInLFxuICAgICd0cmFuc2Zvcm0nLFxuICAgICdjbGlwLXBhdGgnXG5dO1xuXG5jbGFzcyBGZURyb3BTaGFkb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgYXBwbHkoXywgX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnRcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmZURyb3BTaGFkb3cnO1xuICAgICAgICB0aGlzLmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTtcbiAgICB9XG59XG5cbmNsYXNzIEZlTW9ycGhvbG9neUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkge1xuICAgIC8vIFRPRE86IGltcGxlbWVudFxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmZU1vcnBob2xvZ3knO1xuICAgIH1cbn1cblxuY2xhc3MgRmVDb21wb3NpdGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgYXBwbHkoXywgX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnRcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmVDb21wb3NpdGUnO1xuICAgIH1cbn1cblxuY2xhc3MgRmVHYXVzc2lhbkJsdXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgYXBwbHkoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCBibHVyUmFkaXVzICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYm9keSA9IGRvY3VtZW50LndpbmRvdyA/IGRvY3VtZW50LndpbmRvdy5kb2N1bWVudC5ib2R5IDogbnVsbDtcbiAgICAgICAgY29uc3QgY2FudmFzID0gY3R4LmNhbnZhcztcbiAgICAgICAgLy8gU3RhY2tCbHVyIHJlcXVpcmVzIGNhbnZhcyBiZSBvbiBkb2N1bWVudFxuICAgICAgICBjYW52YXMuaWQgPSBkb2N1bWVudC5nZXRVbmlxdWVJZCgpO1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzUkdCQShjYW52YXMsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJsdXJSYWRpdXMpO1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChjYW52YXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmVHYXVzc2lhbkJsdXInO1xuICAgICAgICB0aGlzLmJsdXJSYWRpdXMgPSBNYXRoLmZsb29yKHRoaXMuZ2V0QXR0cmlidXRlKCdzdGREZXZpYXRpb24nKS5nZXROdW1iZXIoKSk7XG4gICAgICAgIHRoaXMuZXh0cmFGaWx0ZXJEaXN0YW5jZSA9IHRoaXMuYmx1clJhZGl1cztcbiAgICB9XG59XG5cbmNsYXNzIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3RpdGxlJztcbiAgICB9XG59XG5cbmNsYXNzIERlc2NFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZGVzYyc7XG4gICAgfVxufVxuXG5jb25zdCBlbGVtZW50cyA9IHtcbiAgICAnc3ZnJzogU1ZHRWxlbWVudCxcbiAgICAncmVjdCc6IFJlY3RFbGVtZW50LFxuICAgICdjaXJjbGUnOiBDaXJjbGVFbGVtZW50LFxuICAgICdlbGxpcHNlJzogRWxsaXBzZUVsZW1lbnQsXG4gICAgJ2xpbmUnOiBMaW5lRWxlbWVudCxcbiAgICAncG9seWxpbmUnOiBQb2x5bGluZUVsZW1lbnQsXG4gICAgJ3BvbHlnb24nOiBQb2x5Z29uRWxlbWVudCxcbiAgICAncGF0aCc6IFBhdGhFbGVtZW50LFxuICAgICdwYXR0ZXJuJzogUGF0dGVybkVsZW1lbnQsXG4gICAgJ21hcmtlcic6IE1hcmtlckVsZW1lbnQsXG4gICAgJ2RlZnMnOiBEZWZzRWxlbWVudCxcbiAgICAnbGluZWFyR3JhZGllbnQnOiBMaW5lYXJHcmFkaWVudEVsZW1lbnQsXG4gICAgJ3JhZGlhbEdyYWRpZW50JzogUmFkaWFsR3JhZGllbnRFbGVtZW50LFxuICAgICdzdG9wJzogU3RvcEVsZW1lbnQsXG4gICAgJ2FuaW1hdGUnOiBBbmltYXRlRWxlbWVudCxcbiAgICAnYW5pbWF0ZUNvbG9yJzogQW5pbWF0ZUNvbG9yRWxlbWVudCxcbiAgICAnYW5pbWF0ZVRyYW5zZm9ybSc6IEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50LFxuICAgICdmb250JzogRm9udEVsZW1lbnQsXG4gICAgJ2ZvbnQtZmFjZSc6IEZvbnRGYWNlRWxlbWVudCxcbiAgICAnbWlzc2luZy1nbHlwaCc6IE1pc3NpbmdHbHlwaEVsZW1lbnQsXG4gICAgJ2dseXBoJzogR2x5cGhFbGVtZW50LFxuICAgICd0ZXh0JzogVGV4dEVsZW1lbnQsXG4gICAgJ3RzcGFuJzogVFNwYW5FbGVtZW50LFxuICAgICd0cmVmJzogVFJlZkVsZW1lbnQsXG4gICAgJ2EnOiBBRWxlbWVudCxcbiAgICAndGV4dFBhdGgnOiBUZXh0UGF0aEVsZW1lbnQsXG4gICAgJ2ltYWdlJzogSW1hZ2VFbGVtZW50LFxuICAgICdnJzogR0VsZW1lbnQsXG4gICAgJ3N5bWJvbCc6IFN5bWJvbEVsZW1lbnQsXG4gICAgJ3N0eWxlJzogU3R5bGVFbGVtZW50LFxuICAgICd1c2UnOiBVc2VFbGVtZW50LFxuICAgICdtYXNrJzogTWFza0VsZW1lbnQsXG4gICAgJ2NsaXBQYXRoJzogQ2xpcFBhdGhFbGVtZW50LFxuICAgICdmaWx0ZXInOiBGaWx0ZXJFbGVtZW50LFxuICAgICdmZURyb3BTaGFkb3cnOiBGZURyb3BTaGFkb3dFbGVtZW50LFxuICAgICdmZU1vcnBob2xvZ3knOiBGZU1vcnBob2xvZ3lFbGVtZW50LFxuICAgICdmZUNvbXBvc2l0ZSc6IEZlQ29tcG9zaXRlRWxlbWVudCxcbiAgICAnZmVDb2xvck1hdHJpeCc6IEZlQ29sb3JNYXRyaXhFbGVtZW50LFxuICAgICdmZUdhdXNzaWFuQmx1cic6IEZlR2F1c3NpYW5CbHVyRWxlbWVudCxcbiAgICAndGl0bGUnOiBUaXRsZUVsZW1lbnQsXG4gICAgJ2Rlc2MnOiBEZXNjRWxlbWVudFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjYW52YXM7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVJbWFnZShzcmMpIHtcbiAgICBsZXQgYW5vbnltb3VzQ3Jvc3NPcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGNvbnN0IGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgaWYgKGFub255bW91c0Nyb3NzT3JpZ2luKSB7XG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKT0+e1xuICAgICAgICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgICAgIH07XG4gICAgICAgIGltYWdlLm9uZXJyb3IgPSAoX2V2ZW50LCBfc291cmNlLCBfbGluZW5vLCBfY29sbm8sIGVycm9yKT0+e1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgIH0pO1xufVxuY29uc3QgREVGQVVMVF9FTV9TSVpFID0gMTI7XG5jbGFzcyBEb2N1bWVudCB7XG4gICAgYmluZENyZWF0ZUltYWdlKGNyZWF0ZUltYWdlMSwgYW5vbnltb3VzQ3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhbm9ueW1vdXNDcm9zc09yaWdpbiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gKHNvdXJjZSwgZm9yY2VBbm9ueW1vdXNDcm9zc09yaWdpbik9PmNyZWF0ZUltYWdlMShzb3VyY2UsIHR5cGVvZiBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luID09PSAnYm9vbGVhbicgPyBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luIDogYW5vbnltb3VzQ3Jvc3NPcmlnaW4pXG4gICAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlMTtcbiAgICB9XG4gICAgZ2V0IHdpbmRvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLndpbmRvdztcbiAgICB9XG4gICAgZ2V0IGZldGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uZmV0Y2g7XG4gICAgfVxuICAgIGdldCBjdHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5jdHg7XG4gICAgfVxuICAgIGdldCBlbVNpemUoKSB7XG4gICAgICAgIGNvbnN0IHsgZW1TaXplU3RhY2sgIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gZW1TaXplU3RhY2tbZW1TaXplU3RhY2subGVuZ3RoIC0gMV0gfHwgREVGQVVMVF9FTV9TSVpFO1xuICAgIH1cbiAgICBzZXQgZW1TaXplKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgZW1TaXplU3RhY2sgIH0gPSB0aGlzO1xuICAgICAgICBlbVNpemVTdGFjay5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wRW1TaXplKCkge1xuICAgICAgICBjb25zdCB7IGVtU2l6ZVN0YWNrICB9ID0gdGhpcztcbiAgICAgICAgZW1TaXplU3RhY2sucG9wKCk7XG4gICAgfVxuICAgIGdldFVuaXF1ZUlkKCkge1xuICAgICAgICByZXR1cm4gXCJjYW52Z1wiLmNvbmNhdCgrK3RoaXMudW5pcXVlSWQpO1xuICAgIH1cbiAgICBpc0ltYWdlc0xvYWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VzLmV2ZXJ5KChfKT0+Xy5sb2FkZWRcbiAgICAgICAgKTtcbiAgICB9XG4gICAgaXNGb250c0xvYWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udHMuZXZlcnkoKF8pPT5fLmxvYWRlZFxuICAgICAgICApO1xuICAgIH1cbiAgICBjcmVhdGVEb2N1bWVudEVsZW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgIGRvY3VtZW50RWxlbWVudC5yb290ID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnRFbGVtZW50LmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBkb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGNyZWF0ZUVsZW1lbnQobm9kZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IG5vZGUubm9kZU5hbWUucmVwbGFjZSgvXlteOl0rOi8sICcnKTtcbiAgICAgICAgY29uc3QgRWxlbWVudFR5cGUgPSBEb2N1bWVudC5lbGVtZW50VHlwZXNbZWxlbWVudFR5cGVdO1xuICAgICAgICBpZiAoRWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudFR5cGUodGhpcywgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVbmtub3duRWxlbWVudCh0aGlzLCBub2RlKTtcbiAgICB9XG4gICAgY3JlYXRlVGV4dE5vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMsIG5vZGUpO1xuICAgIH1cbiAgICBzZXRWaWV3Qm94KGNvbmZpZykge1xuICAgICAgICB0aGlzLnNjcmVlbi5zZXRWaWV3Qm94KHtcbiAgICAgICAgICAgIGRvY3VtZW50OiB0aGlzLFxuICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihjYW52ZywgeyByb290RW1TaXplID1ERUZBVUxUX0VNX1NJWkUgLCBlbVNpemUgPURFRkFVTFRfRU1fU0laRSAsIGNyZWF0ZUNhbnZhczogY3JlYXRlQ2FudmFzMSA9IERvY3VtZW50LmNyZWF0ZUNhbnZhcyAsIGNyZWF0ZUltYWdlOiBjcmVhdGVJbWFnZTIgPSBEb2N1bWVudC5jcmVhdGVJbWFnZSAsIGFub255bW91c0Nyb3NzT3JpZ2luICB9ID0ge30pe1xuICAgICAgICB0aGlzLmNhbnZnID0gY2Fudmc7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IHt9O1xuICAgICAgICB0aGlzLmltYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLmZvbnRzID0gW107XG4gICAgICAgIHRoaXMuZW1TaXplU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy51bmlxdWVJZCA9IDA7XG4gICAgICAgIHRoaXMuc2NyZWVuID0gY2Fudmcuc2NyZWVuO1xuICAgICAgICB0aGlzLnJvb3RFbVNpemUgPSByb290RW1TaXplO1xuICAgICAgICB0aGlzLmVtU2l6ZSA9IGVtU2l6ZTtcbiAgICAgICAgdGhpcy5jcmVhdGVDYW52YXMgPSBjcmVhdGVDYW52YXMxO1xuICAgICAgICB0aGlzLmNyZWF0ZUltYWdlID0gdGhpcy5iaW5kQ3JlYXRlSW1hZ2UoY3JlYXRlSW1hZ2UyLCBhbm9ueW1vdXNDcm9zc09yaWdpbik7XG4gICAgICAgIHRoaXMuc2NyZWVuLndhaXQoKCk9PnRoaXMuaXNJbWFnZXNMb2FkZWQoKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNjcmVlbi53YWl0KCgpPT50aGlzLmlzRm9udHNMb2FkZWQoKVxuICAgICAgICApO1xuICAgIH1cbn1cbkRvY3VtZW50LmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbkRvY3VtZW50LmNyZWF0ZUltYWdlID0gY3JlYXRlSW1hZ2U7XG5Eb2N1bWVudC5lbGVtZW50VHlwZXMgPSBlbGVtZW50cztcblxuLyoqXG4gKiBTVkcgcmVuZGVyZXIgb24gY2FudmFzLlxuICovIGNsYXNzIENhbnZnIHtcbiAgICAvKipcbiAgICogQ3JlYXRlIENhbnZnIGluc3RhbmNlIGZyb20gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZyBvciBVUkwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxuICAgKi8gc3RhdGljIGFzeW5jIGZyb20oY3R4LCBzdmcpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdmdEb2N1bWVudCA9IGF3YWl0IHBhcnNlci5wYXJzZShzdmcpO1xuICAgICAgICByZXR1cm4gbmV3IENhbnZnKGN0eCwgc3ZnRG9jdW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ3JlYXRlIENhbnZnIGluc3RhbmNlIGZyb20gU1ZHIHNvdXJjZSBzdHJpbmcuXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cbiAgICovIHN0YXRpYyBmcm9tU3RyaW5nKGN0eCwgc3ZnKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc3ZnRG9jdW1lbnQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2Zyk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FudmcoY3R4LCBzdmdEb2N1bWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDcmVhdGUgbmV3IENhbnZnIGluc3RhbmNlIHdpdGggaW5oZXJpdGVkIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nIG9yIFVSTC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXG4gICAqLyBmb3JrKGN0eCwgc3ZnKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgICAgcmV0dXJuIENhbnZnLmZyb20oY3R4LCBzdmcsIHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDcmVhdGUgbmV3IENhbnZnIGluc3RhbmNlIHdpdGggaW5oZXJpdGVkIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cbiAgICovIGZvcmtTdHJpbmcoY3R4LCBzdmcpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICByZXR1cm4gQ2FudmcuZnJvbVN0cmluZyhjdHgsIHN2Zywge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIERvY3VtZW50IGlzIHJlYWR5IHByb21pc2UuXG4gICAqIEByZXR1cm5zIFJlYWR5IHByb21pc2UuXG4gICAqLyByZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLnJlYWR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBEb2N1bWVudCBpcyByZWFkeSB2YWx1ZS5cbiAgICogQHJldHVybnMgSXMgcmVhZHkgb3Igbm90LlxuICAgKi8gaXNSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmlzUmVhZHkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJlbmRlciBvbmx5IGZpcnN0IGZyYW1lLCBpZ25vcmluZyBhbmltYXRpb25zIGFuZCBtb3VzZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cbiAgICovIGFzeW5jIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB0aGlzLnN0YXJ0KHtcbiAgICAgICAgICAgIGVuYWJsZVJlZHJhdzogdHJ1ZSxcbiAgICAgICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGlnbm9yZU1vdXNlOiB0cnVlLFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFkeSgpO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFN0YXJ0IHJlbmRlcmluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXIgb3B0aW9ucy5cbiAgICovIHN0YXJ0KCkge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnRFbGVtZW50ICwgc2NyZWVuICwgb3B0aW9uczogYmFzZU9wdGlvbnMgIH0gPSB0aGlzO1xuICAgICAgICBzY3JlZW4uc3RhcnQoZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICAgICAgICBlbmFibGVSZWRyYXc6IHRydWUsXG4gICAgICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTdG9wIHJlbmRlcmluZy5cbiAgICovIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2NyZWVuLnN0b3AoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJlc2l6ZSBTVkcgdG8gZml0IGluIGdpdmVuIHNpemUuXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gaGVpZ2h0XG4gICAqIEBwYXJhbSBwcmVzZXJ2ZUFzcGVjdFJhdGlvXG4gICAqLyByZXNpemUod2lkdGgpIHtcbiAgICAgICAgbGV0IGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogd2lkdGgsIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgICB0aGlzLmRvY3VtZW50RWxlbWVudC5yZXNpemUod2lkdGgsIGhlaWdodCwgcHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBNYWluIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgRG9jdW1lbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXG4gICAqLyBjb25zdHJ1Y3RvcihjdHgsIHN2Zywgb3B0aW9ucyA9IHt9KXtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNjcmVlbiA9IG5ldyBTY3JlZW4oY3R4LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBuZXcgRG9jdW1lbnQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RWxlbWVudChzdmcpO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQUVsZW1lbnQsIEFuaW1hdGVDb2xvckVsZW1lbnQsIEFuaW1hdGVFbGVtZW50LCBBbmltYXRlVHJhbnNmb3JtRWxlbWVudCwgQm91bmRpbmdCb3gsIENCMSwgQ0IyLCBDQjMsIENCNCwgQ2FudmcsIENpcmNsZUVsZW1lbnQsIENsaXBQYXRoRWxlbWVudCwgRGVmc0VsZW1lbnQsIERlc2NFbGVtZW50LCBEb2N1bWVudCwgRWxlbWVudCwgRWxsaXBzZUVsZW1lbnQsIEZlQ29sb3JNYXRyaXhFbGVtZW50LCBGZUNvbXBvc2l0ZUVsZW1lbnQsIEZlRHJvcFNoYWRvd0VsZW1lbnQsIEZlR2F1c3NpYW5CbHVyRWxlbWVudCwgRmVNb3JwaG9sb2d5RWxlbWVudCwgRmlsdGVyRWxlbWVudCwgRm9udCwgRm9udEVsZW1lbnQsIEZvbnRGYWNlRWxlbWVudCwgR0VsZW1lbnQsIEdseXBoRWxlbWVudCwgR3JhZGllbnRFbGVtZW50LCBJbWFnZUVsZW1lbnQsIExpbmVFbGVtZW50LCBMaW5lYXJHcmFkaWVudEVsZW1lbnQsIE1hcmtlckVsZW1lbnQsIE1hc2tFbGVtZW50LCBNYXRyaXgsIE1pc3NpbmdHbHlwaEVsZW1lbnQsIE1vdXNlLCBQU0VVRE9fWkVSTywgUGFyc2VyLCBQYXRoRWxlbWVudCwgUGF0aFBhcnNlciwgUGF0dGVybkVsZW1lbnQsIFBvaW50LCBQb2x5Z29uRWxlbWVudCwgUG9seWxpbmVFbGVtZW50LCBQcm9wZXJ0eSwgUUIxLCBRQjIsIFFCMywgUmFkaWFsR3JhZGllbnRFbGVtZW50LCBSZWN0RWxlbWVudCwgUmVuZGVyZWRFbGVtZW50LCBSb3RhdGUsIFNWR0VsZW1lbnQsIFNWR0ZvbnRMb2FkZXIsIFNjYWxlLCBTY3JlZW4sIFNrZXcsIFNrZXdYLCBTa2V3WSwgU3RvcEVsZW1lbnQsIFN0eWxlRWxlbWVudCwgU3ltYm9sRWxlbWVudCwgVFJlZkVsZW1lbnQsIFRTcGFuRWxlbWVudCwgVGV4dEVsZW1lbnQsIFRleHRQYXRoRWxlbWVudCwgVGl0bGVFbGVtZW50LCBUcmFuc2Zvcm0sIFRyYW5zbGF0ZSwgVW5rbm93bkVsZW1lbnQsIFVzZUVsZW1lbnQsIFZpZXdQb3J0LCBjb21wcmVzc1NwYWNlcywgZWxlbWVudHMsIGdldFNlbGVjdG9yU3BlY2lmaWNpdHksIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUsIG5vcm1hbGl6ZUNvbG9yLCBwYXJzZUV4dGVybmFsVXJsLCBpbmRleCBhcyBwcmVzZXRzLCB0b01hdHJpeFZhbHVlLCB0b051bWJlcnMsIHRyaW1MZWZ0LCB0cmltUmlnaHQsIHZlY3Rvck1hZ25pdHVkZSwgdmVjdG9yc0FuZ2xlLCB2ZWN0b3JzUmF0aW8gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG52YXIgdD1mdW5jdGlvbihyLGUpe3JldHVybih0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LHIpe3QuX19wcm90b19fPXJ9fHxmdW5jdGlvbih0LHIpe2Zvcih2YXIgZSBpbiByKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGUpJiYodFtlXT1yW2VdKX0pKHIsZSl9O2Z1bmN0aW9uIHIocixlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcoZSkrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtmdW5jdGlvbiBpKCl7dGhpcy5jb25zdHJ1Y3Rvcj1yfXQocixlKSxyLnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihpLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgaSl9ZnVuY3Rpb24gZSh0KXt2YXIgcj1cIlwiO0FycmF5LmlzQXJyYXkodCl8fCh0PVt0XSk7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBpPXRbZV07aWYoaS50eXBlPT09Xy5DTE9TRV9QQVRIKXIrPVwielwiO2Vsc2UgaWYoaS50eXBlPT09Xy5IT1JJWl9MSU5FX1RPKXIrPShpLnJlbGF0aXZlP1wiaFwiOlwiSFwiKStpLng7ZWxzZSBpZihpLnR5cGU9PT1fLlZFUlRfTElORV9UTylyKz0oaS5yZWxhdGl2ZT9cInZcIjpcIlZcIikraS55O2Vsc2UgaWYoaS50eXBlPT09Xy5NT1ZFX1RPKXIrPShpLnJlbGF0aXZlP1wibVwiOlwiTVwiKStpLngrXCIgXCIraS55O2Vsc2UgaWYoaS50eXBlPT09Xy5MSU5FX1RPKXIrPShpLnJlbGF0aXZlP1wibFwiOlwiTFwiKStpLngrXCIgXCIraS55O2Vsc2UgaWYoaS50eXBlPT09Xy5DVVJWRV9UTylyKz0oaS5yZWxhdGl2ZT9cImNcIjpcIkNcIikraS54MStcIiBcIitpLnkxK1wiIFwiK2kueDIrXCIgXCIraS55MitcIiBcIitpLngrXCIgXCIraS55O2Vsc2UgaWYoaS50eXBlPT09Xy5TTU9PVEhfQ1VSVkVfVE8pcis9KGkucmVsYXRpdmU/XCJzXCI6XCJTXCIpK2kueDIrXCIgXCIraS55MitcIiBcIitpLngrXCIgXCIraS55O2Vsc2UgaWYoaS50eXBlPT09Xy5RVUFEX1RPKXIrPShpLnJlbGF0aXZlP1wicVwiOlwiUVwiKStpLngxK1wiIFwiK2kueTErXCIgXCIraS54K1wiIFwiK2kueTtlbHNlIGlmKGkudHlwZT09PV8uU01PT1RIX1FVQURfVE8pcis9KGkucmVsYXRpdmU/XCJ0XCI6XCJUXCIpK2kueCtcIiBcIitpLnk7ZWxzZXtpZihpLnR5cGUhPT1fLkFSQyl0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29tbWFuZCB0eXBlIFwiJytpLnR5cGUrJ1wiIGF0IGluZGV4ICcrZStcIi5cIik7cis9KGkucmVsYXRpdmU/XCJhXCI6XCJBXCIpK2kuclgrXCIgXCIraS5yWStcIiBcIitpLnhSb3QrXCIgXCIrICtpLmxBcmNGbGFnK1wiIFwiKyAraS5zd2VlcEZsYWcrXCIgXCIraS54K1wiIFwiK2kueX19cmV0dXJuIHJ9ZnVuY3Rpb24gaSh0LHIpe3ZhciBlPXRbMF0saT10WzFdO3JldHVybltlKk1hdGguY29zKHIpLWkqTWF0aC5zaW4ociksZSpNYXRoLnNpbihyKStpKk1hdGguY29zKHIpXX1mdW5jdGlvbiBhKCl7Zm9yKHZhciB0PVtdLHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXRbcl09YXJndW1lbnRzW3JdO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKFwibnVtYmVyXCIhPXR5cGVvZiB0W2VdKXRocm93IG5ldyBFcnJvcihcImFzc2VydE51bWJlcnMgYXJndW1lbnRzW1wiK2UrXCJdIGlzIG5vdCBhIG51bWJlci4gXCIrdHlwZW9mIHRbZV0rXCIgPT0gdHlwZW9mIFwiK3RbZV0pO3JldHVybiEwfXZhciBuPU1hdGguUEk7ZnVuY3Rpb24gbyh0LHIsZSl7dC5sQXJjRmxhZz0wPT09dC5sQXJjRmxhZz8wOjEsdC5zd2VlcEZsYWc9MD09PXQuc3dlZXBGbGFnPzA6MTt2YXIgYT10LnJYLG89dC5yWSxzPXQueCx1PXQueTthPU1hdGguYWJzKHQuclgpLG89TWF0aC5hYnModC5yWSk7dmFyIGg9aShbKHItcykvMiwoZS11KS8yXSwtdC54Um90LzE4MCpuKSxjPWhbMF0seT1oWzFdLHA9TWF0aC5wb3coYywyKS9NYXRoLnBvdyhhLDIpK01hdGgucG93KHksMikvTWF0aC5wb3cobywyKTsxPHAmJihhKj1NYXRoLnNxcnQocCksbyo9TWF0aC5zcXJ0KHApKSx0LnJYPWEsdC5yWT1vO3ZhciBtPU1hdGgucG93KGEsMikqTWF0aC5wb3coeSwyKStNYXRoLnBvdyhvLDIpKk1hdGgucG93KGMsMiksTz0odC5sQXJjRmxhZyE9PXQuc3dlZXBGbGFnPzE6LTEpKk1hdGguc3FydChNYXRoLm1heCgwLChNYXRoLnBvdyhhLDIpKk1hdGgucG93KG8sMiktbSkvbSkpLGw9YSp5L28qTyxUPS1vKmMvYSpPLHY9aShbbCxUXSx0LnhSb3QvMTgwKm4pO3QuY1g9dlswXSsocitzKS8yLHQuY1k9dlsxXSsoZSt1KS8yLHQucGhpMT1NYXRoLmF0YW4yKCh5LVQpL28sKGMtbCkvYSksdC5waGkyPU1hdGguYXRhbjIoKC15LVQpL28sKC1jLWwpL2EpLDA9PT10LnN3ZWVwRmxhZyYmdC5waGkyPnQucGhpMSYmKHQucGhpMi09MipuKSwxPT09dC5zd2VlcEZsYWcmJnQucGhpMjx0LnBoaTEmJih0LnBoaTIrPTIqbiksdC5waGkxKj0xODAvbix0LnBoaTIqPTE4MC9ufWZ1bmN0aW9uIHModCxyLGUpe2EodCxyLGUpO3ZhciBpPXQqdCtyKnItZSplO2lmKDA+aSlyZXR1cm5bXTtpZigwPT09aSlyZXR1cm5bW3QqZS8odCp0K3IqciksciplLyh0KnQrcipyKV1dO3ZhciBuPU1hdGguc3FydChpKTtyZXR1cm5bWyh0KmUrcipuKS8odCp0K3IqciksKHIqZS10Km4pLyh0KnQrcipyKV0sWyh0KmUtcipuKS8odCp0K3IqciksKHIqZSt0Km4pLyh0KnQrcipyKV1dfXZhciB1LGg9TWF0aC5QSS8xODA7ZnVuY3Rpb24gYyh0LHIsZSl7cmV0dXJuKDEtZSkqdCtlKnJ9ZnVuY3Rpb24geSh0LHIsZSxpKXtyZXR1cm4gdCtNYXRoLmNvcyhpLzE4MCpuKSpyK01hdGguc2luKGkvMTgwKm4pKmV9ZnVuY3Rpb24gcCh0LHIsZSxpKXt2YXIgYT0xZS02LG49ci10LG89ZS1yLHM9MypuKzMqKGktZSktNipvLHU9Niooby1uKSxoPTMqbjtyZXR1cm4gTWF0aC5hYnMocyk8YT9bLWgvdV06ZnVuY3Rpb24odCxyLGUpe3ZvaWQgMD09PWUmJihlPTFlLTYpO3ZhciBpPXQqdC80LXI7aWYoaTwtZSlyZXR1cm5bXTtpZihpPD1lKXJldHVyblstdC8yXTt2YXIgYT1NYXRoLnNxcnQoaSk7cmV0dXJuWy10LzItYSwtdC8yK2FdfSh1L3MsaC9zLGEpfWZ1bmN0aW9uIG0odCxyLGUsaSxhKXt2YXIgbj0xLWE7cmV0dXJuIHQqKG4qbipuKStyKigzKm4qbiphKStlKigzKm4qYSphKStpKihhKmEqYSl9IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIoKXtyZXR1cm4gdSgoZnVuY3Rpb24odCxyLGUpe3JldHVybiB0LnJlbGF0aXZlJiYodm9pZCAwIT09dC54MSYmKHQueDErPXIpLHZvaWQgMCE9PXQueTEmJih0LnkxKz1lKSx2b2lkIDAhPT10LngyJiYodC54Mis9ciksdm9pZCAwIT09dC55MiYmKHQueTIrPWUpLHZvaWQgMCE9PXQueCYmKHQueCs9ciksdm9pZCAwIT09dC55JiYodC55Kz1lKSx0LnJlbGF0aXZlPSExKSx0fSkpfWZ1bmN0aW9uIGUoKXt2YXIgdD1OYU4scj1OYU4sZT1OYU4saT1OYU47cmV0dXJuIHUoKGZ1bmN0aW9uKGEsbixvKXtyZXR1cm4gYS50eXBlJl8uU01PT1RIX0NVUlZFX1RPJiYoYS50eXBlPV8uQ1VSVkVfVE8sdD1pc05hTih0KT9uOnQscj1pc05hTihyKT9vOnIsYS54MT1hLnJlbGF0aXZlP24tdDoyKm4tdCxhLnkxPWEucmVsYXRpdmU/by1yOjIqby1yKSxhLnR5cGUmXy5DVVJWRV9UTz8odD1hLnJlbGF0aXZlP24rYS54MjphLngyLHI9YS5yZWxhdGl2ZT9vK2EueTI6YS55Mik6KHQ9TmFOLHI9TmFOKSxhLnR5cGUmXy5TTU9PVEhfUVVBRF9UTyYmKGEudHlwZT1fLlFVQURfVE8sZT1pc05hTihlKT9uOmUsaT1pc05hTihpKT9vOmksYS54MT1hLnJlbGF0aXZlP24tZToyKm4tZSxhLnkxPWEucmVsYXRpdmU/by1pOjIqby1pKSxhLnR5cGUmXy5RVUFEX1RPPyhlPWEucmVsYXRpdmU/bithLngxOmEueDEsaT1hLnJlbGF0aXZlP28rYS55MTphLnkxKTooZT1OYU4saT1OYU4pLGF9KSl9ZnVuY3Rpb24gbigpe3ZhciB0PU5hTixyPU5hTjtyZXR1cm4gdSgoZnVuY3Rpb24oZSxpLGEpe2lmKGUudHlwZSZfLlNNT09USF9RVUFEX1RPJiYoZS50eXBlPV8uUVVBRF9UTyx0PWlzTmFOKHQpP2k6dCxyPWlzTmFOKHIpP2E6cixlLngxPWUucmVsYXRpdmU/aS10OjIqaS10LGUueTE9ZS5yZWxhdGl2ZT9hLXI6MiphLXIpLGUudHlwZSZfLlFVQURfVE8pe3Q9ZS5yZWxhdGl2ZT9pK2UueDE6ZS54MSxyPWUucmVsYXRpdmU/YStlLnkxOmUueTE7dmFyIG49ZS54MSxvPWUueTE7ZS50eXBlPV8uQ1VSVkVfVE8sZS54MT0oKGUucmVsYXRpdmU/MDppKSsyKm4pLzMsZS55MT0oKGUucmVsYXRpdmU/MDphKSsyKm8pLzMsZS54Mj0oZS54KzIqbikvMyxlLnkyPShlLnkrMipvKS8zfWVsc2UgdD1OYU4scj1OYU47cmV0dXJuIGV9KSl9ZnVuY3Rpb24gdSh0KXt2YXIgcj0wLGU9MCxpPU5hTixhPU5hTjtyZXR1cm4gZnVuY3Rpb24obil7aWYoaXNOYU4oaSkmJiEobi50eXBlJl8uTU9WRV9UTykpdGhyb3cgbmV3IEVycm9yKFwicGF0aCBtdXN0IHN0YXJ0IHdpdGggbW92ZXRvXCIpO3ZhciBvPXQobixyLGUsaSxhKTtyZXR1cm4gbi50eXBlJl8uQ0xPU0VfUEFUSCYmKHI9aSxlPWEpLHZvaWQgMCE9PW4ueCYmKHI9bi5yZWxhdGl2ZT9yK24ueDpuLngpLHZvaWQgMCE9PW4ueSYmKGU9bi5yZWxhdGl2ZT9lK24ueTpuLnkpLG4udHlwZSZfLk1PVkVfVE8mJihpPXIsYT1lKSxvfX1mdW5jdGlvbiBPKHQscixlLGksbixvKXtyZXR1cm4gYSh0LHIsZSxpLG4sbyksdSgoZnVuY3Rpb24oYSxzLHUsaCl7dmFyIGM9YS54MSx5PWEueDIscD1hLnJlbGF0aXZlJiYhaXNOYU4oaCksbT12b2lkIDAhPT1hLng/YS54OnA/MDpzLE89dm9pZCAwIT09YS55P2EueTpwPzA6dTtmdW5jdGlvbiBsKHQpe3JldHVybiB0KnR9YS50eXBlJl8uSE9SSVpfTElORV9UTyYmMCE9PXImJihhLnR5cGU9Xy5MSU5FX1RPLGEueT1hLnJlbGF0aXZlPzA6dSksYS50eXBlJl8uVkVSVF9MSU5FX1RPJiYwIT09ZSYmKGEudHlwZT1fLkxJTkVfVE8sYS54PWEucmVsYXRpdmU/MDpzKSx2b2lkIDAhPT1hLngmJihhLng9YS54KnQrTyplKyhwPzA6bikpLHZvaWQgMCE9PWEueSYmKGEueT1tKnIrYS55KmkrKHA/MDpvKSksdm9pZCAwIT09YS54MSYmKGEueDE9YS54MSp0K2EueTEqZSsocD8wOm4pKSx2b2lkIDAhPT1hLnkxJiYoYS55MT1jKnIrYS55MSppKyhwPzA6bykpLHZvaWQgMCE9PWEueDImJihhLngyPWEueDIqdCthLnkyKmUrKHA/MDpuKSksdm9pZCAwIT09YS55MiYmKGEueTI9eSpyK2EueTIqaSsocD8wOm8pKTt2YXIgVD10KmktciplO2lmKHZvaWQgMCE9PWEueFJvdCYmKDEhPT10fHwwIT09cnx8MCE9PWV8fDEhPT1pKSlpZigwPT09VClkZWxldGUgYS5yWCxkZWxldGUgYS5yWSxkZWxldGUgYS54Um90LGRlbGV0ZSBhLmxBcmNGbGFnLGRlbGV0ZSBhLnN3ZWVwRmxhZyxhLnR5cGU9Xy5MSU5FX1RPO2Vsc2V7dmFyIHY9YS54Um90Kk1hdGguUEkvMTgwLGY9TWF0aC5zaW4odiksTj1NYXRoLmNvcyh2KSx4PTEvbChhLnJYKSxkPTEvbChhLnJZKSxFPWwoTikqeCtsKGYpKmQsQT0yKmYqTiooeC1kKSxDPWwoZikqeCtsKE4pKmQsTT1FKmkqaS1BKnIqaStDKnIqcixSPUEqKHQqaStyKmUpLTIqKEUqZSppK0MqdCpyKSxnPUUqZSplLUEqdCplK0MqdCp0LEk9KE1hdGguYXRhbjIoUixNLWcpK01hdGguUEkpJU1hdGguUEkvMixTPU1hdGguc2luKEkpLEw9TWF0aC5jb3MoSSk7YS5yWD1NYXRoLmFicyhUKS9NYXRoLnNxcnQoTSpsKEwpK1IqUypMK2cqbChTKSksYS5yWT1NYXRoLmFicyhUKS9NYXRoLnNxcnQoTSpsKFMpLVIqUypMK2cqbChMKSksYS54Um90PTE4MCpJL01hdGguUEl9cmV0dXJuIHZvaWQgMCE9PWEuc3dlZXBGbGFnJiYwPlQmJihhLnN3ZWVwRmxhZz0rIWEuc3dlZXBGbGFnKSxhfSkpfWZ1bmN0aW9uIGwoKXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIHI9e307Zm9yKHZhciBlIGluIHQpcltlXT10W2VdO3JldHVybiByfX10LlJPVU5EPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIocil7cmV0dXJuIE1hdGgucm91bmQocip0KS90fXJldHVybiB2b2lkIDA9PT10JiYodD0xZTEzKSxhKHQpLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10LngxJiYodC54MT1yKHQueDEpKSx2b2lkIDAhPT10LnkxJiYodC55MT1yKHQueTEpKSx2b2lkIDAhPT10LngyJiYodC54Mj1yKHQueDIpKSx2b2lkIDAhPT10LnkyJiYodC55Mj1yKHQueTIpKSx2b2lkIDAhPT10LngmJih0Lng9cih0LngpKSx2b2lkIDAhPT10LnkmJih0Lnk9cih0LnkpKSx2b2lkIDAhPT10LnJYJiYodC5yWD1yKHQuclgpKSx2b2lkIDAhPT10LnJZJiYodC5yWT1yKHQuclkpKSx0fX0sdC5UT19BQlM9cix0LlRPX1JFTD1mdW5jdGlvbigpe3JldHVybiB1KChmdW5jdGlvbih0LHIsZSl7cmV0dXJuIHQucmVsYXRpdmV8fCh2b2lkIDAhPT10LngxJiYodC54MS09ciksdm9pZCAwIT09dC55MSYmKHQueTEtPWUpLHZvaWQgMCE9PXQueDImJih0LngyLT1yKSx2b2lkIDAhPT10LnkyJiYodC55Mi09ZSksdm9pZCAwIT09dC54JiYodC54LT1yKSx2b2lkIDAhPT10LnkmJih0LnktPWUpLHQucmVsYXRpdmU9ITApLHR9KSl9LHQuTk9STUFMSVpFX0hWWj1mdW5jdGlvbih0LHIsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSEwKSx2b2lkIDA9PT1yJiYocj0hMCksdm9pZCAwPT09ZSYmKGU9ITApLHUoKGZ1bmN0aW9uKGksYSxuLG8scyl7aWYoaXNOYU4obykmJiEoaS50eXBlJl8uTU9WRV9UTykpdGhyb3cgbmV3IEVycm9yKFwicGF0aCBtdXN0IHN0YXJ0IHdpdGggbW92ZXRvXCIpO3JldHVybiByJiZpLnR5cGUmXy5IT1JJWl9MSU5FX1RPJiYoaS50eXBlPV8uTElORV9UTyxpLnk9aS5yZWxhdGl2ZT8wOm4pLGUmJmkudHlwZSZfLlZFUlRfTElORV9UTyYmKGkudHlwZT1fLkxJTkVfVE8saS54PWkucmVsYXRpdmU/MDphKSx0JiZpLnR5cGUmXy5DTE9TRV9QQVRIJiYoaS50eXBlPV8uTElORV9UTyxpLng9aS5yZWxhdGl2ZT9vLWE6byxpLnk9aS5yZWxhdGl2ZT9zLW46cyksaS50eXBlJl8uQVJDJiYoMD09PWkuclh8fDA9PT1pLnJZKSYmKGkudHlwZT1fLkxJTkVfVE8sZGVsZXRlIGkuclgsZGVsZXRlIGkuclksZGVsZXRlIGkueFJvdCxkZWxldGUgaS5sQXJjRmxhZyxkZWxldGUgaS5zd2VlcEZsYWcpLGl9KSl9LHQuTk9STUFMSVpFX1NUPWUsdC5RVF9UT19DPW4sdC5JTkZPPXUsdC5TQU5JVElaRT1mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD0wKSxhKHQpO3ZhciByPU5hTixlPU5hTixpPU5hTixuPU5hTjtyZXR1cm4gdSgoZnVuY3Rpb24oYSxvLHMsdSxoKXt2YXIgYz1NYXRoLmFicyx5PSExLHA9MCxtPTA7aWYoYS50eXBlJl8uU01PT1RIX0NVUlZFX1RPJiYocD1pc05hTihyKT8wOm8tcixtPWlzTmFOKGUpPzA6cy1lKSxhLnR5cGUmKF8uQ1VSVkVfVE98Xy5TTU9PVEhfQ1VSVkVfVE8pPyhyPWEucmVsYXRpdmU/bythLngyOmEueDIsZT1hLnJlbGF0aXZlP3MrYS55MjphLnkyKToocj1OYU4sZT1OYU4pLGEudHlwZSZfLlNNT09USF9RVUFEX1RPPyhpPWlzTmFOKGkpP286MipvLWksbj1pc05hTihuKT9zOjIqcy1uKTphLnR5cGUmXy5RVUFEX1RPPyhpPWEucmVsYXRpdmU/bythLngxOmEueDEsbj1hLnJlbGF0aXZlP3MrYS55MTphLnkyKTooaT1OYU4sbj1OYU4pLGEudHlwZSZfLkxJTkVfQ09NTUFORFN8fGEudHlwZSZfLkFSQyYmKDA9PT1hLnJYfHwwPT09YS5yWXx8IWEubEFyY0ZsYWcpfHxhLnR5cGUmXy5DVVJWRV9UT3x8YS50eXBlJl8uU01PT1RIX0NVUlZFX1RPfHxhLnR5cGUmXy5RVUFEX1RPfHxhLnR5cGUmXy5TTU9PVEhfUVVBRF9UTyl7dmFyIE89dm9pZCAwPT09YS54PzA6YS5yZWxhdGl2ZT9hLng6YS54LW8sbD12b2lkIDA9PT1hLnk/MDphLnJlbGF0aXZlP2EueTphLnktcztwPWlzTmFOKGkpP3ZvaWQgMD09PWEueDE/cDphLnJlbGF0aXZlP2EueDphLngxLW86aS1vLG09aXNOYU4obik/dm9pZCAwPT09YS55MT9tOmEucmVsYXRpdmU/YS55OmEueTEtczpuLXM7dmFyIFQ9dm9pZCAwPT09YS54Mj8wOmEucmVsYXRpdmU/YS54OmEueDItbyx2PXZvaWQgMD09PWEueTI/MDphLnJlbGF0aXZlP2EueTphLnkyLXM7YyhPKTw9dCYmYyhsKTw9dCYmYyhwKTw9dCYmYyhtKTw9dCYmYyhUKTw9dCYmYyh2KTw9dCYmKHk9ITApfXJldHVybiBhLnR5cGUmXy5DTE9TRV9QQVRIJiZjKG8tdSk8PXQmJmMocy1oKTw9dCYmKHk9ITApLHk/W106YX0pKX0sdC5NQVRSSVg9Tyx0LlJPVEFURT1mdW5jdGlvbih0LHIsZSl7dm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09ZSYmKGU9MCksYSh0LHIsZSk7dmFyIGk9TWF0aC5zaW4odCksbj1NYXRoLmNvcyh0KTtyZXR1cm4gTyhuLGksLWksbixyLXIqbitlKmksZS1yKmktZSpuKX0sdC5UUkFOU0xBVEU9ZnVuY3Rpb24odCxyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MCksYSh0LHIpLE8oMSwwLDAsMSx0LHIpfSx0LlNDQUxFPWZ1bmN0aW9uKHQscil7cmV0dXJuIHZvaWQgMD09PXImJihyPXQpLGEodCxyKSxPKHQsMCwwLHIsMCwwKX0sdC5TS0VXX1g9ZnVuY3Rpb24odCl7cmV0dXJuIGEodCksTygxLDAsTWF0aC5hdGFuKHQpLDEsMCwwKX0sdC5TS0VXX1k9ZnVuY3Rpb24odCl7cmV0dXJuIGEodCksTygxLE1hdGguYXRhbih0KSwwLDEsMCwwKX0sdC5YX0FYSVNfU1lNTUVUUlk9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLGEodCksTygtMSwwLDAsMSx0LDApfSx0LllfQVhJU19TWU1NRVRSWT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksYSh0KSxPKDEsMCwwLC0xLDAsdCl9LHQuQV9UT19DPWZ1bmN0aW9uKCl7cmV0dXJuIHUoKGZ1bmN0aW9uKHQscixlKXtyZXR1cm4gXy5BUkM9PT10LnR5cGU/ZnVuY3Rpb24odCxyLGUpe3ZhciBhLG4scyx1O3QuY1h8fG8odCxyLGUpO2Zvcih2YXIgeT1NYXRoLm1pbih0LnBoaTEsdC5waGkyKSxwPU1hdGgubWF4KHQucGhpMSx0LnBoaTIpLXksbT1NYXRoLmNlaWwocC85MCksTz1uZXcgQXJyYXkobSksbD1yLFQ9ZSx2PTA7djxtO3YrKyl7dmFyIGY9Yyh0LnBoaTEsdC5waGkyLHYvbSksTj1jKHQucGhpMSx0LnBoaTIsKHYrMSkvbSkseD1OLWYsZD00LzMqTWF0aC50YW4oeCpoLzQpLEU9W01hdGguY29zKGYqaCktZCpNYXRoLnNpbihmKmgpLE1hdGguc2luKGYqaCkrZCpNYXRoLmNvcyhmKmgpXSxBPUVbMF0sQz1FWzFdLE09W01hdGguY29zKE4qaCksTWF0aC5zaW4oTipoKV0sUj1NWzBdLGc9TVsxXSxJPVtSK2QqTWF0aC5zaW4oTipoKSxnLWQqTWF0aC5jb3MoTipoKV0sUz1JWzBdLEw9SVsxXTtPW3ZdPXtyZWxhdGl2ZTp0LnJlbGF0aXZlLHR5cGU6Xy5DVVJWRV9UT307dmFyIEg9ZnVuY3Rpb24ocixlKXt2YXIgYT1pKFtyKnQuclgsZSp0LnJZXSx0LnhSb3QpLG49YVswXSxvPWFbMV07cmV0dXJuW3QuY1grbix0LmNZK29dfTthPUgoQSxDKSxPW3ZdLngxPWFbMF0sT1t2XS55MT1hWzFdLG49SChTLEwpLE9bdl0ueDI9blswXSxPW3ZdLnkyPW5bMV0scz1IKFIsZyksT1t2XS54PXNbMF0sT1t2XS55PXNbMV0sdC5yZWxhdGl2ZSYmKE9bdl0ueDEtPWwsT1t2XS55MS09VCxPW3ZdLngyLT1sLE9bdl0ueTItPVQsT1t2XS54LT1sLE9bdl0ueS09VCksbD0odT1bT1t2XS54LE9bdl0ueV0pWzBdLFQ9dVsxXX1yZXR1cm4gT30odCx0LnJlbGF0aXZlPzA6cix0LnJlbGF0aXZlPzA6ZSk6dH0pKX0sdC5BTk5PVEFURV9BUkNTPWZ1bmN0aW9uKCl7cmV0dXJuIHUoKGZ1bmN0aW9uKHQscixlKXtyZXR1cm4gdC5yZWxhdGl2ZSYmKHI9MCxlPTApLF8uQVJDPT09dC50eXBlJiZvKHQscixlKSx0fSkpfSx0LkNMT05FPWwsdC5DQUxDVUxBVEVfQk9VTkRTPWZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24odCl7dmFyIHI9e307Zm9yKHZhciBlIGluIHQpcltlXT10W2VdO3JldHVybiByfSxpPXIoKSxhPW4oKSxoPWUoKSxjPXUoKGZ1bmN0aW9uKHIsZSxuKXt2YXIgdT1oKGEoaSh0KHIpKSkpO2Z1bmN0aW9uIE8odCl7dD5jLm1heFgmJihjLm1heFg9dCksdDxjLm1pblgmJihjLm1pblg9dCl9ZnVuY3Rpb24gbCh0KXt0PmMubWF4WSYmKGMubWF4WT10KSx0PGMubWluWSYmKGMubWluWT10KX1pZih1LnR5cGUmXy5EUkFXSU5HX0NPTU1BTkRTJiYoTyhlKSxsKG4pKSx1LnR5cGUmXy5IT1JJWl9MSU5FX1RPJiZPKHUueCksdS50eXBlJl8uVkVSVF9MSU5FX1RPJiZsKHUueSksdS50eXBlJl8uTElORV9UTyYmKE8odS54KSxsKHUueSkpLHUudHlwZSZfLkNVUlZFX1RPKXtPKHUueCksbCh1LnkpO2Zvcih2YXIgVD0wLHY9cChlLHUueDEsdS54Mix1LngpO1Q8di5sZW5ndGg7VCsrKXswPCh3PXZbVF0pJiYxPncmJk8obShlLHUueDEsdS54Mix1LngsdykpfWZvcih2YXIgZj0wLE49cChuLHUueTEsdS55Mix1LnkpO2Y8Ti5sZW5ndGg7ZisrKXswPCh3PU5bZl0pJiYxPncmJmwobShuLHUueTEsdS55Mix1LnksdykpfX1pZih1LnR5cGUmXy5BUkMpe08odS54KSxsKHUueSksbyh1LGUsbik7Zm9yKHZhciB4PXUueFJvdC8xODAqTWF0aC5QSSxkPU1hdGguY29zKHgpKnUuclgsRT1NYXRoLnNpbih4KSp1LnJYLEE9LU1hdGguc2luKHgpKnUuclksQz1NYXRoLmNvcyh4KSp1LnJZLE09dS5waGkxPHUucGhpMj9bdS5waGkxLHUucGhpMl06LTE4MD51LnBoaTI/W3UucGhpMiszNjAsdS5waGkxKzM2MF06W3UucGhpMix1LnBoaTFdLFI9TVswXSxnPU1bMV0sST1mdW5jdGlvbih0KXt2YXIgcj10WzBdLGU9dFsxXSxpPTE4MCpNYXRoLmF0YW4yKGUscikvTWF0aC5QSTtyZXR1cm4gaTxSP2krMzYwOml9LFM9MCxMPXMoQSwtZCwwKS5tYXAoSSk7UzxMLmxlbmd0aDtTKyspeyh3PUxbU10pPlImJnc8ZyYmTyh5KHUuY1gsZCxBLHcpKX1mb3IodmFyIEg9MCxVPXMoQywtRSwwKS5tYXAoSSk7SDxVLmxlbmd0aDtIKyspe3ZhciB3Oyh3PVVbSF0pPlImJnc8ZyYmbCh5KHUuY1ksRSxDLHcpKX19cmV0dXJuIHJ9KSk7cmV0dXJuIGMubWluWD0xLzAsYy5tYXhYPS0xLzAsYy5taW5ZPTEvMCxjLm1heFk9LTEvMCxjfX0odXx8KHU9e30pKTt2YXIgTyxsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuUk9VTkQodCkpfSx0LnByb3RvdHlwZS50b0Ficz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlRPX0FCUygpKX0sdC5wcm90b3R5cGUudG9SZWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5UT19SRUwoKSl9LHQucHJvdG90eXBlLm5vcm1hbGl6ZUhWWj1mdW5jdGlvbih0LHIsZSl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuTk9STUFMSVpFX0hWWih0LHIsZSkpfSx0LnByb3RvdHlwZS5ub3JtYWxpemVTVD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1Lk5PUk1BTElaRV9TVCgpKX0sdC5wcm90b3R5cGUucXRUb0M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5RVF9UT19DKCkpfSx0LnByb3RvdHlwZS5hVG9DPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuQV9UT19DKCkpfSx0LnByb3RvdHlwZS5zYW5pdGl6ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5TQU5JVElaRSh0KSl9LHQucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbih0LHIpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlRSQU5TTEFURSh0LHIpKX0sdC5wcm90b3R5cGUuc2NhbGU9ZnVuY3Rpb24odCxyKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5TQ0FMRSh0LHIpKX0sdC5wcm90b3R5cGUucm90YXRlPWZ1bmN0aW9uKHQscixlKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5ST1RBVEUodCxyLGUpKX0sdC5wcm90b3R5cGUubWF0cml4PWZ1bmN0aW9uKHQscixlLGksYSxuKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5NQVRSSVgodCxyLGUsaSxhLG4pKX0sdC5wcm90b3R5cGUuc2tld1g9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuU0tFV19YKHQpKX0sdC5wcm90b3R5cGUuc2tld1k9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuU0tFV19ZKHQpKX0sdC5wcm90b3R5cGUueFN5bW1ldHJ5PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlhfQVhJU19TWU1NRVRSWSh0KSl9LHQucHJvdG90eXBlLnlTeW1tZXRyeT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5ZX0FYSVNfU1lNTUVUUlkodCkpfSx0LnByb3RvdHlwZS5hbm5vdGF0ZUFyY3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5BTk5PVEFURV9BUkNTKCkpfSx0fSgpLFQ9ZnVuY3Rpb24odCl7cmV0dXJuXCIgXCI9PT10fHxcIlxcdFwiPT09dHx8XCJcXHJcIj09PXR8fFwiXFxuXCI9PT10fSx2PWZ1bmN0aW9uKHQpe3JldHVyblwiMFwiLmNoYXJDb2RlQXQoMCk8PXQuY2hhckNvZGVBdCgwKSYmdC5jaGFyQ29kZUF0KDApPD1cIjlcIi5jaGFyQ29kZUF0KDApfSxmPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIuY3VyTnVtYmVyPVwiXCIsci5jdXJDb21tYW5kVHlwZT0tMSxyLmN1ckNvbW1hbmRSZWxhdGl2ZT0hMSxyLmNhblBhcnNlQ29tbWFuZE9yQ29tbWE9ITAsci5jdXJOdW1iZXJIYXNFeHA9ITEsci5jdXJOdW1iZXJIYXNFeHBEaWdpdHM9ITEsci5jdXJOdW1iZXJIYXNEZWNpbWFsPSExLHIuY3VyQXJncz1bXSxyfXJldHVybiByKGUsdCksZS5wcm90b3R5cGUuZmluaXNoPWZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQmJih0PVtdKSx0aGlzLnBhcnNlKFwiIFwiLHQpLDAhPT10aGlzLmN1ckFyZ3MubGVuZ3RofHwhdGhpcy5jYW5QYXJzZUNvbW1hbmRPckNvbW1hKXRocm93IG5ldyBTeW50YXhFcnJvcihcIlVudGVybWluYXRlZCBjb21tYW5kIGF0IHRoZSBwYXRoIGVuZC5cIik7cmV0dXJuIHR9LGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKHQscil7dmFyIGU9dGhpczt2b2lkIDA9PT1yJiYocj1bXSk7Zm9yKHZhciBpPWZ1bmN0aW9uKHQpe3IucHVzaCh0KSxlLmN1ckFyZ3MubGVuZ3RoPTAsZS5jYW5QYXJzZUNvbW1hbmRPckNvbW1hPSEwfSxhPTA7YTx0Lmxlbmd0aDthKyspe3ZhciBuPXRbYV0sbz0hKHRoaXMuY3VyQ29tbWFuZFR5cGUhPT1fLkFSQ3x8MyE9PXRoaXMuY3VyQXJncy5sZW5ndGgmJjQhPT10aGlzLmN1ckFyZ3MubGVuZ3RofHwxIT09dGhpcy5jdXJOdW1iZXIubGVuZ3RofHxcIjBcIiE9PXRoaXMuY3VyTnVtYmVyJiZcIjFcIiE9PXRoaXMuY3VyTnVtYmVyKSxzPXYobikmJihcIjBcIj09PXRoaXMuY3VyTnVtYmVyJiZcIjBcIj09PW58fG8pO2lmKCF2KG4pfHxzKWlmKFwiZVwiIT09biYmXCJFXCIhPT1uKWlmKFwiLVwiIT09biYmXCIrXCIhPT1ufHwhdGhpcy5jdXJOdW1iZXJIYXNFeHB8fHRoaXMuY3VyTnVtYmVySGFzRXhwRGlnaXRzKWlmKFwiLlwiIT09bnx8dGhpcy5jdXJOdW1iZXJIYXNFeHB8fHRoaXMuY3VyTnVtYmVySGFzRGVjaW1hbHx8byl7aWYodGhpcy5jdXJOdW1iZXImJi0xIT09dGhpcy5jdXJDb21tYW5kVHlwZSl7dmFyIHU9TnVtYmVyKHRoaXMuY3VyTnVtYmVyKTtpZihpc05hTih1KSl0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJJbnZhbGlkIG51bWJlciBlbmRpbmcgYXQgXCIrYSk7aWYodGhpcy5jdXJDb21tYW5kVHlwZT09PV8uQVJDKWlmKDA9PT10aGlzLmN1ckFyZ3MubGVuZ3RofHwxPT09dGhpcy5jdXJBcmdzLmxlbmd0aCl7aWYoMD51KXRocm93IG5ldyBTeW50YXhFcnJvcignRXhwZWN0ZWQgcG9zaXRpdmUgbnVtYmVyLCBnb3QgXCInK3UrJ1wiIGF0IGluZGV4IFwiJythKydcIicpfWVsc2UgaWYoKDM9PT10aGlzLmN1ckFyZ3MubGVuZ3RofHw0PT09dGhpcy5jdXJBcmdzLmxlbmd0aCkmJlwiMFwiIT09dGhpcy5jdXJOdW1iZXImJlwiMVwiIT09dGhpcy5jdXJOdW1iZXIpdGhyb3cgbmV3IFN5bnRheEVycm9yKCdFeHBlY3RlZCBhIGZsYWcsIGdvdCBcIicrdGhpcy5jdXJOdW1iZXIrJ1wiIGF0IGluZGV4IFwiJythKydcIicpO3RoaXMuY3VyQXJncy5wdXNoKHUpLHRoaXMuY3VyQXJncy5sZW5ndGg9PT1OW3RoaXMuY3VyQ29tbWFuZFR5cGVdJiYoXy5IT1JJWl9MSU5FX1RPPT09dGhpcy5jdXJDb21tYW5kVHlwZT9pKHt0eXBlOl8uSE9SSVpfTElORV9UTyxyZWxhdGl2ZTp0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZSx4OnV9KTpfLlZFUlRfTElORV9UTz09PXRoaXMuY3VyQ29tbWFuZFR5cGU/aSh7dHlwZTpfLlZFUlRfTElORV9UTyxyZWxhdGl2ZTp0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZSx5OnV9KTp0aGlzLmN1ckNvbW1hbmRUeXBlPT09Xy5NT1ZFX1RPfHx0aGlzLmN1ckNvbW1hbmRUeXBlPT09Xy5MSU5FX1RPfHx0aGlzLmN1ckNvbW1hbmRUeXBlPT09Xy5TTU9PVEhfUVVBRF9UTz8oaSh7dHlwZTp0aGlzLmN1ckNvbW1hbmRUeXBlLHJlbGF0aXZlOnRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlLHg6dGhpcy5jdXJBcmdzWzBdLHk6dGhpcy5jdXJBcmdzWzFdfSksXy5NT1ZFX1RPPT09dGhpcy5jdXJDb21tYW5kVHlwZSYmKHRoaXMuY3VyQ29tbWFuZFR5cGU9Xy5MSU5FX1RPKSk6dGhpcy5jdXJDb21tYW5kVHlwZT09PV8uQ1VSVkVfVE8/aSh7dHlwZTpfLkNVUlZFX1RPLHJlbGF0aXZlOnRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlLHgxOnRoaXMuY3VyQXJnc1swXSx5MTp0aGlzLmN1ckFyZ3NbMV0seDI6dGhpcy5jdXJBcmdzWzJdLHkyOnRoaXMuY3VyQXJnc1szXSx4OnRoaXMuY3VyQXJnc1s0XSx5OnRoaXMuY3VyQXJnc1s1XX0pOnRoaXMuY3VyQ29tbWFuZFR5cGU9PT1fLlNNT09USF9DVVJWRV9UTz9pKHt0eXBlOl8uU01PT1RIX0NVUlZFX1RPLHJlbGF0aXZlOnRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlLHgyOnRoaXMuY3VyQXJnc1swXSx5Mjp0aGlzLmN1ckFyZ3NbMV0seDp0aGlzLmN1ckFyZ3NbMl0seTp0aGlzLmN1ckFyZ3NbM119KTp0aGlzLmN1ckNvbW1hbmRUeXBlPT09Xy5RVUFEX1RPP2koe3R5cGU6Xy5RVUFEX1RPLHJlbGF0aXZlOnRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlLHgxOnRoaXMuY3VyQXJnc1swXSx5MTp0aGlzLmN1ckFyZ3NbMV0seDp0aGlzLmN1ckFyZ3NbMl0seTp0aGlzLmN1ckFyZ3NbM119KTp0aGlzLmN1ckNvbW1hbmRUeXBlPT09Xy5BUkMmJmkoe3R5cGU6Xy5BUkMscmVsYXRpdmU6dGhpcy5jdXJDb21tYW5kUmVsYXRpdmUsclg6dGhpcy5jdXJBcmdzWzBdLHJZOnRoaXMuY3VyQXJnc1sxXSx4Um90OnRoaXMuY3VyQXJnc1syXSxsQXJjRmxhZzp0aGlzLmN1ckFyZ3NbM10sc3dlZXBGbGFnOnRoaXMuY3VyQXJnc1s0XSx4OnRoaXMuY3VyQXJnc1s1XSx5OnRoaXMuY3VyQXJnc1s2XX0pKSx0aGlzLmN1ck51bWJlcj1cIlwiLHRoaXMuY3VyTnVtYmVySGFzRXhwRGlnaXRzPSExLHRoaXMuY3VyTnVtYmVySGFzRXhwPSExLHRoaXMuY3VyTnVtYmVySGFzRGVjaW1hbD0hMSx0aGlzLmNhblBhcnNlQ29tbWFuZE9yQ29tbWE9ITB9aWYoIVQobikpaWYoXCIsXCI9PT1uJiZ0aGlzLmNhblBhcnNlQ29tbWFuZE9yQ29tbWEpdGhpcy5jYW5QYXJzZUNvbW1hbmRPckNvbW1hPSExO2Vsc2UgaWYoXCIrXCIhPT1uJiZcIi1cIiE9PW4mJlwiLlwiIT09bilpZihzKXRoaXMuY3VyTnVtYmVyPW4sdGhpcy5jdXJOdW1iZXJIYXNEZWNpbWFsPSExO2Vsc2V7aWYoMCE9PXRoaXMuY3VyQXJncy5sZW5ndGgpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW50ZXJtaW5hdGVkIGNvbW1hbmQgYXQgaW5kZXggXCIrYStcIi5cIik7aWYoIXRoaXMuY2FuUGFyc2VDb21tYW5kT3JDb21tYSl0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiJytuKydcIiBhdCBpbmRleCAnK2ErXCIuIENvbW1hbmQgY2Fubm90IGZvbGxvdyBjb21tYVwiKTtpZih0aGlzLmNhblBhcnNlQ29tbWFuZE9yQ29tbWE9ITEsXCJ6XCIhPT1uJiZcIlpcIiE9PW4paWYoXCJoXCI9PT1ufHxcIkhcIj09PW4pdGhpcy5jdXJDb21tYW5kVHlwZT1fLkhPUklaX0xJTkVfVE8sdGhpcy5jdXJDb21tYW5kUmVsYXRpdmU9XCJoXCI9PT1uO2Vsc2UgaWYoXCJ2XCI9PT1ufHxcIlZcIj09PW4pdGhpcy5jdXJDb21tYW5kVHlwZT1fLlZFUlRfTElORV9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT1cInZcIj09PW47ZWxzZSBpZihcIm1cIj09PW58fFwiTVwiPT09bil0aGlzLmN1ckNvbW1hbmRUeXBlPV8uTU9WRV9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT1cIm1cIj09PW47ZWxzZSBpZihcImxcIj09PW58fFwiTFwiPT09bil0aGlzLmN1ckNvbW1hbmRUeXBlPV8uTElORV9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT1cImxcIj09PW47ZWxzZSBpZihcImNcIj09PW58fFwiQ1wiPT09bil0aGlzLmN1ckNvbW1hbmRUeXBlPV8uQ1VSVkVfVE8sdGhpcy5jdXJDb21tYW5kUmVsYXRpdmU9XCJjXCI9PT1uO2Vsc2UgaWYoXCJzXCI9PT1ufHxcIlNcIj09PW4pdGhpcy5jdXJDb21tYW5kVHlwZT1fLlNNT09USF9DVVJWRV9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT1cInNcIj09PW47ZWxzZSBpZihcInFcIj09PW58fFwiUVwiPT09bil0aGlzLmN1ckNvbW1hbmRUeXBlPV8uUVVBRF9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT1cInFcIj09PW47ZWxzZSBpZihcInRcIj09PW58fFwiVFwiPT09bil0aGlzLmN1ckNvbW1hbmRUeXBlPV8uU01PT1RIX1FVQURfVE8sdGhpcy5jdXJDb21tYW5kUmVsYXRpdmU9XCJ0XCI9PT1uO2Vsc2V7aWYoXCJhXCIhPT1uJiZcIkFcIiE9PW4pdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGNoYXJhY3RlciBcIicrbisnXCIgYXQgaW5kZXggJythK1wiLlwiKTt0aGlzLmN1ckNvbW1hbmRUeXBlPV8uQVJDLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPVwiYVwiPT09bn1lbHNlIHIucHVzaCh7dHlwZTpfLkNMT1NFX1BBVEh9KSx0aGlzLmNhblBhcnNlQ29tbWFuZE9yQ29tbWE9ITAsdGhpcy5jdXJDb21tYW5kVHlwZT0tMX1lbHNlIHRoaXMuY3VyTnVtYmVyPW4sdGhpcy5jdXJOdW1iZXJIYXNEZWNpbWFsPVwiLlwiPT09bn1lbHNlIHRoaXMuY3VyTnVtYmVyKz1uLHRoaXMuY3VyTnVtYmVySGFzRGVjaW1hbD0hMDtlbHNlIHRoaXMuY3VyTnVtYmVyKz1uO2Vsc2UgdGhpcy5jdXJOdW1iZXIrPW4sdGhpcy5jdXJOdW1iZXJIYXNFeHA9ITA7ZWxzZSB0aGlzLmN1ck51bWJlcis9bix0aGlzLmN1ck51bWJlckhhc0V4cERpZ2l0cz10aGlzLmN1ck51bWJlckhhc0V4cH1yZXR1cm4gcn0sZS5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuY3JlYXRlKHRoaXMse3BhcnNlOnt2YWx1ZTpmdW5jdGlvbihyLGUpe3ZvaWQgMD09PWUmJihlPVtdKTtmb3IodmFyIGk9MCxhPU9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZS5jYWxsKHRoaXMscik7aTxhLmxlbmd0aDtpKyspe3ZhciBuPWFbaV0sbz10KG4pO0FycmF5LmlzQXJyYXkobyk/ZS5wdXNoLmFwcGx5KGUsbyk6ZS5wdXNoKG8pfXJldHVybiBlfX19KX0sZX0obCksXz1mdW5jdGlvbih0KXtmdW5jdGlvbiBpKHIpe3ZhciBlPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gZS5jb21tYW5kcz1cInN0cmluZ1wiPT10eXBlb2Ygcj9pLnBhcnNlKHIpOnIsZX1yZXR1cm4gcihpLHQpLGkucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbigpe3JldHVybiBpLmVuY29kZSh0aGlzLmNvbW1hbmRzKX0saS5wcm90b3R5cGUuZ2V0Qm91bmRzPWZ1bmN0aW9uKCl7dmFyIHQ9dS5DQUxDVUxBVEVfQk9VTkRTKCk7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHQpLHR9LGkucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbih0KXtmb3IodmFyIHI9W10sZT0wLGk9dGhpcy5jb21tYW5kcztlPGkubGVuZ3RoO2UrKyl7dmFyIGE9dChpW2VdKTtBcnJheS5pc0FycmF5KGEpP3IucHVzaC5hcHBseShyLGEpOnIucHVzaChhKX1yZXR1cm4gdGhpcy5jb21tYW5kcz1yLHRoaXN9LGkuZW5jb2RlPWZ1bmN0aW9uKHQpe3JldHVybiBlKHQpfSxpLnBhcnNlPWZ1bmN0aW9uKHQpe3ZhciByPW5ldyBmLGU9W107cmV0dXJuIHIucGFyc2UodCxlKSxyLmZpbmlzaChlKSxlfSxpLkNMT1NFX1BBVEg9MSxpLk1PVkVfVE89MixpLkhPUklaX0xJTkVfVE89NCxpLlZFUlRfTElORV9UTz04LGkuTElORV9UTz0xNixpLkNVUlZFX1RPPTMyLGkuU01PT1RIX0NVUlZFX1RPPTY0LGkuUVVBRF9UTz0xMjgsaS5TTU9PVEhfUVVBRF9UTz0yNTYsaS5BUkM9NTEyLGkuTElORV9DT01NQU5EUz1pLkxJTkVfVE98aS5IT1JJWl9MSU5FX1RPfGkuVkVSVF9MSU5FX1RPLGkuRFJBV0lOR19DT01NQU5EUz1pLkhPUklaX0xJTkVfVE98aS5WRVJUX0xJTkVfVE98aS5MSU5FX1RPfGkuQ1VSVkVfVE98aS5TTU9PVEhfQ1VSVkVfVE98aS5RVUFEX1RPfGkuU01PT1RIX1FVQURfVE98aS5BUkMsaX0obCksTj0oKE89e30pW18uTU9WRV9UT109MixPW18uTElORV9UT109MixPW18uSE9SSVpfTElORV9UT109MSxPW18uVkVSVF9MSU5FX1RPXT0xLE9bXy5DTE9TRV9QQVRIXT0wLE9bXy5RVUFEX1RPXT00LE9bXy5TTU9PVEhfUVVBRF9UT109MixPW18uQ1VSVkVfVE9dPTYsT1tfLlNNT09USF9DVVJWRV9UT109NCxPW18uQVJDXT03LE8pO2V4cG9ydHtOIGFzIENPTU1BTkRfQVJHX0NPVU5UUyxfIGFzIFNWR1BhdGhEYXRhLGYgYXMgU1ZHUGF0aERhdGFQYXJzZXIsdSBhcyBTVkdQYXRoRGF0YVRyYW5zZm9ybWVyLGUgYXMgZW5jb2RlU1ZHUGF0aH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TVkdQYXRoRGF0YS5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=